
#include <jni.h>
#include <cstdlib>
#include <iostream>
#include "crclj.h"

namespace crclj {

    JNIEnv *getEnv();
    static jclass getStringClass();
    static jstring getEmptyString();
    static bool debug_j4cpp = false;

    namespace java {
        namespace lang {

            Object::Object() {
                jthis = NULL;
            };

            Object::Object(const Object &objref) {
                jobject _jthis = objref.jthis;
                if (_jthis != NULL) {
                    jthis = getEnv()->NewGlobalRef(_jthis);
                }
            };

            Object::Object(jobject _jthis, bool copy) {
                //                std::cout << "_jthis = " << _jthis << std::endl;
                jthis = NULL;
                if (_jthis != NULL) {
                    JNIEnv *env = getEnv();
                    jobjectRefType ref0 = env->GetObjectRefType(jthis);
                    if (copy || ref0 != JNIGlobalRefType) {
                        jthis = env->NewGlobalRef(_jthis);
                    }
                }
            };

            Object::~Object() {
                if (NULL != jthis) {
                    getEnv()->DeleteGlobalRef(jthis);
                    jthis = NULL;
                }
            };

            jstring Object::toString() {

                if (jthis == NULL) {
                    std::cerr << "Call of method toString of java.lang.Object with jthis == NULL." << std::endl;
                    return NULL;
                }
                JNIEnv *env = getEnv();
                jobjectRefType ref0 = env->GetObjectRefType(jthis);
                if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Object::toString() jthis=",jthis);
                jclass cls = env->GetObjectClass(jthis);
                jstring retVal = NULL;
                if (cls != NULL) {
                    jmethodID mid = env->GetMethodID(cls, "toString", "()Ljava/lang/String;");
                    if (NULL == mid) {
                        std::cerr << "Class ava.lang.Object has no method named toString with signature ()Ljava/lang/String;." << std::endl;
                        return NULL;
                    } else {
                        retVal = (jstring) env->CallObjectMethod(jthis, mid);
                    }
                }
                return retVal;
            }
        }
    }


  namespace crcl{
   namespace base{
   
   // get JNI handle for class crcl.base.DataThingType
   static inline jclass getDataThingTypeClass();
   
   DataThingType::DataThingType(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   DataThingType::DataThingType(const DataThingType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   DataThingType::DataThingType() {
    JNIEnv *env =getEnv();
    static jclass cls = getDataThingTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class DataThingType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new DataThingType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.DataThingType
   DataThingType::~DataThingType() {
   	// Place-holder for later extensibility.
   }

   jstring DataThingType::getName() {

   if(jthis == NULL) {
       std::cerr << "Call of method getName of crcl.base.DataThingType with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," DataThingType::getName jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getName", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.DataThingType has no method named getName with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void DataThingType::setName(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setName of crcl.base.DataThingType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," DataThingType::setName jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setName", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.DataThingType has no method named setName with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewDataThingTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/DataThingType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/DataThingType" << std::endl;
       }
       return clss;
   }
   
   static jclass DataThingTypeClass = NULL;
   static inline jclass getDataThingTypeClass() {
       if (DataThingTypeClass != NULL) {
           return DataThingTypeClass;
       }
       DataThingTypeClass = getNewDataThingTypeClass();
   }
   
   // get JNI handle for class crcl.base.JointDetailsType
   static inline jclass getJointDetailsTypeClass();
   
   JointDetailsType::JointDetailsType(jobject _jthis, bool copy): DataThingType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   JointDetailsType::JointDetailsType(const JointDetailsType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   JointDetailsType::JointDetailsType() {
    JNIEnv *env =getEnv();
    static jclass cls = getJointDetailsTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class JointDetailsType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new JointDetailsType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.JointDetailsType
   JointDetailsType::~JointDetailsType() {
   	// Place-holder for later extensibility.
   }

   static jclass getNewJointDetailsTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/JointDetailsType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/JointDetailsType" << std::endl;
       }
       return clss;
   }
   
   static jclass JointDetailsTypeClass = NULL;
   static inline jclass getJointDetailsTypeClass() {
       if (JointDetailsTypeClass != NULL) {
           return JointDetailsTypeClass;
       }
       JointDetailsTypeClass = getNewJointDetailsTypeClass();
   }
   
   // get JNI handle for class crcl.base.JointSpeedAccelType
   static inline jclass getJointSpeedAccelTypeClass();
   
   JointSpeedAccelType::JointSpeedAccelType(jobject _jthis, bool copy): JointDetailsType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   JointSpeedAccelType::JointSpeedAccelType(const JointSpeedAccelType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   JointSpeedAccelType::JointSpeedAccelType() {
    JNIEnv *env =getEnv();
    static jclass cls = getJointSpeedAccelTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class JointSpeedAccelType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new JointSpeedAccelType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.JointSpeedAccelType
   JointSpeedAccelType::~JointSpeedAccelType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::math::BigDecimal JointSpeedAccelType::getJointSpeed() {

   if(jthis == NULL) {
       std::cerr << "Call of method getJointSpeed of crcl.base.JointSpeedAccelType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JointSpeedAccelType::getJointSpeed jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getJointSpeed", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.JointSpeedAccelType has no method named getJointSpeed with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void JointSpeedAccelType::setJointSpeed(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setJointSpeed of crcl.base.JointSpeedAccelType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JointSpeedAccelType::setJointSpeed jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setJointSpeed", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.JointSpeedAccelType has no method named setJointSpeed with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::math::BigDecimal JointSpeedAccelType::getJointAccel() {

   if(jthis == NULL) {
       std::cerr << "Call of method getJointAccel of crcl.base.JointSpeedAccelType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JointSpeedAccelType::getJointAccel jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getJointAccel", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.JointSpeedAccelType has no method named getJointAccel with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void JointSpeedAccelType::setJointAccel(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setJointAccel of crcl.base.JointSpeedAccelType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JointSpeedAccelType::setJointAccel jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setJointAccel", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.JointSpeedAccelType has no method named setJointAccel with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewJointSpeedAccelTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/JointSpeedAccelType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/JointSpeedAccelType" << std::endl;
       }
       return clss;
   }
   
   static jclass JointSpeedAccelTypeClass = NULL;
   static inline jclass getJointSpeedAccelTypeClass() {
       if (JointSpeedAccelTypeClass != NULL) {
           return JointSpeedAccelTypeClass;
       }
       JointSpeedAccelTypeClass = getNewJointSpeedAccelTypeClass();
   }
   
   // get JNI handle for class crcl.base.CRCLCommandType
   static inline jclass getCRCLCommandTypeClass();
   
   CRCLCommandType::CRCLCommandType(jobject _jthis, bool copy): DataThingType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   CRCLCommandType::CRCLCommandType(const CRCLCommandType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   CRCLCommandType::CRCLCommandType() {
    JNIEnv *env =getEnv();
    static jclass cls = getCRCLCommandTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class CRCLCommandType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new CRCLCommandType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.CRCLCommandType
   CRCLCommandType::~CRCLCommandType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::math::BigInteger CRCLCommandType::getCommandID() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCommandID of crcl.base.CRCLCommandType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLCommandType::getCommandID jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCommandID", "()Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CRCLCommandType has no method named getCommandID with signature ()Ljava/math/BigInteger;." << std::endl;
           ::crclj::java::math::BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigInteger retObject(retVal,false);
    return retObject;
   }
   void CRCLCommandType::setCommandID(::crclj::java::math::BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCommandID of crcl.base.CRCLCommandType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLCommandType::setCommandID jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCommandID", "(Ljava/math/BigInteger;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CRCLCommandType has no method named setCommandID with signature (Ljava/math/BigInteger;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewCRCLCommandTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/CRCLCommandType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/CRCLCommandType" << std::endl;
       }
       return clss;
   }
   
   static jclass CRCLCommandTypeClass = NULL;
   static inline jclass getCRCLCommandTypeClass() {
       if (CRCLCommandTypeClass != NULL) {
           return CRCLCommandTypeClass;
       }
       CRCLCommandTypeClass = getNewCRCLCommandTypeClass();
   }
   
   // get JNI handle for class crcl.base.MiddleCommandType
   static inline jclass getMiddleCommandTypeClass();
   
   MiddleCommandType::MiddleCommandType(jobject _jthis, bool copy): CRCLCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   MiddleCommandType::MiddleCommandType(const MiddleCommandType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   MiddleCommandType::MiddleCommandType() {
    JNIEnv *env =getEnv();
    static jclass cls = getMiddleCommandTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class MiddleCommandType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new MiddleCommandType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.MiddleCommandType
   MiddleCommandType::~MiddleCommandType() {
   	// Place-holder for later extensibility.
   }

   static jclass getNewMiddleCommandTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/MiddleCommandType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/MiddleCommandType" << std::endl;
       }
       return clss;
   }
   
   static jclass MiddleCommandTypeClass = NULL;
   static inline jclass getMiddleCommandTypeClass() {
       if (MiddleCommandTypeClass != NULL) {
           return MiddleCommandTypeClass;
       }
       MiddleCommandTypeClass = getNewMiddleCommandTypeClass();
   }
   
   // get JNI handle for class crcl.base.SetIntermediatePoseToleranceType
   static inline jclass getSetIntermediatePoseToleranceTypeClass();
   
   SetIntermediatePoseToleranceType::SetIntermediatePoseToleranceType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SetIntermediatePoseToleranceType::SetIntermediatePoseToleranceType(const SetIntermediatePoseToleranceType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SetIntermediatePoseToleranceType::SetIntermediatePoseToleranceType() {
    JNIEnv *env =getEnv();
    static jclass cls = getSetIntermediatePoseToleranceTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class SetIntermediatePoseToleranceType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SetIntermediatePoseToleranceType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.SetIntermediatePoseToleranceType
   SetIntermediatePoseToleranceType::~SetIntermediatePoseToleranceType() {
   	// Place-holder for later extensibility.
   }

   void SetIntermediatePoseToleranceType::setTolerance(PoseToleranceType  &poseToleranceType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setTolerance of crcl.base.SetIntermediatePoseToleranceType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetIntermediatePoseToleranceType::setTolerance jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setTolerance", "(Lcrcl/base/PoseToleranceType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetIntermediatePoseToleranceType has no method named setTolerance with signature (Lcrcl/base/PoseToleranceType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,poseToleranceType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   PoseToleranceType SetIntermediatePoseToleranceType::getTolerance() {

   if(jthis == NULL) {
       std::cerr << "Call of method getTolerance of crcl.base.SetIntermediatePoseToleranceType with jthis == NULL." << std::endl;
       PoseToleranceType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetIntermediatePoseToleranceType::getTolerance jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getTolerance", "()Lcrcl/base/PoseToleranceType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetIntermediatePoseToleranceType has no method named getTolerance with signature ()Lcrcl/base/PoseToleranceType;." << std::endl;
           PoseToleranceType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PoseToleranceType retObject(retVal,false);
    return retObject;
   }
   static jclass getNewSetIntermediatePoseToleranceTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/SetIntermediatePoseToleranceType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/SetIntermediatePoseToleranceType" << std::endl;
       }
       return clss;
   }
   
   static jclass SetIntermediatePoseToleranceTypeClass = NULL;
   static inline jclass getSetIntermediatePoseToleranceTypeClass() {
       if (SetIntermediatePoseToleranceTypeClass != NULL) {
           return SetIntermediatePoseToleranceTypeClass;
       }
       SetIntermediatePoseToleranceTypeClass = getNewSetIntermediatePoseToleranceTypeClass();
   }
   
   // get JNI handle for class crcl.base.SetEndPoseToleranceType
   static inline jclass getSetEndPoseToleranceTypeClass();
   
   SetEndPoseToleranceType::SetEndPoseToleranceType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SetEndPoseToleranceType::SetEndPoseToleranceType(const SetEndPoseToleranceType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SetEndPoseToleranceType::SetEndPoseToleranceType() {
    JNIEnv *env =getEnv();
    static jclass cls = getSetEndPoseToleranceTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class SetEndPoseToleranceType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SetEndPoseToleranceType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.SetEndPoseToleranceType
   SetEndPoseToleranceType::~SetEndPoseToleranceType() {
   	// Place-holder for later extensibility.
   }

   void SetEndPoseToleranceType::setTolerance(PoseToleranceType  &poseToleranceType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setTolerance of crcl.base.SetEndPoseToleranceType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetEndPoseToleranceType::setTolerance jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setTolerance", "(Lcrcl/base/PoseToleranceType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetEndPoseToleranceType has no method named setTolerance with signature (Lcrcl/base/PoseToleranceType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,poseToleranceType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   PoseToleranceType SetEndPoseToleranceType::getTolerance() {

   if(jthis == NULL) {
       std::cerr << "Call of method getTolerance of crcl.base.SetEndPoseToleranceType with jthis == NULL." << std::endl;
       PoseToleranceType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetEndPoseToleranceType::getTolerance jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getTolerance", "()Lcrcl/base/PoseToleranceType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetEndPoseToleranceType has no method named getTolerance with signature ()Lcrcl/base/PoseToleranceType;." << std::endl;
           PoseToleranceType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PoseToleranceType retObject(retVal,false);
    return retObject;
   }
   static jclass getNewSetEndPoseToleranceTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/SetEndPoseToleranceType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/SetEndPoseToleranceType" << std::endl;
       }
       return clss;
   }
   
   static jclass SetEndPoseToleranceTypeClass = NULL;
   static inline jclass getSetEndPoseToleranceTypeClass() {
       if (SetEndPoseToleranceTypeClass != NULL) {
           return SetEndPoseToleranceTypeClass;
       }
       SetEndPoseToleranceTypeClass = getNewSetEndPoseToleranceTypeClass();
   }
   
   // get JNI handle for class crcl.base.EndCanonType
   static inline jclass getEndCanonTypeClass();
   
   EndCanonType::EndCanonType(jobject _jthis, bool copy): CRCLCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   EndCanonType::EndCanonType(const EndCanonType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   EndCanonType::EndCanonType() {
    JNIEnv *env =getEnv();
    static jclass cls = getEndCanonTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class EndCanonType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new EndCanonType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.EndCanonType
   EndCanonType::~EndCanonType() {
   	// Place-holder for later extensibility.
   }

   static jclass getNewEndCanonTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/EndCanonType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/EndCanonType" << std::endl;
       }
       return clss;
   }
   
   static jclass EndCanonTypeClass = NULL;
   static inline jclass getEndCanonTypeClass() {
       if (EndCanonTypeClass != NULL) {
           return EndCanonTypeClass;
       }
       EndCanonTypeClass = getNewEndCanonTypeClass();
   }
   
   // get JNI handle for class crcl.base.SetRobotParametersType
   static inline jclass getSetRobotParametersTypeClass();
   
   SetRobotParametersType::SetRobotParametersType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SetRobotParametersType::SetRobotParametersType(const SetRobotParametersType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SetRobotParametersType::SetRobotParametersType() {
    JNIEnv *env =getEnv();
    static jclass cls = getSetRobotParametersTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class SetRobotParametersType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SetRobotParametersType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.SetRobotParametersType
   SetRobotParametersType::~SetRobotParametersType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::util::List SetRobotParametersType::getParameterSetting() {

   if(jthis == NULL) {
       std::cerr << "Call of method getParameterSetting of crcl.base.SetRobotParametersType with jthis == NULL." << std::endl;
       ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetRobotParametersType::getParameterSetting jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getParameterSetting", "()Ljava/util/List;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetRobotParametersType has no method named getParameterSetting with signature ()Ljava/util/List;." << std::endl;
           ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::util::List retObject(retVal,false);
    return retObject;
   }
   static jclass getNewSetRobotParametersTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/SetRobotParametersType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/SetRobotParametersType" << std::endl;
       }
       return clss;
   }
   
   static jclass SetRobotParametersTypeClass = NULL;
   static inline jclass getSetRobotParametersTypeClass() {
       if (SetRobotParametersTypeClass != NULL) {
           return SetRobotParametersTypeClass;
       }
       SetRobotParametersTypeClass = getNewSetRobotParametersTypeClass();
   }
  } // end namespace base

   namespace utils{
   
   // get JNI handle for class crcl.utils.DefaultMain
   static inline jclass getDefaultMainClass();
   
   DefaultMain::DefaultMain(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   DefaultMain::DefaultMain(const DefaultMain &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   DefaultMain::DefaultMain() {
    JNIEnv *env =getEnv();
    static jclass cls = getDefaultMainClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class DefaultMain has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new DefaultMain jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.DefaultMain
   DefaultMain::~DefaultMain() {
   	// Place-holder for later extensibility.
   }

   void DefaultMain::main(jobjectArray stringArray_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getDefaultMainClass();
   
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "main", "([Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.DefaultMain has no method named main with signature ([Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallStaticVoidMethod( cls, mid ,stringArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void DefaultMain::main(int argc, const char **argv) {
           if(argc <1 || argv==NULL) {
                main(NULL);
           } else {
               JNIEnv *env =getEnv();
               jclass strClss = getStringClass();
               jobjectArray stringArray = env->NewObjectArray(argc,strClss,getEmptyString());
               for(int i = 0; i < argc; i++) {
                   jstring str = env->NewStringUTF(argv[i]);
                   env->SetObjectArrayElement(stringArray,i,str);
               }
                main(stringArray);
               for(int i = 0; i < argc; i++) {
                   jobject str = env->GetObjectArrayElement(stringArray,i);
                   jobjectRefType ref = env->GetObjectRefType(str);
                   if(ref == JNIGlobalRefType) {
                       env->DeleteGlobalRef(str);
                   }
               }
               jobjectRefType ref = env->GetObjectRefType(stringArray);
               if(ref == JNIGlobalRefType) {
                   env->DeleteGlobalRef(stringArray);
               }
               return ;
           }
   }
   static jclass getNewDefaultMainClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/DefaultMain");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/DefaultMain" << std::endl;
       }
       return clss;
   }
   
   static jclass DefaultMainClass = NULL;
   static inline jclass getDefaultMainClass() {
       if (DefaultMainClass != NULL) {
           return DefaultMainClass;
       }
       DefaultMainClass = getNewDefaultMainClass();
   }
   
   // get JNI handle for class crcl.utils.PoseToleranceChecker
   static inline jclass getPoseToleranceCheckerClass();
   
   PoseToleranceChecker::PoseToleranceChecker(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   PoseToleranceChecker::PoseToleranceChecker(const PoseToleranceChecker &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }

   // Destructor for crcl.utils.PoseToleranceChecker
   PoseToleranceChecker::~PoseToleranceChecker() {
   	// Place-holder for later extensibility.
   }

   jboolean PoseToleranceChecker::containsNull(::crclj::crcl::base::PoseType  &poseType_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getPoseToleranceCheckerClass();
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "containsNull", "(Lcrcl/base/PoseType;)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PoseToleranceChecker has no method named containsNull with signature (Lcrcl/base/PoseType;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallStaticBooleanMethod( cls, mid ,poseType_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PoseToleranceChecker::containsNull(::crclj::crcl::base::VectorType  &vectorType_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getPoseToleranceCheckerClass();
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "containsNull", "(Lcrcl/base/VectorType;)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PoseToleranceChecker has no method named containsNull with signature (Lcrcl/base/VectorType;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallStaticBooleanMethod( cls, mid ,vectorType_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PoseToleranceChecker::containsNull(::crclj::crcl::base::PointType  &pointType_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getPoseToleranceCheckerClass();
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "containsNull", "(Lcrcl/base/PointType;)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PoseToleranceChecker has no method named containsNull with signature (Lcrcl/base/PointType;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallStaticBooleanMethod( cls, mid ,pointType_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PoseToleranceChecker::containsNull(::crclj::crcl::base::PoseToleranceType  &poseToleranceType_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getPoseToleranceCheckerClass();
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "containsNull", "(Lcrcl/base/PoseToleranceType;)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PoseToleranceChecker has no method named containsNull with signature (Lcrcl/base/PoseToleranceType;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallStaticBooleanMethod( cls, mid ,poseToleranceType_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PoseToleranceChecker::isInTolerance(::crclj::crcl::base::PointType  &pointType_0,::crclj::crcl::base::PointType  &pointType_1,::crclj::crcl::base::PoseToleranceType  &poseToleranceType_2) {

   JNIEnv *env =getEnv();
   static jclass cls = getPoseToleranceCheckerClass();
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "isInTolerance", "(Lcrcl/base/PointType;Lcrcl/base/PointType;Lcrcl/base/PoseToleranceType;)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PoseToleranceChecker has no method named isInTolerance with signature (Lcrcl/base/PointType;Lcrcl/base/PointType;Lcrcl/base/PoseToleranceType;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallStaticBooleanMethod( cls, mid ,pointType_0.jthis,pointType_1.jthis,poseToleranceType_2.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PoseToleranceChecker::isInTolerance(::crclj::crcl::base::VectorType  &vectorType_0,::crclj::crcl::base::VectorType  &vectorType_1,::crclj::java::math::BigDecimal  &bigDecimal_2,::crclj::crcl::base::AngleUnitEnumType  &angleUnitEnumType_3) {

   JNIEnv *env =getEnv();
   static jclass cls = getPoseToleranceCheckerClass();
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "isInTolerance", "(Lcrcl/base/VectorType;Lcrcl/base/VectorType;Ljava/math/BigDecimal;Lcrcl/base/AngleUnitEnumType;)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PoseToleranceChecker has no method named isInTolerance with signature (Lcrcl/base/VectorType;Lcrcl/base/VectorType;Ljava/math/BigDecimal;Lcrcl/base/AngleUnitEnumType;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallStaticBooleanMethod( cls, mid ,vectorType_0.jthis,vectorType_1.jthis,bigDecimal_2.jthis,angleUnitEnumType_3.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PoseToleranceChecker::isInTolerance(::crclj::java::math::BigDecimal  &bigDecimal_0,::crclj::java::math::BigDecimal  &bigDecimal_1,::crclj::java::math::BigDecimal  &bigDecimal_2) {

   JNIEnv *env =getEnv();
   static jclass cls = getPoseToleranceCheckerClass();
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "isInTolerance", "(Ljava/math/BigDecimal;Ljava/math/BigDecimal;Ljava/math/BigDecimal;)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PoseToleranceChecker has no method named isInTolerance with signature (Ljava/math/BigDecimal;Ljava/math/BigDecimal;Ljava/math/BigDecimal;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallStaticBooleanMethod( cls, mid ,bigDecimal_0.jthis,bigDecimal_1.jthis,bigDecimal_2.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PoseToleranceChecker::isInTolerance(::crclj::crcl::base::PoseType  &poseType_0,::crclj::crcl::base::PoseType  &poseType_1,::crclj::crcl::base::PoseToleranceType  &poseToleranceType_2,::crclj::crcl::base::AngleUnitEnumType  &angleUnitEnumType_3) {

   JNIEnv *env =getEnv();
   static jclass cls = getPoseToleranceCheckerClass();
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "isInTolerance", "(Lcrcl/base/PoseType;Lcrcl/base/PoseType;Lcrcl/base/PoseToleranceType;Lcrcl/base/AngleUnitEnumType;)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PoseToleranceChecker has no method named isInTolerance with signature (Lcrcl/base/PoseType;Lcrcl/base/PoseType;Lcrcl/base/PoseToleranceType;Lcrcl/base/AngleUnitEnumType;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallStaticBooleanMethod( cls, mid ,poseType_0.jthis,poseType_1.jthis,poseToleranceType_2.jthis,angleUnitEnumType_3.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewPoseToleranceCheckerClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/PoseToleranceChecker");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/PoseToleranceChecker" << std::endl;
       }
       return clss;
   }
   
   static jclass PoseToleranceCheckerClass = NULL;
   static inline jclass getPoseToleranceCheckerClass() {
       if (PoseToleranceCheckerClass != NULL) {
           return PoseToleranceCheckerClass;
       }
       PoseToleranceCheckerClass = getNewPoseToleranceCheckerClass();
   }
  } // end namespace utils
 } // end namespace crcl

  namespace java{
   namespace lang{
   
   // get JNI handle for class java.lang.Enum
   static inline jclass getEnumClass();
   
   Enum::Enum(jobject _jthis, bool copy): Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   Enum::Enum(const Enum &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }

   // Destructor for java.lang.Enum
   Enum::~Enum() {
   	// Place-holder for later extensibility.
   }

   jstring Enum::name() {

   if(jthis == NULL) {
       std::cerr << "Call of method name of java.lang.Enum with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Enum::name jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "name", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.lang.Enum has no method named name with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Enum::equals(Object  &object_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method equals of java.lang.Enum with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Enum::equals jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
       if (NULL == mid) {
           std::cerr << "Class java.lang.Enum has no method named equals with signature (Ljava/lang/Object;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,object_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring Enum::toString() {

   if(jthis == NULL) {
       std::cerr << "Call of method toString of java.lang.Enum with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Enum::toString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toString", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.lang.Enum has no method named toString with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint Enum::hashCode() {

   if(jthis == NULL) {
       std::cerr << "Call of method hashCode of java.lang.Enum with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Enum::hashCode jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "hashCode", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.lang.Enum has no method named hashCode with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint Enum::compareTo(Enum  &enum_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method compareTo of java.lang.Enum with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Enum::compareTo jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "compareTo", "(Ljava/lang/Enum;)I");
       if (NULL == mid) {
           std::cerr << "Class java.lang.Enum has no method named compareTo with signature (Ljava/lang/Enum;)I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid ,enum_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint Enum::ordinal() {

   if(jthis == NULL) {
       std::cerr << "Call of method ordinal of java.lang.Enum with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Enum::ordinal jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "ordinal", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.lang.Enum has no method named ordinal with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewEnumClass() {
       jclass clss = getEnv()->FindClass("java/lang/Enum");
       if (NULL == clss) {
           std::cerr << " Can't find class java/lang/Enum" << std::endl;
       }
       return clss;
   }
   
   static jclass EnumClass = NULL;
   static inline jclass getEnumClass() {
       if (EnumClass != NULL) {
           return EnumClass;
       }
       EnumClass = getNewEnumClass();
   }
  } // end namespace lang
 } // end namespace java

  namespace crcl{
   namespace utils{
   
   // get JNI handle for class crcl.utils.SimRobotEnum
   static inline jclass getSimRobotEnumClass();
   
   SimRobotEnum::SimRobotEnum(jobject _jthis, bool copy): ::crclj::java::lang::Enum(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SimRobotEnum::SimRobotEnum(const SimRobotEnum &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }

   // Destructor for crcl.utils.SimRobotEnum
   SimRobotEnum::~SimRobotEnum() {
   	// Place-holder for later extensibility.
   }

   jobjectArray SimRobotEnum::values() {

   JNIEnv *env =getEnv();
   static jclass cls = getSimRobotEnumClass();
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "values", "()[Lcrcl/utils/SimRobotEnum;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimRobotEnum has no method named values with signature ()[Lcrcl/utils/SimRobotEnum;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallStaticObjectMethod( cls, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   SimRobotEnum SimRobotEnum::valueOf(jstring string_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getSimRobotEnumClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "valueOf", "(Ljava/lang/String;)Lcrcl/utils/SimRobotEnum;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimRobotEnum has no method named valueOf with signature (Ljava/lang/String;)Lcrcl/utils/SimRobotEnum;." << std::endl;
           SimRobotEnum nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,string_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    SimRobotEnum retObject(retVal,false);
    return retObject;
   }
   static jclass getNewSimRobotEnumClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/SimRobotEnum");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/SimRobotEnum" << std::endl;
       }
       return clss;
   }
   
   static jclass SimRobotEnumClass = NULL;
   static inline jclass getSimRobotEnumClass() {
       if (SimRobotEnumClass != NULL) {
           return SimRobotEnumClass;
       }
       SimRobotEnumClass = getNewSimRobotEnumClass();
   }
   
   // get JNI handle for class crcl.utils.PendantClientOuterStub
   static inline jclass getPendantClientOuterStubClass();
   
   PendantClientOuterStub::PendantClientOuterStub(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   PendantClientOuterStub::PendantClientOuterStub(const PendantClientOuterStub &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   PendantClientOuterStub::PendantClientOuterStub() {
    JNIEnv *env =getEnv();
    static jclass cls = getPendantClientOuterStubClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class PendantClientOuterStub has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PendantClientOuterStub jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PendantClientOuterStub::PendantClientOuterStub(jboolean boolean_0,jboolean boolean_1,jstring string_2,jint int_3,jboolean boolean_4,jboolean boolean_5,jboolean boolean_6,jboolean boolean_7,jboolean boolean_8,jboolean boolean_9) {
    JNIEnv *env =getEnv();
    static jclass cls = getPendantClientOuterStubClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(ZZLjava/lang/String;IZZZZZZ)V");
        if (NULL == mid) {
            std::cerr << "Class PendantClientOuterStub has no method constructor signature (ZZLjava/lang/String;IZZZZZZ)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,boolean_0,boolean_1,string_2,int_3,boolean_4,boolean_5,boolean_6,boolean_7,boolean_8,boolean_9);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PendantClientOuterStub jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.PendantClientOuterStub
   PendantClientOuterStub::~PendantClientOuterStub() {
   	// Place-holder for later extensibility.
   }

   void PendantClientOuterStub::finishConnect() {

   if(jthis == NULL) {
       std::cerr << "Call of method finishConnect of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::finishConnect jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "finishConnect", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named finishConnect with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClientOuterStub::showMessage(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method showMessage of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::showMessage jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "showMessage", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named showMessage with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClientOuterStub::showMessage(::crclj::java::lang::Throwable  &throwable_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method showMessage of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::showMessage jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "showMessage", "(Ljava/lang/Throwable;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named showMessage with signature (Ljava/lang/Throwable;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,throwable_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   jboolean PendantClientOuterStub::showDebugMessage(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method showDebugMessage of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::showDebugMessage jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "showDebugMessage", "(Ljava/lang/String;)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named showDebugMessage with signature (Ljava/lang/String;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PendantClientOuterStub::validateXmlSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method validateXmlSelected of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::validateXmlSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "validateXmlSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named validateXmlSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PendantClientOuterStub::replaceStateSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method replaceStateSelected of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::replaceStateSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "replaceStateSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named replaceStateSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PendantClientOuterStub::finishDisconnect() {

   if(jthis == NULL) {
       std::cerr << "Call of method finishDisconnect of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::finishDisconnect jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "finishDisconnect", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named finishDisconnect with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClientOuterStub::finishSetStatus() {

   if(jthis == NULL) {
       std::cerr << "Call of method finishSetStatus of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::finishSetStatus jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "finishSetStatus", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named finishSetStatus with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClientOuterStub::checkXmlQuery(CRCLSocket  &cRCLSocket_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method checkXmlQuery of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::checkXmlQuery jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "checkXmlQuery", "(Lcrcl/utils/CRCLSocket;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named checkXmlQuery with signature (Lcrcl/utils/CRCLSocket;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,cRCLSocket_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClientOuterStub::stopPollTimer() {

   if(jthis == NULL) {
       std::cerr << "Call of method stopPollTimer of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::stopPollTimer jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "stopPollTimer", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named stopPollTimer with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClientOuterStub::checkPollSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method checkPollSelected of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::checkPollSelected jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "checkPollSelected", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named checkPollSelected with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jboolean PendantClientOuterStub::isDebugWaitForDoneSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isDebugWaitForDoneSelected of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::isDebugWaitForDoneSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isDebugWaitForDoneSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named isDebugWaitForDoneSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PendantClientOuterStub::isDebugSendCommandSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isDebugSendCommandSelected of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::isDebugSendCommandSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isDebugSendCommandSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named isDebugSendCommandSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PendantClientOuterStub::isDebugReadStatusSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isDebugReadStatusSelected of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::isDebugReadStatusSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isDebugReadStatusSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named isDebugReadStatusSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PendantClientOuterStub::showCurrentProgramLine(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method showCurrentProgramLine of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::showCurrentProgramLine jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "showCurrentProgramLine", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named showCurrentProgramLine with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClientOuterStub::finishOpenXmlProgramFile(::crclj::java::io::File  &file_0,::crclj::crcl::base::CRCLProgramType  &cRCLProgramType_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method finishOpenXmlProgramFile of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::finishOpenXmlProgramFile jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "finishOpenXmlProgramFile", "(Ljava/io/File;Lcrcl/base/CRCLProgramType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named finishOpenXmlProgramFile with signature (Ljava/io/File;Lcrcl/base/CRCLProgramType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,file_0.jthis,cRCLProgramType_1.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::crcl::base::CRCLProgramType PendantClientOuterStub::editProgram(::crclj::crcl::base::CRCLProgramType  &cRCLProgramType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method editProgram of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       ::crclj::crcl::base::CRCLProgramType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::editProgram jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "editProgram", "(Lcrcl/base/CRCLProgramType;)Lcrcl/base/CRCLProgramType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named editProgram with signature (Lcrcl/base/CRCLProgramType;)Lcrcl/base/CRCLProgramType;." << std::endl;
           ::crclj::crcl::base::CRCLProgramType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,cRCLProgramType_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::CRCLProgramType retObject(retVal,false);
    return retObject;
   }
   void PendantClientOuterStub::showLastProgramLineExecTimeMillisDists(jlong long_0,jdouble double_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method showLastProgramLineExecTimeMillisDists of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::showLastProgramLineExecTimeMillisDists jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "showLastProgramLineExecTimeMillisDists", "(JD)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named showLastProgramLineExecTimeMillisDists with signature (JD)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,long_0,double_1 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean PendantClientOuterStub::isRecordPoseSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isRecordPoseSelected of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::isRecordPoseSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isRecordPoseSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named isRecordPoseSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PendantClientOuterStub::isEXISelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isEXISelected of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::isEXISelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isEXISelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named isEXISelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PendantClientOuterStub::isUseReadStatusThreadSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isUseReadStatusThreadSelected of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::isUseReadStatusThreadSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isUseReadStatusThreadSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named isUseReadStatusThreadSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring PendantClientOuterStub::getHost() {

   if(jthis == NULL) {
       std::cerr << "Call of method getHost of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::getHost jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getHost", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named getHost with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint PendantClientOuterStub::getPort() {

   if(jthis == NULL) {
       std::cerr << "Call of method getPort of crcl.utils.PendantClientOuterStub with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientOuterStub::getPort jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getPort", "()I");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientOuterStub has no method named getPort with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewPendantClientOuterStubClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/PendantClientOuterStub");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/PendantClientOuterStub" << std::endl;
       }
       return clss;
   }
   
   static jclass PendantClientOuterStubClass = NULL;
   static inline jclass getPendantClientOuterStubClass() {
       if (PendantClientOuterStubClass != NULL) {
           return PendantClientOuterStubClass;
       }
       PendantClientOuterStubClass = getNewPendantClientOuterStubClass();
   }
  } // end namespace utils
 } // end namespace crcl

  namespace java{
   namespace awt{
   
   // get JNI handle for class java.awt.Component
   static inline jclass getComponentClass();
   
   Component::Component(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   Component::Component(const Component &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }

   // Destructor for java.awt.Component
   Component::~Component() {
   	// Place-holder for later extensibility.
   }

   void Component::validate() {

   if(jthis == NULL) {
       std::cerr << "Call of method validate of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::validate jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "validate", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named validate with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jboolean Component::isValid() {

   if(jthis == NULL) {
       std::cerr << "Call of method isValid of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::isValid jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isValid", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named isValid with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Component::addNotify() {

   if(jthis == NULL) {
       std::cerr << "Call of method addNotify of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::addNotify jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "addNotify", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named addNotify with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Component::removeNotify() {

   if(jthis == NULL) {
       std::cerr << "Call of method removeNotify of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::removeNotify jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "removeNotify", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named removeNotify with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::lang::Object Component::getTreeLock() {

   if(jthis == NULL) {
       std::cerr << "Call of method getTreeLock of java.awt.Component with jthis == NULL." << std::endl;
       ::crclj::java::lang::Object nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::getTreeLock jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getTreeLock", "()Ljava/lang/Object;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named getTreeLock with signature ()Ljava/lang/Object;." << std::endl;
           ::crclj::java::lang::Object nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::lang::Object retObject(retVal,false);
    return retObject;
   }
   jboolean Component::isDisplayable() {

   if(jthis == NULL) {
       std::cerr << "Call of method isDisplayable of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::isDisplayable jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isDisplayable", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named isDisplayable with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Component::setLocation(jint int_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method setLocation of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::setLocation jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setLocation", "(II)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named setLocation with signature (II)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0,int_1 );
       }
   }
   releaseEnv(env);
   
   }
   void Component::reshape(jint int_0,jint int_1,jint int_2,jint int_3) {

   if(jthis == NULL) {
       std::cerr << "Call of method reshape of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::reshape jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "reshape", "(IIII)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named reshape with signature (IIII)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0,int_1,int_2,int_3 );
       }
   }
   releaseEnv(env);
   
   }
   void Component::show(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method show of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::show jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "show", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named show with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   void Component::show() {

   if(jthis == NULL) {
       std::cerr << "Call of method show of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::show jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "show", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named show with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Component::hide() {

   if(jthis == NULL) {
       std::cerr << "Call of method hide of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::hide jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "hide", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named hide with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jboolean Component::isFocusCycleRoot(Container  &container_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method isFocusCycleRoot of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::isFocusCycleRoot jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isFocusCycleRoot", "(Ljava/awt/Container;)Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named isFocusCycleRoot with signature (Ljava/awt/Container;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,container_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   Container Component::getFocusCycleRootAncestor() {

   if(jthis == NULL) {
       std::cerr << "Call of method getFocusCycleRootAncestor of java.awt.Component with jthis == NULL." << std::endl;
       Container nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::getFocusCycleRootAncestor jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getFocusCycleRootAncestor", "()Ljava/awt/Container;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named getFocusCycleRootAncestor with signature ()Ljava/awt/Container;." << std::endl;
           Container nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Container retObject(retVal,false);
    return retObject;
   }
   jboolean Component::isShowing() {

   if(jthis == NULL) {
       std::cerr << "Call of method isShowing of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::isShowing jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isShowing", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named isShowing with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Component::setBounds(jint int_0,jint int_1,jint int_2,jint int_3) {

   if(jthis == NULL) {
       std::cerr << "Call of method setBounds of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::setBounds jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setBounds", "(IIII)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named setBounds with signature (IIII)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0,int_1,int_2,int_3 );
       }
   }
   releaseEnv(env);
   
   }
   jint Component::getX() {

   if(jthis == NULL) {
       std::cerr << "Call of method getX of java.awt.Component with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::getX jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getX", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named getX with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint Component::getY() {

   if(jthis == NULL) {
       std::cerr << "Call of method getY of java.awt.Component with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::getY jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getY", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named getY with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Component::isMinimumSizeSet() {

   if(jthis == NULL) {
       std::cerr << "Call of method isMinimumSizeSet of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::isMinimumSizeSet jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isMinimumSizeSet", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named isMinimumSizeSet with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Component::isVisible() {

   if(jthis == NULL) {
       std::cerr << "Call of method isVisible of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::isVisible jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isVisible", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named isVisible with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Component::requestFocus() {

   if(jthis == NULL) {
       std::cerr << "Call of method requestFocus of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::requestFocus jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "requestFocus", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named requestFocus with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jint Component::getWidth() {

   if(jthis == NULL) {
       std::cerr << "Call of method getWidth of java.awt.Component with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::getWidth jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getWidth", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named getWidth with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint Component::getHeight() {

   if(jthis == NULL) {
       std::cerr << "Call of method getHeight of java.awt.Component with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::getHeight jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getHeight", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named getHeight with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Component::doLayout() {

   if(jthis == NULL) {
       std::cerr << "Call of method doLayout of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::doLayout jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "doLayout", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named doLayout with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jfloat Component::getAlignmentX() {

   if(jthis == NULL) {
       std::cerr << "Call of method getAlignmentX of java.awt.Component with jthis == NULL." << std::endl;
       return (jfloat) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::getAlignmentX jthis=",jthis);
   jfloat retVal= (jfloat) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getAlignmentX", "()F");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named getAlignmentX with signature ()F." << std::endl;
           return (jfloat) -1.0;
       } else {
           retVal= (jfloat)  env->CallFloatMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jfloat Component::getAlignmentY() {

   if(jthis == NULL) {
       std::cerr << "Call of method getAlignmentY of java.awt.Component with jthis == NULL." << std::endl;
       return (jfloat) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::getAlignmentY jthis=",jthis);
   jfloat retVal= (jfloat) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getAlignmentY", "()F");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named getAlignmentY with signature ()F." << std::endl;
           return (jfloat) -1.0;
       } else {
           retVal= (jfloat)  env->CallFloatMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   Component Component::getComponentAt(jint int_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method getComponentAt of java.awt.Component with jthis == NULL." << std::endl;
       Component nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::getComponentAt jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getComponentAt", "(II)Ljava/awt/Component;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named getComponentAt with signature (II)Ljava/awt/Component;." << std::endl;
           Component nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,int_0,int_1 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Component retObject(retVal,false);
    return retObject;
   }
   Component Component::locate(jint int_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method locate of java.awt.Component with jthis == NULL." << std::endl;
       Component nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::locate jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "locate", "(II)Ljava/awt/Component;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named locate with signature (II)Ljava/awt/Component;." << std::endl;
           Component nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,int_0,int_1 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Component retObject(retVal,false);
    return retObject;
   }
   jboolean Component::areFocusTraversalKeysSet(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method areFocusTraversalKeysSet of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::areFocusTraversalKeysSet jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "areFocusTraversalKeysSet", "(I)Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named areFocusTraversalKeysSet with signature (I)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Component::isEnabled() {

   if(jthis == NULL) {
       std::cerr << "Call of method isEnabled of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::isEnabled jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isEnabled", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named isEnabled with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Component::isFocusable() {

   if(jthis == NULL) {
       std::cerr << "Call of method isFocusable of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::isFocusable jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isFocusable", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named isFocusable with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Component::isLightweight() {

   if(jthis == NULL) {
       std::cerr << "Call of method isLightweight of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::isLightweight jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isLightweight", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named isLightweight with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Component::isFocusOwner() {

   if(jthis == NULL) {
       std::cerr << "Call of method isFocusOwner of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::isFocusOwner jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isFocusOwner", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named isFocusOwner with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Component::transferFocus() {

   if(jthis == NULL) {
       std::cerr << "Call of method transferFocus of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::transferFocus jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "transferFocus", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named transferFocus with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jboolean Component::isPreferredSizeSet() {

   if(jthis == NULL) {
       std::cerr << "Call of method isPreferredSizeSet of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::isPreferredSizeSet jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isPreferredSizeSet", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named isPreferredSizeSet with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Component::isMaximumSizeSet() {

   if(jthis == NULL) {
       std::cerr << "Call of method isMaximumSizeSet of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::isMaximumSizeSet jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isMaximumSizeSet", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named isMaximumSizeSet with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Component::move(jint int_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method move of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::move jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "move", "(II)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named move with signature (II)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0,int_1 );
       }
   }
   releaseEnv(env);
   
   }
   void Component::invalidate() {

   if(jthis == NULL) {
       std::cerr << "Call of method invalidate of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::invalidate jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "invalidate", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named invalidate with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Component::repaint() {

   if(jthis == NULL) {
       std::cerr << "Call of method repaint of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::repaint jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "repaint", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named repaint with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Component::repaint(jlong long_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method repaint of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::repaint jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "repaint", "(J)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named repaint with signature (J)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,long_0 );
       }
   }
   releaseEnv(env);
   
   }
   void Component::repaint(jint int_0,jint int_1,jint int_2,jint int_3) {

   if(jthis == NULL) {
       std::cerr << "Call of method repaint of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::repaint jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "repaint", "(IIII)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named repaint with signature (IIII)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0,int_1,int_2,int_3 );
       }
   }
   releaseEnv(env);
   
   }
   void Component::repaint(jlong long_0,jint int_1,jint int_2,jint int_3,jint int_4) {

   if(jthis == NULL) {
       std::cerr << "Call of method repaint of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::repaint jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "repaint", "(JIIII)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named repaint with signature (JIIII)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,long_0,int_1,int_2,int_3,int_4 );
       }
   }
   releaseEnv(env);
   
   }
   void Component::firePropertyChange(jstring string_0,jlong long_1,jlong long_2) {

   if(jthis == NULL) {
       std::cerr << "Call of method firePropertyChange of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::firePropertyChange jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "firePropertyChange", "(Ljava/lang/String;JJ)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named firePropertyChange with signature (Ljava/lang/String;JJ)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0,long_1,long_2 );
       }
   }
   releaseEnv(env);
   
   }
   void Component::firePropertyChange(jstring string_0,jbyte byte_1,jbyte byte_2) {

   if(jthis == NULL) {
       std::cerr << "Call of method firePropertyChange of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::firePropertyChange jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "firePropertyChange", "(Ljava/lang/String;BB)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named firePropertyChange with signature (Ljava/lang/String;BB)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0,byte_1,byte_2 );
       }
   }
   releaseEnv(env);
   
   }
   void Component::firePropertyChange(jstring string_0,jchar char_1,jchar char_2) {

   if(jthis == NULL) {
       std::cerr << "Call of method firePropertyChange of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::firePropertyChange jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "firePropertyChange", "(Ljava/lang/String;CC)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named firePropertyChange with signature (Ljava/lang/String;CC)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0,char_1,char_2 );
       }
   }
   releaseEnv(env);
   
   }
   void Component::firePropertyChange(jstring string_0,jfloat float_1,jfloat float_2) {

   if(jthis == NULL) {
       std::cerr << "Call of method firePropertyChange of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::firePropertyChange jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "firePropertyChange", "(Ljava/lang/String;FF)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named firePropertyChange with signature (Ljava/lang/String;FF)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0,float_1,float_2 );
       }
   }
   releaseEnv(env);
   
   }
   void Component::firePropertyChange(jstring string_0,jshort short_1,jshort short_2) {

   if(jthis == NULL) {
       std::cerr << "Call of method firePropertyChange of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::firePropertyChange jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "firePropertyChange", "(Ljava/lang/String;SS)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named firePropertyChange with signature (Ljava/lang/String;SS)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0,short_1,short_2 );
       }
   }
   releaseEnv(env);
   
   }
   void Component::firePropertyChange(jstring string_0,jdouble double_1,jdouble double_2) {

   if(jthis == NULL) {
       std::cerr << "Call of method firePropertyChange of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::firePropertyChange jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "firePropertyChange", "(Ljava/lang/String;DD)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named firePropertyChange with signature (Ljava/lang/String;DD)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0,double_1,double_2 );
       }
   }
   releaseEnv(env);
   
   }
   void Component::transferFocusBackward() {

   if(jthis == NULL) {
       std::cerr << "Call of method transferFocusBackward of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::transferFocusBackward jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "transferFocusBackward", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named transferFocusBackward with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Component::setEnabled(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setEnabled of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::setEnabled jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setEnabled", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named setEnabled with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean Component::isDoubleBuffered() {

   if(jthis == NULL) {
       std::cerr << "Call of method isDoubleBuffered of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::isDoubleBuffered jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isDoubleBuffered", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named isDoubleBuffered with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Component::enableInputMethods(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method enableInputMethods of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::enableInputMethods jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "enableInputMethods", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named enableInputMethods with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean Component::isForegroundSet() {

   if(jthis == NULL) {
       std::cerr << "Call of method isForegroundSet of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::isForegroundSet jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isForegroundSet", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named isForegroundSet with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Component::isBackgroundSet() {

   if(jthis == NULL) {
       std::cerr << "Call of method isBackgroundSet of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::isBackgroundSet jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isBackgroundSet", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named isBackgroundSet with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Component::isFontSet() {

   if(jthis == NULL) {
       std::cerr << "Call of method isFontSet of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::isFontSet jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isFontSet", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named isFontSet with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint Component::getBaseline(jint int_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method getBaseline of java.awt.Component with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::getBaseline jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getBaseline", "(II)I");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named getBaseline with signature (II)I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid ,int_0,int_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Component::revalidate() {

   if(jthis == NULL) {
       std::cerr << "Call of method revalidate of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::revalidate jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "revalidate", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named revalidate with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jboolean Component::isCursorSet() {

   if(jthis == NULL) {
       std::cerr << "Call of method isCursorSet of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::isCursorSet jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isCursorSet", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named isCursorSet with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Component::setIgnoreRepaint(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setIgnoreRepaint of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::setIgnoreRepaint jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setIgnoreRepaint", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named setIgnoreRepaint with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean Component::getIgnoreRepaint() {

   if(jthis == NULL) {
       std::cerr << "Call of method getIgnoreRepaint of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::getIgnoreRepaint jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getIgnoreRepaint", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named getIgnoreRepaint with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Component::inside(jint int_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method inside of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::inside jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "inside", "(II)Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named inside with signature (II)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,int_0,int_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Component::isFocusTraversable() {

   if(jthis == NULL) {
       std::cerr << "Call of method isFocusTraversable of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::isFocusTraversable jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isFocusTraversable", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named isFocusTraversable with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Component::setFocusable(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setFocusable of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::setFocusable jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setFocusable", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named setFocusable with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   void Component::setFocusTraversalKeysEnabled(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setFocusTraversalKeysEnabled of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::setFocusTraversalKeysEnabled jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setFocusTraversalKeysEnabled", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named setFocusTraversalKeysEnabled with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean Component::getFocusTraversalKeysEnabled() {

   if(jthis == NULL) {
       std::cerr << "Call of method getFocusTraversalKeysEnabled of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::getFocusTraversalKeysEnabled jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getFocusTraversalKeysEnabled", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named getFocusTraversalKeysEnabled with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Component::requestFocusInWindow() {

   if(jthis == NULL) {
       std::cerr << "Call of method requestFocusInWindow of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::requestFocusInWindow jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "requestFocusInWindow", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named requestFocusInWindow with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Component::nextFocus() {

   if(jthis == NULL) {
       std::cerr << "Call of method nextFocus of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::nextFocus jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "nextFocus", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named nextFocus with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Component::transferFocusUpCycle() {

   if(jthis == NULL) {
       std::cerr << "Call of method transferFocusUpCycle of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::transferFocusUpCycle jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "transferFocusUpCycle", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named transferFocusUpCycle with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jboolean Component::hasFocus() {

   if(jthis == NULL) {
       std::cerr << "Call of method hasFocus of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::hasFocus jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "hasFocus", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named hasFocus with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Component::layout() {

   if(jthis == NULL) {
       std::cerr << "Call of method layout of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::layout jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "layout", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named layout with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Component::setVisible(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setVisible of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::setVisible jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setVisible", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named setVisible with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jstring Component::toString() {

   if(jthis == NULL) {
       std::cerr << "Call of method toString of java.awt.Component with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::toString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toString", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named toString with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring Component::getName() {

   if(jthis == NULL) {
       std::cerr << "Call of method getName of java.awt.Component with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::getName jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getName", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named getName with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Component::contains(jint int_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method contains of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::contains jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "contains", "(II)Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named contains with signature (II)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,int_0,int_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   Container Component::getParent() {

   if(jthis == NULL) {
       std::cerr << "Call of method getParent of java.awt.Component with jthis == NULL." << std::endl;
       Container nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::getParent jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getParent", "()Ljava/awt/Container;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named getParent with signature ()Ljava/awt/Container;." << std::endl;
           Container nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Container retObject(retVal,false);
    return retObject;
   }
   void Component::setName(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setName of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::setName jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setName", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named setName with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   void Component::list() {

   if(jthis == NULL) {
       std::cerr << "Call of method list of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::list jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "list", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named list with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Component::list(::crclj::java::io::PrintStream  &printStream_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method list of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::list jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "list", "(Ljava/io/PrintStream;)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named list with signature (Ljava/io/PrintStream;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,printStream_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void Component::list(::crclj::java::io::PrintStream  &printStream_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method list of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::list jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "list", "(Ljava/io/PrintStream;I)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named list with signature (Ljava/io/PrintStream;I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,printStream_0.jthis,int_1 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean Component::isOpaque() {

   if(jthis == NULL) {
       std::cerr << "Call of method isOpaque of java.awt.Component with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::isOpaque jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isOpaque", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named isOpaque with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Component::setSize(jint int_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method setSize of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::setSize jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setSize", "(II)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named setSize with signature (II)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0,int_1 );
       }
   }
   releaseEnv(env);
   
   }
   void Component::resize(jint int_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method resize of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::resize jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "resize", "(II)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named resize with signature (II)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0,int_1 );
       }
   }
   releaseEnv(env);
   
   }
   void Component::enable() {

   if(jthis == NULL) {
       std::cerr << "Call of method enable of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::enable jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "enable", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named enable with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Component::enable(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method enable of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::enable jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "enable", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named enable with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   void Component::disable() {

   if(jthis == NULL) {
       std::cerr << "Call of method disable of java.awt.Component with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Component::disable jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "disable", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Component has no method named disable with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewComponentClass() {
       jclass clss = getEnv()->FindClass("java/awt/Component");
       if (NULL == clss) {
           std::cerr << " Can't find class java/awt/Component" << std::endl;
       }
       return clss;
   }
   
   static jclass ComponentClass = NULL;
   static inline jclass getComponentClass() {
       if (ComponentClass != NULL) {
           return ComponentClass;
       }
       ComponentClass = getNewComponentClass();
   }
   
   // get JNI handle for class java.awt.Container
   static inline jclass getContainerClass();
   
   Container::Container(jobject _jthis, bool copy): Component(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   Container::Container(const Container &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   Container::Container() {
    JNIEnv *env =getEnv();
    static jclass cls = getContainerClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class Container has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Container jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for java.awt.Container
   Container::~Container() {
   	// Place-holder for later extensibility.
   }

   void Container::validate() {

   if(jthis == NULL) {
       std::cerr << "Call of method validate of java.awt.Container with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::validate jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "validate", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named validate with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Container::addNotify() {

   if(jthis == NULL) {
       std::cerr << "Call of method addNotify of java.awt.Container with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::addNotify jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "addNotify", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named addNotify with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Container::removeNotify() {

   if(jthis == NULL) {
       std::cerr << "Call of method removeNotify of java.awt.Container with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::removeNotify jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "removeNotify", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named removeNotify with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Container::setFocusCycleRoot(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setFocusCycleRoot of java.awt.Container with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::setFocusCycleRoot jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setFocusCycleRoot", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named setFocusCycleRoot with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean Container::isFocusCycleRoot(Container  &container_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method isFocusCycleRoot of java.awt.Container with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::isFocusCycleRoot jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isFocusCycleRoot", "(Ljava/awt/Container;)Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named isFocusCycleRoot with signature (Ljava/awt/Container;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,container_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Container::isFocusCycleRoot() {

   if(jthis == NULL) {
       std::cerr << "Call of method isFocusCycleRoot of java.awt.Container with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::isFocusCycleRoot jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isFocusCycleRoot", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named isFocusCycleRoot with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Container::isValidateRoot() {

   if(jthis == NULL) {
       std::cerr << "Call of method isValidateRoot of java.awt.Container with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::isValidateRoot jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isValidateRoot", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named isValidateRoot with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint Container::getComponentCount() {

   if(jthis == NULL) {
       std::cerr << "Call of method getComponentCount of java.awt.Container with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::getComponentCount jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getComponentCount", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named getComponentCount with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   Component Container::getComponent(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method getComponent of java.awt.Container with jthis == NULL." << std::endl;
       Component nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::getComponent jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getComponent", "(I)Ljava/awt/Component;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named getComponent with signature (I)Ljava/awt/Component;." << std::endl;
           Component nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Component retObject(retVal,false);
    return retObject;
   }
   jint Container::countComponents() {

   if(jthis == NULL) {
       std::cerr << "Call of method countComponents of java.awt.Container with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::countComponents jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "countComponents", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named countComponents with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jobjectArray Container::getComponents() {

   if(jthis == NULL) {
       std::cerr << "Call of method getComponents of java.awt.Container with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::getComponents jthis=",jthis);
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getComponents", "()[Ljava/awt/Component;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named getComponents with signature ()[Ljava/awt/Component;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Container::setComponentZOrder(Component  &component_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method setComponentZOrder of java.awt.Container with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::setComponentZOrder jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setComponentZOrder", "(Ljava/awt/Component;I)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named setComponentZOrder with signature (Ljava/awt/Component;I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,component_0.jthis,int_1 );
       }
   }
   releaseEnv(env);
   
   }
   jint Container::getComponentZOrder(Component  &component_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method getComponentZOrder of java.awt.Container with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::getComponentZOrder jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getComponentZOrder", "(Ljava/awt/Component;)I");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named getComponentZOrder with signature (Ljava/awt/Component;)I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid ,component_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Container::doLayout() {

   if(jthis == NULL) {
       std::cerr << "Call of method doLayout of java.awt.Container with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::doLayout jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "doLayout", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named doLayout with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jfloat Container::getAlignmentX() {

   if(jthis == NULL) {
       std::cerr << "Call of method getAlignmentX of java.awt.Container with jthis == NULL." << std::endl;
       return (jfloat) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::getAlignmentX jthis=",jthis);
   jfloat retVal= (jfloat) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getAlignmentX", "()F");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named getAlignmentX with signature ()F." << std::endl;
           return (jfloat) -1.0;
       } else {
           retVal= (jfloat)  env->CallFloatMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jfloat Container::getAlignmentY() {

   if(jthis == NULL) {
       std::cerr << "Call of method getAlignmentY of java.awt.Container with jthis == NULL." << std::endl;
       return (jfloat) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::getAlignmentY jthis=",jthis);
   jfloat retVal= (jfloat) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getAlignmentY", "()F");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named getAlignmentY with signature ()F." << std::endl;
           return (jfloat) -1.0;
       } else {
           retVal= (jfloat)  env->CallFloatMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   Component Container::getComponentAt(jint int_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method getComponentAt of java.awt.Container with jthis == NULL." << std::endl;
       Component nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::getComponentAt jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getComponentAt", "(II)Ljava/awt/Component;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named getComponentAt with signature (II)Ljava/awt/Component;." << std::endl;
           Component nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,int_0,int_1 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Component retObject(retVal,false);
    return retObject;
   }
   Component Container::locate(jint int_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method locate of java.awt.Container with jthis == NULL." << std::endl;
       Component nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::locate jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "locate", "(II)Ljava/awt/Component;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named locate with signature (II)Ljava/awt/Component;." << std::endl;
           Component nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,int_0,int_1 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Component retObject(retVal,false);
    return retObject;
   }
   Component Container::findComponentAt(jint int_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method findComponentAt of java.awt.Container with jthis == NULL." << std::endl;
       Component nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::findComponentAt jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "findComponentAt", "(II)Ljava/awt/Component;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named findComponentAt with signature (II)Ljava/awt/Component;." << std::endl;
           Component nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,int_0,int_1 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Component retObject(retVal,false);
    return retObject;
   }
   jboolean Container::isAncestorOf(Component  &component_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method isAncestorOf of java.awt.Container with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::isAncestorOf jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isAncestorOf", "(Ljava/awt/Component;)Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named isAncestorOf with signature (Ljava/awt/Component;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,component_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Container::areFocusTraversalKeysSet(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method areFocusTraversalKeysSet of java.awt.Container with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::areFocusTraversalKeysSet jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "areFocusTraversalKeysSet", "(I)Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named areFocusTraversalKeysSet with signature (I)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Container::isFocusTraversalPolicySet() {

   if(jthis == NULL) {
       std::cerr << "Call of method isFocusTraversalPolicySet of java.awt.Container with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::isFocusTraversalPolicySet jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isFocusTraversalPolicySet", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named isFocusTraversalPolicySet with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Container::setFocusTraversalPolicyProvider(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setFocusTraversalPolicyProvider of java.awt.Container with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::setFocusTraversalPolicyProvider jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setFocusTraversalPolicyProvider", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named setFocusTraversalPolicyProvider with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean Container::isFocusTraversalPolicyProvider() {

   if(jthis == NULL) {
       std::cerr << "Call of method isFocusTraversalPolicyProvider of java.awt.Container with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::isFocusTraversalPolicyProvider jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isFocusTraversalPolicyProvider", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named isFocusTraversalPolicyProvider with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Container::transferFocusDownCycle() {

   if(jthis == NULL) {
       std::cerr << "Call of method transferFocusDownCycle of java.awt.Container with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::transferFocusDownCycle jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "transferFocusDownCycle", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named transferFocusDownCycle with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Container::invalidate() {

   if(jthis == NULL) {
       std::cerr << "Call of method invalidate of java.awt.Container with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::invalidate jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "invalidate", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named invalidate with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Container::layout() {

   if(jthis == NULL) {
       std::cerr << "Call of method layout of java.awt.Container with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::layout jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "layout", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named layout with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   Component Container::add(Component  &component_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method add of java.awt.Container with jthis == NULL." << std::endl;
       Component nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::add jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "add", "(Ljava/awt/Component;)Ljava/awt/Component;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named add with signature (Ljava/awt/Component;)Ljava/awt/Component;." << std::endl;
           Component nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,component_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Component retObject(retVal,false);
    return retObject;
   }
   void Container::add(Component  &component_0,::crclj::java::lang::Object  &object_1,jint int_2) {

   if(jthis == NULL) {
       std::cerr << "Call of method add of java.awt.Container with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::add jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "add", "(Ljava/awt/Component;Ljava/lang/Object;I)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named add with signature (Ljava/awt/Component;Ljava/lang/Object;I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,component_0.jthis,object_1.jthis,int_2 );
       }
   }
   releaseEnv(env);
   
   }
   Component Container::add(jstring string_0,Component  &component_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method add of java.awt.Container with jthis == NULL." << std::endl;
       Component nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::add jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "add", "(Ljava/lang/String;Ljava/awt/Component;)Ljava/awt/Component;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named add with signature (Ljava/lang/String;Ljava/awt/Component;)Ljava/awt/Component;." << std::endl;
           Component nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,string_0,component_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Component retObject(retVal,false);
    return retObject;
   }
   Component Container::add(Component  &component_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method add of java.awt.Container with jthis == NULL." << std::endl;
       Component nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::add jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "add", "(Ljava/awt/Component;I)Ljava/awt/Component;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named add with signature (Ljava/awt/Component;I)Ljava/awt/Component;." << std::endl;
           Component nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,component_0.jthis,int_1 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Component retObject(retVal,false);
    return retObject;
   }
   void Container::add(Component  &component_0,::crclj::java::lang::Object  &object_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method add of java.awt.Container with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::add jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "add", "(Ljava/awt/Component;Ljava/lang/Object;)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named add with signature (Ljava/awt/Component;Ljava/lang/Object;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,component_0.jthis,object_1.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void Container::remove(Component  &component_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method remove of java.awt.Container with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::remove jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "remove", "(Ljava/awt/Component;)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named remove with signature (Ljava/awt/Component;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,component_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void Container::remove(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method remove of java.awt.Container with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::remove jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "remove", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named remove with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   void Container::list(::crclj::java::io::PrintStream  &printStream_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method list of java.awt.Container with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::list jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "list", "(Ljava/io/PrintStream;I)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named list with signature (Ljava/io/PrintStream;I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,printStream_0.jthis,int_1 );
       }
   }
   releaseEnv(env);
   
   }
   void Container::removeAll() {

   if(jthis == NULL) {
       std::cerr << "Call of method removeAll of java.awt.Container with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Container::removeAll jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "removeAll", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Container has no method named removeAll with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewContainerClass() {
       jclass clss = getEnv()->FindClass("java/awt/Container");
       if (NULL == clss) {
           std::cerr << " Can't find class java/awt/Container" << std::endl;
       }
       return clss;
   }
   
   static jclass ContainerClass = NULL;
   static inline jclass getContainerClass() {
       if (ContainerClass != NULL) {
           return ContainerClass;
       }
       ContainerClass = getNewContainerClass();
   }
  } // end namespace awt
 } // end namespace java

  namespace javax{
   namespace swing{
   
   // get JNI handle for class javax.swing.JComponent
   static inline jclass getJComponentClass();
   
   JComponent::JComponent(jobject _jthis, bool copy): ::crclj::java::awt::Container(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   JComponent::JComponent(const JComponent &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   JComponent::JComponent() {
    JNIEnv *env =getEnv();
    static jclass cls = getJComponentClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class JComponent has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new JComponent jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for javax.swing.JComponent
   JComponent::~JComponent() {
   	// Place-holder for later extensibility.
   }

   void JComponent::setInheritsPopupMenu(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setInheritsPopupMenu of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::setInheritsPopupMenu jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setInheritsPopupMenu", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named setInheritsPopupMenu with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean JComponent::getInheritsPopupMenu() {

   if(jthis == NULL) {
       std::cerr << "Call of method getInheritsPopupMenu of javax.swing.JComponent with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::getInheritsPopupMenu jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getInheritsPopupMenu", "()Z");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named getInheritsPopupMenu with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean JComponent::isPaintingTile() {

   if(jthis == NULL) {
       std::cerr << "Call of method isPaintingTile of javax.swing.JComponent with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::isPaintingTile jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isPaintingTile", "()Z");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named isPaintingTile with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean JComponent::isPaintingForPrint() {

   if(jthis == NULL) {
       std::cerr << "Call of method isPaintingForPrint of javax.swing.JComponent with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::isPaintingForPrint jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isPaintingForPrint", "()Z");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named isPaintingForPrint with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean JComponent::isManagingFocus() {

   if(jthis == NULL) {
       std::cerr << "Call of method isManagingFocus of javax.swing.JComponent with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::isManagingFocus jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isManagingFocus", "()Z");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named isManagingFocus with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void JComponent::setNextFocusableComponent(::crclj::java::awt::Component  &component_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setNextFocusableComponent of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::setNextFocusableComponent jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setNextFocusableComponent", "(Ljava/awt/Component;)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named setNextFocusableComponent with signature (Ljava/awt/Component;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,component_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::awt::Component JComponent::getNextFocusableComponent() {

   if(jthis == NULL) {
       std::cerr << "Call of method getNextFocusableComponent of javax.swing.JComponent with jthis == NULL." << std::endl;
       ::crclj::java::awt::Component nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::getNextFocusableComponent jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getNextFocusableComponent", "()Ljava/awt/Component;");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named getNextFocusableComponent with signature ()Ljava/awt/Component;." << std::endl;
           ::crclj::java::awt::Component nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::awt::Component retObject(retVal,false);
    return retObject;
   }
   void JComponent::setRequestFocusEnabled(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setRequestFocusEnabled of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::setRequestFocusEnabled jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setRequestFocusEnabled", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named setRequestFocusEnabled with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean JComponent::isRequestFocusEnabled() {

   if(jthis == NULL) {
       std::cerr << "Call of method isRequestFocusEnabled of javax.swing.JComponent with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::isRequestFocusEnabled jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isRequestFocusEnabled", "()Z");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named isRequestFocusEnabled with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void JComponent::grabFocus() {

   if(jthis == NULL) {
       std::cerr << "Call of method grabFocus of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::grabFocus jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "grabFocus", "()V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named grabFocus with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void JComponent::setVerifyInputWhenFocusTarget(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setVerifyInputWhenFocusTarget of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::setVerifyInputWhenFocusTarget jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setVerifyInputWhenFocusTarget", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named setVerifyInputWhenFocusTarget with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean JComponent::getVerifyInputWhenFocusTarget() {

   if(jthis == NULL) {
       std::cerr << "Call of method getVerifyInputWhenFocusTarget of javax.swing.JComponent with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::getVerifyInputWhenFocusTarget jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getVerifyInputWhenFocusTarget", "()Z");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named getVerifyInputWhenFocusTarget with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void JComponent::setAlignmentY(jfloat float_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setAlignmentY of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::setAlignmentY jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setAlignmentY", "(F)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named setAlignmentY with signature (F)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,float_0 );
       }
   }
   releaseEnv(env);
   
   }
   void JComponent::setAlignmentX(jfloat float_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setAlignmentX of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::setAlignmentX jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setAlignmentX", "(F)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named setAlignmentX with signature (F)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,float_0 );
       }
   }
   releaseEnv(env);
   
   }
   void JComponent::setDebugGraphicsOptions(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setDebugGraphicsOptions of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::setDebugGraphicsOptions jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setDebugGraphicsOptions", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named setDebugGraphicsOptions with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   jint JComponent::getDebugGraphicsOptions() {

   if(jthis == NULL) {
       std::cerr << "Call of method getDebugGraphicsOptions of javax.swing.JComponent with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::getDebugGraphicsOptions jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getDebugGraphicsOptions", "()I");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named getDebugGraphicsOptions with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void JComponent::resetKeyboardActions() {

   if(jthis == NULL) {
       std::cerr << "Call of method resetKeyboardActions of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::resetKeyboardActions jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "resetKeyboardActions", "()V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named resetKeyboardActions with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jboolean JComponent::requestDefaultFocus() {

   if(jthis == NULL) {
       std::cerr << "Call of method requestDefaultFocus of javax.swing.JComponent with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::requestDefaultFocus jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "requestDefaultFocus", "()Z");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named requestDefaultFocus with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void JComponent::setToolTipText(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setToolTipText of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::setToolTipText jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setToolTipText", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named setToolTipText with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   jstring JComponent::getToolTipText() {

   if(jthis == NULL) {
       std::cerr << "Call of method getToolTipText of javax.swing.JComponent with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::getToolTipText jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getToolTipText", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named getToolTipText with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void JComponent::setAutoscrolls(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setAutoscrolls of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::setAutoscrolls jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setAutoscrolls", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named setAutoscrolls with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean JComponent::getAutoscrolls() {

   if(jthis == NULL) {
       std::cerr << "Call of method getAutoscrolls of javax.swing.JComponent with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::getAutoscrolls jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getAutoscrolls", "()Z");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named getAutoscrolls with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   ::crclj::java::lang::Object JComponent::getClientProperty(::crclj::java::lang::Object  &object_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method getClientProperty of javax.swing.JComponent with jthis == NULL." << std::endl;
       ::crclj::java::lang::Object nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::getClientProperty jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getClientProperty", "(Ljava/lang/Object;)Ljava/lang/Object;");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named getClientProperty with signature (Ljava/lang/Object;)Ljava/lang/Object;." << std::endl;
           ::crclj::java::lang::Object nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,object_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::lang::Object retObject(retVal,false);
    return retObject;
   }
   void JComponent::putClientProperty(::crclj::java::lang::Object  &object_0,::crclj::java::lang::Object  &object_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method putClientProperty of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::putClientProperty jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "putClientProperty", "(Ljava/lang/Object;Ljava/lang/Object;)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named putClientProperty with signature (Ljava/lang/Object;Ljava/lang/Object;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,object_0.jthis,object_1.jthis );
       }
   }
   releaseEnv(env);
   
   }
   jboolean JComponent::isLightweightComponent(::crclj::java::awt::Component  &component_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getJComponentClass();
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "isLightweightComponent", "(Ljava/awt/Component;)Z");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named isLightweightComponent with signature (Ljava/awt/Component;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallStaticBooleanMethod( cls, mid ,component_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   ::crclj::java::awt::Container JComponent::getTopLevelAncestor() {

   if(jthis == NULL) {
       std::cerr << "Call of method getTopLevelAncestor of javax.swing.JComponent with jthis == NULL." << std::endl;
       ::crclj::java::awt::Container nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::getTopLevelAncestor jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getTopLevelAncestor", "()Ljava/awt/Container;");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named getTopLevelAncestor with signature ()Ljava/awt/Container;." << std::endl;
           ::crclj::java::awt::Container nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::awt::Container retObject(retVal,false);
    return retObject;
   }
   jboolean JComponent::isOptimizedDrawingEnabled() {

   if(jthis == NULL) {
       std::cerr << "Call of method isOptimizedDrawingEnabled of javax.swing.JComponent with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::isOptimizedDrawingEnabled jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isOptimizedDrawingEnabled", "()Z");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named isOptimizedDrawingEnabled with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void JComponent::paintImmediately(jint int_0,jint int_1,jint int_2,jint int_3) {

   if(jthis == NULL) {
       std::cerr << "Call of method paintImmediately of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::paintImmediately jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "paintImmediately", "(IIII)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named paintImmediately with signature (IIII)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0,int_1,int_2,int_3 );
       }
   }
   releaseEnv(env);
   
   }
   void JComponent::addNotify() {

   if(jthis == NULL) {
       std::cerr << "Call of method addNotify of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::addNotify jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "addNotify", "()V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named addNotify with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void JComponent::removeNotify() {

   if(jthis == NULL) {
       std::cerr << "Call of method removeNotify of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::removeNotify jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "removeNotify", "()V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named removeNotify with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void JComponent::reshape(jint int_0,jint int_1,jint int_2,jint int_3) {

   if(jthis == NULL) {
       std::cerr << "Call of method reshape of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::reshape jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "reshape", "(IIII)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named reshape with signature (IIII)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0,int_1,int_2,int_3 );
       }
   }
   releaseEnv(env);
   
   }
   void JComponent::hide() {

   if(jthis == NULL) {
       std::cerr << "Call of method hide of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::hide jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "hide", "()V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named hide with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jboolean JComponent::isValidateRoot() {

   if(jthis == NULL) {
       std::cerr << "Call of method isValidateRoot of javax.swing.JComponent with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::isValidateRoot jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isValidateRoot", "()Z");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named isValidateRoot with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint JComponent::getX() {

   if(jthis == NULL) {
       std::cerr << "Call of method getX of javax.swing.JComponent with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::getX jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getX", "()I");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named getX with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint JComponent::getY() {

   if(jthis == NULL) {
       std::cerr << "Call of method getY of javax.swing.JComponent with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::getY jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getY", "()I");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named getY with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void JComponent::requestFocus() {

   if(jthis == NULL) {
       std::cerr << "Call of method requestFocus of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::requestFocus jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "requestFocus", "()V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named requestFocus with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jboolean JComponent::requestFocus(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method requestFocus of javax.swing.JComponent with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::requestFocus jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "requestFocus", "(Z)Z");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named requestFocus with signature (Z)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint JComponent::getWidth() {

   if(jthis == NULL) {
       std::cerr << "Call of method getWidth of javax.swing.JComponent with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::getWidth jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getWidth", "()I");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named getWidth with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint JComponent::getHeight() {

   if(jthis == NULL) {
       std::cerr << "Call of method getHeight of javax.swing.JComponent with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::getHeight jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getHeight", "()I");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named getHeight with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jfloat JComponent::getAlignmentX() {

   if(jthis == NULL) {
       std::cerr << "Call of method getAlignmentX of javax.swing.JComponent with jthis == NULL." << std::endl;
       return (jfloat) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::getAlignmentX jthis=",jthis);
   jfloat retVal= (jfloat) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getAlignmentX", "()F");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named getAlignmentX with signature ()F." << std::endl;
           return (jfloat) -1.0;
       } else {
           retVal= (jfloat)  env->CallFloatMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jfloat JComponent::getAlignmentY() {

   if(jthis == NULL) {
       std::cerr << "Call of method getAlignmentY of javax.swing.JComponent with jthis == NULL." << std::endl;
       return (jfloat) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::getAlignmentY jthis=",jthis);
   jfloat retVal= (jfloat) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getAlignmentY", "()F");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named getAlignmentY with signature ()F." << std::endl;
           return (jfloat) -1.0;
       } else {
           retVal= (jfloat)  env->CallFloatMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void JComponent::repaint(jlong long_0,jint int_1,jint int_2,jint int_3,jint int_4) {

   if(jthis == NULL) {
       std::cerr << "Call of method repaint of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::repaint jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "repaint", "(JIIII)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named repaint with signature (JIIII)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,long_0,int_1,int_2,int_3,int_4 );
       }
   }
   releaseEnv(env);
   
   }
   void JComponent::setOpaque(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setOpaque of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::setOpaque jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setOpaque", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named setOpaque with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   void JComponent::firePropertyChange(jstring string_0,jchar char_1,jchar char_2) {

   if(jthis == NULL) {
       std::cerr << "Call of method firePropertyChange of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::firePropertyChange jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "firePropertyChange", "(Ljava/lang/String;CC)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named firePropertyChange with signature (Ljava/lang/String;CC)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0,char_1,char_2 );
       }
   }
   releaseEnv(env);
   
   }
   void JComponent::firePropertyChange(jstring string_0,jint int_1,jint int_2) {

   if(jthis == NULL) {
       std::cerr << "Call of method firePropertyChange of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::firePropertyChange jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "firePropertyChange", "(Ljava/lang/String;II)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named firePropertyChange with signature (Ljava/lang/String;II)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0,int_1,int_2 );
       }
   }
   releaseEnv(env);
   
   }
   void JComponent::firePropertyChange(jstring string_0,jboolean boolean_1,jboolean boolean_2) {

   if(jthis == NULL) {
       std::cerr << "Call of method firePropertyChange of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::firePropertyChange jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "firePropertyChange", "(Ljava/lang/String;ZZ)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named firePropertyChange with signature (Ljava/lang/String;ZZ)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0,boolean_1,boolean_2 );
       }
   }
   releaseEnv(env);
   
   }
   void JComponent::setEnabled(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setEnabled of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::setEnabled jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setEnabled", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named setEnabled with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean JComponent::isDoubleBuffered() {

   if(jthis == NULL) {
       std::cerr << "Call of method isDoubleBuffered of javax.swing.JComponent with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::isDoubleBuffered jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isDoubleBuffered", "()Z");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named isDoubleBuffered with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint JComponent::getBaseline(jint int_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method getBaseline of javax.swing.JComponent with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::getBaseline jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getBaseline", "(II)I");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named getBaseline with signature (II)I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid ,int_0,int_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void JComponent::revalidate() {

   if(jthis == NULL) {
       std::cerr << "Call of method revalidate of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::revalidate jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "revalidate", "()V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named revalidate with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jboolean JComponent::requestFocusInWindow() {

   if(jthis == NULL) {
       std::cerr << "Call of method requestFocusInWindow of javax.swing.JComponent with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::requestFocusInWindow jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "requestFocusInWindow", "()Z");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named requestFocusInWindow with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void JComponent::updateUI() {

   if(jthis == NULL) {
       std::cerr << "Call of method updateUI of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::updateUI jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updateUI", "()V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named updateUI with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jstring JComponent::getUIClassID() {

   if(jthis == NULL) {
       std::cerr << "Call of method getUIClassID of javax.swing.JComponent with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::getUIClassID jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getUIClassID", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named getUIClassID with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void JComponent::setDoubleBuffered(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setDoubleBuffered of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::setDoubleBuffered jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setDoubleBuffered", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named setDoubleBuffered with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   void JComponent::setVisible(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setVisible of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::setVisible jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setVisible", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named setVisible with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean JComponent::contains(jint int_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method contains of javax.swing.JComponent with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::contains jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "contains", "(II)Z");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named contains with signature (II)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,int_0,int_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean JComponent::isOpaque() {

   if(jthis == NULL) {
       std::cerr << "Call of method isOpaque of javax.swing.JComponent with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::isOpaque jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isOpaque", "()Z");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named isOpaque with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void JComponent::enable() {

   if(jthis == NULL) {
       std::cerr << "Call of method enable of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::enable jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "enable", "()V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named enable with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void JComponent::disable() {

   if(jthis == NULL) {
       std::cerr << "Call of method disable of javax.swing.JComponent with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JComponent::disable jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "disable", "()V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JComponent has no method named disable with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewJComponentClass() {
       jclass clss = getEnv()->FindClass("javax/swing/JComponent");
       if (NULL == clss) {
           std::cerr << " Can't find class javax/swing/JComponent" << std::endl;
       }
       return clss;
   }
   
   static jclass JComponentClass = NULL;
   static inline jclass getJComponentClass() {
       if (JComponentClass != NULL) {
           return JComponentClass;
       }
       JComponentClass = getNewJComponentClass();
   }
   
   // get JNI handle for class javax.swing.JPanel
   static inline jclass getJPanelClass();
   
   JPanel::JPanel(jobject _jthis, bool copy): JComponent(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   JPanel::JPanel(const JPanel &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   JPanel::JPanel() {
    JNIEnv *env =getEnv();
    static jclass cls = getJPanelClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class JPanel has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new JPanel jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   JPanel::JPanel(jboolean boolean_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getJPanelClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Z)V");
        if (NULL == mid) {
            std::cerr << "Class JPanel has no method constructor signature (Z)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,boolean_0);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new JPanel jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for javax.swing.JPanel
   JPanel::~JPanel() {
   	// Place-holder for later extensibility.
   }

   void JPanel::updateUI() {

   if(jthis == NULL) {
       std::cerr << "Call of method updateUI of javax.swing.JPanel with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JPanel::updateUI jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updateUI", "()V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JPanel has no method named updateUI with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jstring JPanel::getUIClassID() {

   if(jthis == NULL) {
       std::cerr << "Call of method getUIClassID of javax.swing.JPanel with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JPanel::getUIClassID jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getUIClassID", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JPanel has no method named getUIClassID with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewJPanelClass() {
       jclass clss = getEnv()->FindClass("javax/swing/JPanel");
       if (NULL == clss) {
           std::cerr << " Can't find class javax/swing/JPanel" << std::endl;
       }
       return clss;
   }
   
   static jclass JPanelClass = NULL;
   static inline jclass getJPanelClass() {
       if (JPanelClass != NULL) {
           return JPanelClass;
       }
       JPanelClass = getNewJPanelClass();
   }
  } // end namespace swing
 } // end namespace javax

  namespace crcl{
   namespace utils{
   
   // get JNI handle for class crcl.utils.OverHeadJPanel
   static inline jclass getOverHeadJPanelClass();
   
   OverHeadJPanel::OverHeadJPanel(jobject _jthis, bool copy): ::crclj::javax::swing::JPanel(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   OverHeadJPanel::OverHeadJPanel(const OverHeadJPanel &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   OverHeadJPanel::OverHeadJPanel() {
    JNIEnv *env =getEnv();
    static jclass cls = getOverHeadJPanelClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class OverHeadJPanel has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new OverHeadJPanel jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.OverHeadJPanel
   OverHeadJPanel::~OverHeadJPanel() {
   	// Place-holder for later extensibility.
   }

   SimRobotEnum OverHeadJPanel::getRobotType() {

   if(jthis == NULL) {
       std::cerr << "Call of method getRobotType of crcl.utils.OverHeadJPanel with jthis == NULL." << std::endl;
       SimRobotEnum nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," OverHeadJPanel::getRobotType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getRobotType", "()Lcrcl/utils/SimRobotEnum;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.OverHeadJPanel has no method named getRobotType with signature ()Lcrcl/utils/SimRobotEnum;." << std::endl;
           SimRobotEnum nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    SimRobotEnum retObject(retVal,false);
    return retObject;
   }
   void OverHeadJPanel::setRobotType(SimRobotEnum  &simRobotEnum_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setRobotType of crcl.utils.OverHeadJPanel with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," OverHeadJPanel::setRobotType jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setRobotType", "(Lcrcl/utils/SimRobotEnum;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.OverHeadJPanel has no method named setRobotType with signature (Lcrcl/utils/SimRobotEnum;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,simRobotEnum_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   jdoubleArray OverHeadJPanel::getJointvals() {

   if(jthis == NULL) {
       std::cerr << "Call of method getJointvals of crcl.utils.OverHeadJPanel with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," OverHeadJPanel::getJointvals jthis=",jthis);
   jdoubleArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getJointvals", "()[D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.OverHeadJPanel has no method named getJointvals with signature ()[D." << std::endl;
           return NULL;
       } else {
           retVal= (jdoubleArray)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void OverHeadJPanel::setJointvals(jdoubleArray doubleArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setJointvals of crcl.utils.OverHeadJPanel with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," OverHeadJPanel::setJointvals jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setJointvals", "([D)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.OverHeadJPanel has no method named setJointvals with signature ([D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,doubleArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void OverHeadJPanel::setSeglengths(jdoubleArray doubleArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setSeglengths of crcl.utils.OverHeadJPanel with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," OverHeadJPanel::setSeglengths jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setSeglengths", "([D)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.OverHeadJPanel has no method named setSeglengths with signature ([D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,doubleArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewOverHeadJPanelClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/OverHeadJPanel");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/OverHeadJPanel" << std::endl;
       }
       return clss;
   }
   
   static jclass OverHeadJPanelClass = NULL;
   static inline jclass getOverHeadJPanelClass() {
       if (OverHeadJPanelClass != NULL) {
           return OverHeadJPanelClass;
       }
       OverHeadJPanelClass = getNewOverHeadJPanelClass();
   }
  } // end namespace utils

   namespace base{
   
   // get JNI handle for class crcl.base.CloseToolChangerType
   static inline jclass getCloseToolChangerTypeClass();
   
   CloseToolChangerType::CloseToolChangerType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   CloseToolChangerType::CloseToolChangerType(const CloseToolChangerType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   CloseToolChangerType::CloseToolChangerType() {
    JNIEnv *env =getEnv();
    static jclass cls = getCloseToolChangerTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class CloseToolChangerType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new CloseToolChangerType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.CloseToolChangerType
   CloseToolChangerType::~CloseToolChangerType() {
   	// Place-holder for later extensibility.
   }

   static jclass getNewCloseToolChangerTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/CloseToolChangerType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/CloseToolChangerType" << std::endl;
       }
       return clss;
   }
   
   static jclass CloseToolChangerTypeClass = NULL;
   static inline jclass getCloseToolChangerTypeClass() {
       if (CloseToolChangerTypeClass != NULL) {
           return CloseToolChangerTypeClass;
       }
       CloseToolChangerTypeClass = getNewCloseToolChangerTypeClass();
   }
   
   // get JNI handle for class crcl.base.ForceUnitEnumType
   static inline jclass getForceUnitEnumTypeClass();
   
   ForceUnitEnumType::ForceUnitEnumType(jobject _jthis, bool copy): ::crclj::java::lang::Enum(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   ForceUnitEnumType::ForceUnitEnumType(const ForceUnitEnumType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }

   // Destructor for crcl.base.ForceUnitEnumType
   ForceUnitEnumType::~ForceUnitEnumType() {
   	// Place-holder for later extensibility.
   }

   ForceUnitEnumType ForceUnitEnumType::fromValue(jstring string_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getForceUnitEnumTypeClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "fromValue", "(Ljava/lang/String;)Lcrcl/base/ForceUnitEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ForceUnitEnumType has no method named fromValue with signature (Ljava/lang/String;)Lcrcl/base/ForceUnitEnumType;." << std::endl;
           ForceUnitEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,string_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ForceUnitEnumType retObject(retVal,false);
    return retObject;
   }
   jstring ForceUnitEnumType::value() {

   if(jthis == NULL) {
       std::cerr << "Call of method value of crcl.base.ForceUnitEnumType with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ForceUnitEnumType::value jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "value", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ForceUnitEnumType has no method named value with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jobjectArray ForceUnitEnumType::values() {

   JNIEnv *env =getEnv();
   static jclass cls = getForceUnitEnumTypeClass();
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "values", "()[Lcrcl/base/ForceUnitEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ForceUnitEnumType has no method named values with signature ()[Lcrcl/base/ForceUnitEnumType;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallStaticObjectMethod( cls, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   ForceUnitEnumType ForceUnitEnumType::valueOf(jstring string_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getForceUnitEnumTypeClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "valueOf", "(Ljava/lang/String;)Lcrcl/base/ForceUnitEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ForceUnitEnumType has no method named valueOf with signature (Ljava/lang/String;)Lcrcl/base/ForceUnitEnumType;." << std::endl;
           ForceUnitEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,string_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ForceUnitEnumType retObject(retVal,false);
    return retObject;
   }
   static jclass getNewForceUnitEnumTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/ForceUnitEnumType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/ForceUnitEnumType" << std::endl;
       }
       return clss;
   }
   
   static jclass ForceUnitEnumTypeClass = NULL;
   static inline jclass getForceUnitEnumTypeClass() {
       if (ForceUnitEnumTypeClass != NULL) {
           return ForceUnitEnumTypeClass;
       }
       ForceUnitEnumTypeClass = getNewForceUnitEnumTypeClass();
   }
   
   // get JNI handle for class crcl.base.ParameterSettingType
   static inline jclass getParameterSettingTypeClass();
   
   ParameterSettingType::ParameterSettingType(jobject _jthis, bool copy): DataThingType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   ParameterSettingType::ParameterSettingType(const ParameterSettingType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   ParameterSettingType::ParameterSettingType() {
    JNIEnv *env =getEnv();
    static jclass cls = getParameterSettingTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class ParameterSettingType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new ParameterSettingType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.ParameterSettingType
   ParameterSettingType::~ParameterSettingType() {
   	// Place-holder for later extensibility.
   }

   jstring ParameterSettingType::getParameterName() {

   if(jthis == NULL) {
       std::cerr << "Call of method getParameterName of crcl.base.ParameterSettingType with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ParameterSettingType::getParameterName jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getParameterName", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ParameterSettingType has no method named getParameterName with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void ParameterSettingType::setParameterName(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setParameterName of crcl.base.ParameterSettingType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ParameterSettingType::setParameterName jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setParameterName", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ParameterSettingType has no method named setParameterName with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   jstring ParameterSettingType::getParameterValue() {

   if(jthis == NULL) {
       std::cerr << "Call of method getParameterValue of crcl.base.ParameterSettingType with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ParameterSettingType::getParameterValue jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getParameterValue", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ParameterSettingType has no method named getParameterValue with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void ParameterSettingType::setParameterValue(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setParameterValue of crcl.base.ParameterSettingType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ParameterSettingType::setParameterValue jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setParameterValue", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ParameterSettingType has no method named setParameterValue with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewParameterSettingTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/ParameterSettingType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/ParameterSettingType" << std::endl;
       }
       return clss;
   }
   
   static jclass ParameterSettingTypeClass = NULL;
   static inline jclass getParameterSettingTypeClass() {
       if (ParameterSettingTypeClass != NULL) {
           return ParameterSettingTypeClass;
       }
       ParameterSettingTypeClass = getNewParameterSettingTypeClass();
   }
   
   // get JNI handle for class crcl.base.CRCLStatusType
   static inline jclass getCRCLStatusTypeClass();
   
   CRCLStatusType::CRCLStatusType(jobject _jthis, bool copy): DataThingType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   CRCLStatusType::CRCLStatusType(const CRCLStatusType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   CRCLStatusType::CRCLStatusType() {
    JNIEnv *env =getEnv();
    static jclass cls = getCRCLStatusTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class CRCLStatusType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new CRCLStatusType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.CRCLStatusType
   CRCLStatusType::~CRCLStatusType() {
   	// Place-holder for later extensibility.
   }

   JointStatusesType CRCLStatusType::getJointStatuses() {

   if(jthis == NULL) {
       std::cerr << "Call of method getJointStatuses of crcl.base.CRCLStatusType with jthis == NULL." << std::endl;
       JointStatusesType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLStatusType::getJointStatuses jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getJointStatuses", "()Lcrcl/base/JointStatusesType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CRCLStatusType has no method named getJointStatuses with signature ()Lcrcl/base/JointStatusesType;." << std::endl;
           JointStatusesType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    JointStatusesType retObject(retVal,false);
    return retObject;
   }
   CommandStatusType CRCLStatusType::getCommandStatus() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCommandStatus of crcl.base.CRCLStatusType with jthis == NULL." << std::endl;
       CommandStatusType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLStatusType::getCommandStatus jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCommandStatus", "()Lcrcl/base/CommandStatusType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CRCLStatusType has no method named getCommandStatus with signature ()Lcrcl/base/CommandStatusType;." << std::endl;
           CommandStatusType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    CommandStatusType retObject(retVal,false);
    return retObject;
   }
   PoseType CRCLStatusType::getPose() {

   if(jthis == NULL) {
       std::cerr << "Call of method getPose of crcl.base.CRCLStatusType with jthis == NULL." << std::endl;
       PoseType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLStatusType::getPose jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getPose", "()Lcrcl/base/PoseType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CRCLStatusType has no method named getPose with signature ()Lcrcl/base/PoseType;." << std::endl;
           PoseType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PoseType retObject(retVal,false);
    return retObject;
   }
   void CRCLStatusType::setCommandStatus(CommandStatusType  &commandStatusType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCommandStatus of crcl.base.CRCLStatusType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLStatusType::setCommandStatus jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCommandStatus", "(Lcrcl/base/CommandStatusType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CRCLStatusType has no method named setCommandStatus with signature (Lcrcl/base/CommandStatusType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,commandStatusType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void CRCLStatusType::setJointStatuses(JointStatusesType  &jointStatusesType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setJointStatuses of crcl.base.CRCLStatusType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLStatusType::setJointStatuses jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setJointStatuses", "(Lcrcl/base/JointStatusesType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CRCLStatusType has no method named setJointStatuses with signature (Lcrcl/base/JointStatusesType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,jointStatusesType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void CRCLStatusType::setPose(PoseType  &poseType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setPose of crcl.base.CRCLStatusType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLStatusType::setPose jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setPose", "(Lcrcl/base/PoseType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CRCLStatusType has no method named setPose with signature (Lcrcl/base/PoseType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,poseType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   GripperStatusType CRCLStatusType::getGripperStatus() {

   if(jthis == NULL) {
       std::cerr << "Call of method getGripperStatus of crcl.base.CRCLStatusType with jthis == NULL." << std::endl;
       GripperStatusType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLStatusType::getGripperStatus jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getGripperStatus", "()Lcrcl/base/GripperStatusType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CRCLStatusType has no method named getGripperStatus with signature ()Lcrcl/base/GripperStatusType;." << std::endl;
           GripperStatusType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    GripperStatusType retObject(retVal,false);
    return retObject;
   }
   void CRCLStatusType::setGripperStatus(GripperStatusType  &gripperStatusType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setGripperStatus of crcl.base.CRCLStatusType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLStatusType::setGripperStatus jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setGripperStatus", "(Lcrcl/base/GripperStatusType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CRCLStatusType has no method named setGripperStatus with signature (Lcrcl/base/GripperStatusType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,gripperStatusType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewCRCLStatusTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/CRCLStatusType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/CRCLStatusType" << std::endl;
       }
       return clss;
   }
   
   static jclass CRCLStatusTypeClass = NULL;
   static inline jclass getCRCLStatusTypeClass() {
       if (CRCLStatusTypeClass != NULL) {
           return CRCLStatusTypeClass;
       }
       CRCLStatusTypeClass = getNewCRCLStatusTypeClass();
   }
   
   // get JNI handle for class crcl.base.MoveScrewType
   static inline jclass getMoveScrewTypeClass();
   
   MoveScrewType::MoveScrewType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   MoveScrewType::MoveScrewType(const MoveScrewType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   MoveScrewType::MoveScrewType() {
    JNIEnv *env =getEnv();
    static jclass cls = getMoveScrewTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class MoveScrewType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new MoveScrewType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.MoveScrewType
   MoveScrewType::~MoveScrewType() {
   	// Place-holder for later extensibility.
   }

   PoseType MoveScrewType::getStartPosition() {

   if(jthis == NULL) {
       std::cerr << "Call of method getStartPosition of crcl.base.MoveScrewType with jthis == NULL." << std::endl;
       PoseType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MoveScrewType::getStartPosition jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getStartPosition", "()Lcrcl/base/PoseType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MoveScrewType has no method named getStartPosition with signature ()Lcrcl/base/PoseType;." << std::endl;
           PoseType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PoseType retObject(retVal,false);
    return retObject;
   }
   void MoveScrewType::setStartPosition(PoseType  &poseType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setStartPosition of crcl.base.MoveScrewType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MoveScrewType::setStartPosition jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setStartPosition", "(Lcrcl/base/PoseType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MoveScrewType has no method named setStartPosition with signature (Lcrcl/base/PoseType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,poseType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   PointType MoveScrewType::getAxisPoint() {

   if(jthis == NULL) {
       std::cerr << "Call of method getAxisPoint of crcl.base.MoveScrewType with jthis == NULL." << std::endl;
       PointType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MoveScrewType::getAxisPoint jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getAxisPoint", "()Lcrcl/base/PointType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MoveScrewType has no method named getAxisPoint with signature ()Lcrcl/base/PointType;." << std::endl;
           PointType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PointType retObject(retVal,false);
    return retObject;
   }
   void MoveScrewType::setAxisPoint(PointType  &pointType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setAxisPoint of crcl.base.MoveScrewType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MoveScrewType::setAxisPoint jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setAxisPoint", "(Lcrcl/base/PointType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MoveScrewType has no method named setAxisPoint with signature (Lcrcl/base/PointType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,pointType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::math::BigDecimal MoveScrewType::getAxialDistanceFree() {

   if(jthis == NULL) {
       std::cerr << "Call of method getAxialDistanceFree of crcl.base.MoveScrewType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MoveScrewType::getAxialDistanceFree jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getAxialDistanceFree", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MoveScrewType has no method named getAxialDistanceFree with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void MoveScrewType::setAxialDistanceFree(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setAxialDistanceFree of crcl.base.MoveScrewType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MoveScrewType::setAxialDistanceFree jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setAxialDistanceFree", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MoveScrewType has no method named setAxialDistanceFree with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::math::BigDecimal MoveScrewType::getAxialDistanceScrew() {

   if(jthis == NULL) {
       std::cerr << "Call of method getAxialDistanceScrew of crcl.base.MoveScrewType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MoveScrewType::getAxialDistanceScrew jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getAxialDistanceScrew", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MoveScrewType has no method named getAxialDistanceScrew with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void MoveScrewType::setAxialDistanceScrew(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setAxialDistanceScrew of crcl.base.MoveScrewType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MoveScrewType::setAxialDistanceScrew jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setAxialDistanceScrew", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MoveScrewType has no method named setAxialDistanceScrew with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::math::BigDecimal MoveScrewType::getTurn() {

   if(jthis == NULL) {
       std::cerr << "Call of method getTurn of crcl.base.MoveScrewType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MoveScrewType::getTurn jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getTurn", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MoveScrewType has no method named getTurn with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void MoveScrewType::setTurn(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setTurn of crcl.base.MoveScrewType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MoveScrewType::setTurn jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setTurn", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MoveScrewType has no method named setTurn with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewMoveScrewTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/MoveScrewType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/MoveScrewType" << std::endl;
       }
       return clss;
   }
   
   static jclass MoveScrewTypeClass = NULL;
   static inline jclass getMoveScrewTypeClass() {
       if (MoveScrewTypeClass != NULL) {
           return MoveScrewTypeClass;
       }
       MoveScrewTypeClass = getNewMoveScrewTypeClass();
   }
   
   // get JNI handle for class crcl.base.MoveToType
   static inline jclass getMoveToTypeClass();
   
   MoveToType::MoveToType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   MoveToType::MoveToType(const MoveToType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   MoveToType::MoveToType() {
    JNIEnv *env =getEnv();
    static jclass cls = getMoveToTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class MoveToType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new MoveToType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.MoveToType
   MoveToType::~MoveToType() {
   	// Place-holder for later extensibility.
   }

   jboolean MoveToType::isMoveStraight() {

   if(jthis == NULL) {
       std::cerr << "Call of method isMoveStraight of crcl.base.MoveToType with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MoveToType::isMoveStraight jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isMoveStraight", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MoveToType has no method named isMoveStraight with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void MoveToType::setMoveStraight(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setMoveStraight of crcl.base.MoveToType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MoveToType::setMoveStraight jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setMoveStraight", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MoveToType has no method named setMoveStraight with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   PoseType MoveToType::getEndPosition() {

   if(jthis == NULL) {
       std::cerr << "Call of method getEndPosition of crcl.base.MoveToType with jthis == NULL." << std::endl;
       PoseType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MoveToType::getEndPosition jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getEndPosition", "()Lcrcl/base/PoseType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MoveToType has no method named getEndPosition with signature ()Lcrcl/base/PoseType;." << std::endl;
           PoseType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PoseType retObject(retVal,false);
    return retObject;
   }
   void MoveToType::setEndPosition(PoseType  &poseType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setEndPosition of crcl.base.MoveToType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MoveToType::setEndPosition jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setEndPosition", "(Lcrcl/base/PoseType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MoveToType has no method named setEndPosition with signature (Lcrcl/base/PoseType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,poseType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewMoveToTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/MoveToType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/MoveToType" << std::endl;
       }
       return clss;
   }
   
   static jclass MoveToTypeClass = NULL;
   static inline jclass getMoveToTypeClass() {
       if (MoveToTypeClass != NULL) {
           return MoveToTypeClass;
       }
       MoveToTypeClass = getNewMoveToTypeClass();
   }
   
   // get JNI handle for class crcl.base.ObjectFactory
   static inline jclass getObjectFactoryClass();
   
   ObjectFactory::ObjectFactory(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   ObjectFactory::ObjectFactory(const ObjectFactory &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   ObjectFactory::ObjectFactory() {
    JNIEnv *env =getEnv();
    static jclass cls = getObjectFactoryClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class ObjectFactory has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new ObjectFactory jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.ObjectFactory
   ObjectFactory::~ObjectFactory() {
   	// Place-holder for later extensibility.
   }

   ::crclj::javax::xml::bind::JAXBElement ObjectFactory::createCRCLStatus(CRCLStatusType  &cRCLStatusType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method createCRCLStatus of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       ::crclj::javax::xml::bind::JAXBElement nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createCRCLStatus jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createCRCLStatus", "(Lcrcl/base/CRCLStatusType;)Ljavax/xml/bind/JAXBElement;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createCRCLStatus with signature (Lcrcl/base/CRCLStatusType;)Ljavax/xml/bind/JAXBElement;." << std::endl;
           ::crclj::javax::xml::bind::JAXBElement nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,cRCLStatusType_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::javax::xml::bind::JAXBElement retObject(retVal,false);
    return retObject;
   }
   ::crclj::javax::xml::bind::JAXBElement ObjectFactory::createCRCLCommandInstance(CRCLCommandInstanceType  &cRCLCommandInstanceType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method createCRCLCommandInstance of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       ::crclj::javax::xml::bind::JAXBElement nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createCRCLCommandInstance jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createCRCLCommandInstance", "(Lcrcl/base/CRCLCommandInstanceType;)Ljavax/xml/bind/JAXBElement;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createCRCLCommandInstance with signature (Lcrcl/base/CRCLCommandInstanceType;)Ljavax/xml/bind/JAXBElement;." << std::endl;
           ::crclj::javax::xml::bind::JAXBElement nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,cRCLCommandInstanceType_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::javax::xml::bind::JAXBElement retObject(retVal,false);
    return retObject;
   }
   ::crclj::javax::xml::bind::JAXBElement ObjectFactory::createCRCLProgram(CRCLProgramType  &cRCLProgramType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method createCRCLProgram of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       ::crclj::javax::xml::bind::JAXBElement nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createCRCLProgram jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createCRCLProgram", "(Lcrcl/base/CRCLProgramType;)Ljavax/xml/bind/JAXBElement;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createCRCLProgram with signature (Lcrcl/base/CRCLProgramType;)Ljavax/xml/bind/JAXBElement;." << std::endl;
           ::crclj::javax::xml::bind::JAXBElement nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,cRCLProgramType_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::javax::xml::bind::JAXBElement retObject(retVal,false);
    return retObject;
   }
   CRCLProgramType ObjectFactory::createCRCLProgramType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createCRCLProgramType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       CRCLProgramType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createCRCLProgramType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createCRCLProgramType", "()Lcrcl/base/CRCLProgramType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createCRCLProgramType with signature ()Lcrcl/base/CRCLProgramType;." << std::endl;
           CRCLProgramType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    CRCLProgramType retObject(retVal,false);
    return retObject;
   }
   CRCLCommandInstanceType ObjectFactory::createCRCLCommandInstanceType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createCRCLCommandInstanceType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       CRCLCommandInstanceType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createCRCLCommandInstanceType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createCRCLCommandInstanceType", "()Lcrcl/base/CRCLCommandInstanceType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createCRCLCommandInstanceType with signature ()Lcrcl/base/CRCLCommandInstanceType;." << std::endl;
           CRCLCommandInstanceType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    CRCLCommandInstanceType retObject(retVal,false);
    return retObject;
   }
   CRCLStatusType ObjectFactory::createCRCLStatusType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createCRCLStatusType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       CRCLStatusType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createCRCLStatusType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createCRCLStatusType", "()Lcrcl/base/CRCLStatusType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createCRCLStatusType with signature ()Lcrcl/base/CRCLStatusType;." << std::endl;
           CRCLStatusType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    CRCLStatusType retObject(retVal,false);
    return retObject;
   }
   PointType ObjectFactory::createPointType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createPointType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       PointType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createPointType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createPointType", "()Lcrcl/base/PointType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createPointType with signature ()Lcrcl/base/PointType;." << std::endl;
           PointType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PointType retObject(retVal,false);
    return retObject;
   }
   PoseType ObjectFactory::createPoseType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createPoseType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       PoseType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createPoseType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createPoseType", "()Lcrcl/base/PoseType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createPoseType with signature ()Lcrcl/base/PoseType;." << std::endl;
           PoseType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PoseType retObject(retVal,false);
    return retObject;
   }
   VectorType ObjectFactory::createVectorType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createVectorType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       VectorType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createVectorType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createVectorType", "()Lcrcl/base/VectorType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createVectorType with signature ()Lcrcl/base/VectorType;." << std::endl;
           VectorType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    VectorType retObject(retVal,false);
    return retObject;
   }
   ActuateJointsType ObjectFactory::createActuateJointsType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createActuateJointsType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       ActuateJointsType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createActuateJointsType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createActuateJointsType", "()Lcrcl/base/ActuateJointsType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createActuateJointsType with signature ()Lcrcl/base/ActuateJointsType;." << std::endl;
           ActuateJointsType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ActuateJointsType retObject(retVal,false);
    return retObject;
   }
   ActuateJointType ObjectFactory::createActuateJointType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createActuateJointType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       ActuateJointType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createActuateJointType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createActuateJointType", "()Lcrcl/base/ActuateJointType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createActuateJointType with signature ()Lcrcl/base/ActuateJointType;." << std::endl;
           ActuateJointType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ActuateJointType retObject(retVal,false);
    return retObject;
   }
   CloseToolChangerType ObjectFactory::createCloseToolChangerType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createCloseToolChangerType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       CloseToolChangerType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createCloseToolChangerType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createCloseToolChangerType", "()Lcrcl/base/CloseToolChangerType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createCloseToolChangerType with signature ()Lcrcl/base/CloseToolChangerType;." << std::endl;
           CloseToolChangerType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    CloseToolChangerType retObject(retVal,false);
    return retObject;
   }
   DwellType ObjectFactory::createDwellType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createDwellType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       DwellType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createDwellType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createDwellType", "()Lcrcl/base/DwellType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createDwellType with signature ()Lcrcl/base/DwellType;." << std::endl;
           DwellType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    DwellType retObject(retVal,false);
    return retObject;
   }
   ConfigureJointReportsType ObjectFactory::createConfigureJointReportsType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createConfigureJointReportsType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       ConfigureJointReportsType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createConfigureJointReportsType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createConfigureJointReportsType", "()Lcrcl/base/ConfigureJointReportsType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createConfigureJointReportsType with signature ()Lcrcl/base/ConfigureJointReportsType;." << std::endl;
           ConfigureJointReportsType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ConfigureJointReportsType retObject(retVal,false);
    return retObject;
   }
   ConfigureJointReportType ObjectFactory::createConfigureJointReportType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createConfigureJointReportType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       ConfigureJointReportType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createConfigureJointReportType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createConfigureJointReportType", "()Lcrcl/base/ConfigureJointReportType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createConfigureJointReportType with signature ()Lcrcl/base/ConfigureJointReportType;." << std::endl;
           ConfigureJointReportType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ConfigureJointReportType retObject(retVal,false);
    return retObject;
   }
   EndCanonType ObjectFactory::createEndCanonType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createEndCanonType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       EndCanonType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createEndCanonType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createEndCanonType", "()Lcrcl/base/EndCanonType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createEndCanonType with signature ()Lcrcl/base/EndCanonType;." << std::endl;
           EndCanonType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    EndCanonType retObject(retVal,false);
    return retObject;
   }
   GetStatusType ObjectFactory::createGetStatusType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createGetStatusType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       GetStatusType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createGetStatusType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createGetStatusType", "()Lcrcl/base/GetStatusType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createGetStatusType with signature ()Lcrcl/base/GetStatusType;." << std::endl;
           GetStatusType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    GetStatusType retObject(retVal,false);
    return retObject;
   }
   InitCanonType ObjectFactory::createInitCanonType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createInitCanonType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       InitCanonType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createInitCanonType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createInitCanonType", "()Lcrcl/base/InitCanonType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createInitCanonType with signature ()Lcrcl/base/InitCanonType;." << std::endl;
           InitCanonType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    InitCanonType retObject(retVal,false);
    return retObject;
   }
   JointForceTorqueType ObjectFactory::createJointForceTorqueType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createJointForceTorqueType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       JointForceTorqueType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createJointForceTorqueType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createJointForceTorqueType", "()Lcrcl/base/JointForceTorqueType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createJointForceTorqueType with signature ()Lcrcl/base/JointForceTorqueType;." << std::endl;
           JointForceTorqueType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    JointForceTorqueType retObject(retVal,false);
    return retObject;
   }
   JointSpeedAccelType ObjectFactory::createJointSpeedAccelType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createJointSpeedAccelType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       JointSpeedAccelType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createJointSpeedAccelType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createJointSpeedAccelType", "()Lcrcl/base/JointSpeedAccelType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createJointSpeedAccelType with signature ()Lcrcl/base/JointSpeedAccelType;." << std::endl;
           JointSpeedAccelType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    JointSpeedAccelType retObject(retVal,false);
    return retObject;
   }
   MessageType ObjectFactory::createMessageType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createMessageType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       MessageType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createMessageType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createMessageType", "()Lcrcl/base/MessageType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createMessageType with signature ()Lcrcl/base/MessageType;." << std::endl;
           MessageType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    MessageType retObject(retVal,false);
    return retObject;
   }
   MoveScrewType ObjectFactory::createMoveScrewType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createMoveScrewType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       MoveScrewType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createMoveScrewType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createMoveScrewType", "()Lcrcl/base/MoveScrewType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createMoveScrewType with signature ()Lcrcl/base/MoveScrewType;." << std::endl;
           MoveScrewType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    MoveScrewType retObject(retVal,false);
    return retObject;
   }
   MoveThroughToType ObjectFactory::createMoveThroughToType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createMoveThroughToType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       MoveThroughToType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createMoveThroughToType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createMoveThroughToType", "()Lcrcl/base/MoveThroughToType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createMoveThroughToType with signature ()Lcrcl/base/MoveThroughToType;." << std::endl;
           MoveThroughToType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    MoveThroughToType retObject(retVal,false);
    return retObject;
   }
   MoveToType ObjectFactory::createMoveToType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createMoveToType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       MoveToType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createMoveToType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createMoveToType", "()Lcrcl/base/MoveToType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createMoveToType with signature ()Lcrcl/base/MoveToType;." << std::endl;
           MoveToType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    MoveToType retObject(retVal,false);
    return retObject;
   }
   OpenToolChangerType ObjectFactory::createOpenToolChangerType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createOpenToolChangerType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       OpenToolChangerType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createOpenToolChangerType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createOpenToolChangerType", "()Lcrcl/base/OpenToolChangerType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createOpenToolChangerType with signature ()Lcrcl/base/OpenToolChangerType;." << std::endl;
           OpenToolChangerType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    OpenToolChangerType retObject(retVal,false);
    return retObject;
   }
   ParameterSettingType ObjectFactory::createParameterSettingType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createParameterSettingType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       ParameterSettingType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createParameterSettingType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createParameterSettingType", "()Lcrcl/base/ParameterSettingType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createParameterSettingType with signature ()Lcrcl/base/ParameterSettingType;." << std::endl;
           ParameterSettingType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ParameterSettingType retObject(retVal,false);
    return retObject;
   }
   PoseAndSetType ObjectFactory::createPoseAndSetType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createPoseAndSetType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       PoseAndSetType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createPoseAndSetType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createPoseAndSetType", "()Lcrcl/base/PoseAndSetType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createPoseAndSetType with signature ()Lcrcl/base/PoseAndSetType;." << std::endl;
           PoseAndSetType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PoseAndSetType retObject(retVal,false);
    return retObject;
   }
   PoseToleranceType ObjectFactory::createPoseToleranceType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createPoseToleranceType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       PoseToleranceType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createPoseToleranceType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createPoseToleranceType", "()Lcrcl/base/PoseToleranceType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createPoseToleranceType with signature ()Lcrcl/base/PoseToleranceType;." << std::endl;
           PoseToleranceType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PoseToleranceType retObject(retVal,false);
    return retObject;
   }
   RotAccelAbsoluteType ObjectFactory::createRotAccelAbsoluteType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createRotAccelAbsoluteType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       RotAccelAbsoluteType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createRotAccelAbsoluteType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createRotAccelAbsoluteType", "()Lcrcl/base/RotAccelAbsoluteType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createRotAccelAbsoluteType with signature ()Lcrcl/base/RotAccelAbsoluteType;." << std::endl;
           RotAccelAbsoluteType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    RotAccelAbsoluteType retObject(retVal,false);
    return retObject;
   }
   RotAccelRelativeType ObjectFactory::createRotAccelRelativeType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createRotAccelRelativeType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       RotAccelRelativeType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createRotAccelRelativeType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createRotAccelRelativeType", "()Lcrcl/base/RotAccelRelativeType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createRotAccelRelativeType with signature ()Lcrcl/base/RotAccelRelativeType;." << std::endl;
           RotAccelRelativeType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    RotAccelRelativeType retObject(retVal,false);
    return retObject;
   }
   RotSpeedAbsoluteType ObjectFactory::createRotSpeedAbsoluteType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createRotSpeedAbsoluteType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       RotSpeedAbsoluteType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createRotSpeedAbsoluteType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createRotSpeedAbsoluteType", "()Lcrcl/base/RotSpeedAbsoluteType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createRotSpeedAbsoluteType with signature ()Lcrcl/base/RotSpeedAbsoluteType;." << std::endl;
           RotSpeedAbsoluteType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    RotSpeedAbsoluteType retObject(retVal,false);
    return retObject;
   }
   RotSpeedRelativeType ObjectFactory::createRotSpeedRelativeType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createRotSpeedRelativeType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       RotSpeedRelativeType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createRotSpeedRelativeType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createRotSpeedRelativeType", "()Lcrcl/base/RotSpeedRelativeType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createRotSpeedRelativeType with signature ()Lcrcl/base/RotSpeedRelativeType;." << std::endl;
           RotSpeedRelativeType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    RotSpeedRelativeType retObject(retVal,false);
    return retObject;
   }
   RunProgramType ObjectFactory::createRunProgramType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createRunProgramType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       RunProgramType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createRunProgramType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createRunProgramType", "()Lcrcl/base/RunProgramType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createRunProgramType with signature ()Lcrcl/base/RunProgramType;." << std::endl;
           RunProgramType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    RunProgramType retObject(retVal,false);
    return retObject;
   }
   SetAngleUnitsType ObjectFactory::createSetAngleUnitsType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createSetAngleUnitsType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       SetAngleUnitsType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createSetAngleUnitsType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createSetAngleUnitsType", "()Lcrcl/base/SetAngleUnitsType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createSetAngleUnitsType with signature ()Lcrcl/base/SetAngleUnitsType;." << std::endl;
           SetAngleUnitsType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    SetAngleUnitsType retObject(retVal,false);
    return retObject;
   }
   SetEndEffectorParametersType ObjectFactory::createSetEndEffectorParametersType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createSetEndEffectorParametersType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       SetEndEffectorParametersType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createSetEndEffectorParametersType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createSetEndEffectorParametersType", "()Lcrcl/base/SetEndEffectorParametersType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createSetEndEffectorParametersType with signature ()Lcrcl/base/SetEndEffectorParametersType;." << std::endl;
           SetEndEffectorParametersType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    SetEndEffectorParametersType retObject(retVal,false);
    return retObject;
   }
   SetEndEffectorType ObjectFactory::createSetEndEffectorType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createSetEndEffectorType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       SetEndEffectorType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createSetEndEffectorType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createSetEndEffectorType", "()Lcrcl/base/SetEndEffectorType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createSetEndEffectorType with signature ()Lcrcl/base/SetEndEffectorType;." << std::endl;
           SetEndEffectorType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    SetEndEffectorType retObject(retVal,false);
    return retObject;
   }
   SetEndPoseToleranceType ObjectFactory::createSetEndPoseToleranceType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createSetEndPoseToleranceType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       SetEndPoseToleranceType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createSetEndPoseToleranceType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createSetEndPoseToleranceType", "()Lcrcl/base/SetEndPoseToleranceType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createSetEndPoseToleranceType with signature ()Lcrcl/base/SetEndPoseToleranceType;." << std::endl;
           SetEndPoseToleranceType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    SetEndPoseToleranceType retObject(retVal,false);
    return retObject;
   }
   SetForceUnitsType ObjectFactory::createSetForceUnitsType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createSetForceUnitsType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       SetForceUnitsType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createSetForceUnitsType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createSetForceUnitsType", "()Lcrcl/base/SetForceUnitsType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createSetForceUnitsType with signature ()Lcrcl/base/SetForceUnitsType;." << std::endl;
           SetForceUnitsType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    SetForceUnitsType retObject(retVal,false);
    return retObject;
   }
   SetIntermediatePoseToleranceType ObjectFactory::createSetIntermediatePoseToleranceType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createSetIntermediatePoseToleranceType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       SetIntermediatePoseToleranceType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createSetIntermediatePoseToleranceType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createSetIntermediatePoseToleranceType", "()Lcrcl/base/SetIntermediatePoseToleranceType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createSetIntermediatePoseToleranceType with signature ()Lcrcl/base/SetIntermediatePoseToleranceType;." << std::endl;
           SetIntermediatePoseToleranceType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    SetIntermediatePoseToleranceType retObject(retVal,false);
    return retObject;
   }
   SetLengthUnitsType ObjectFactory::createSetLengthUnitsType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createSetLengthUnitsType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       SetLengthUnitsType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createSetLengthUnitsType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createSetLengthUnitsType", "()Lcrcl/base/SetLengthUnitsType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createSetLengthUnitsType with signature ()Lcrcl/base/SetLengthUnitsType;." << std::endl;
           SetLengthUnitsType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    SetLengthUnitsType retObject(retVal,false);
    return retObject;
   }
   SetMotionCoordinationType ObjectFactory::createSetMotionCoordinationType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createSetMotionCoordinationType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       SetMotionCoordinationType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createSetMotionCoordinationType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createSetMotionCoordinationType", "()Lcrcl/base/SetMotionCoordinationType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createSetMotionCoordinationType with signature ()Lcrcl/base/SetMotionCoordinationType;." << std::endl;
           SetMotionCoordinationType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    SetMotionCoordinationType retObject(retVal,false);
    return retObject;
   }
   SetRobotParametersType ObjectFactory::createSetRobotParametersType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createSetRobotParametersType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       SetRobotParametersType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createSetRobotParametersType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createSetRobotParametersType", "()Lcrcl/base/SetRobotParametersType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createSetRobotParametersType with signature ()Lcrcl/base/SetRobotParametersType;." << std::endl;
           SetRobotParametersType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    SetRobotParametersType retObject(retVal,false);
    return retObject;
   }
   SetRotAccelType ObjectFactory::createSetRotAccelType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createSetRotAccelType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       SetRotAccelType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createSetRotAccelType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createSetRotAccelType", "()Lcrcl/base/SetRotAccelType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createSetRotAccelType with signature ()Lcrcl/base/SetRotAccelType;." << std::endl;
           SetRotAccelType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    SetRotAccelType retObject(retVal,false);
    return retObject;
   }
   SetRotSpeedType ObjectFactory::createSetRotSpeedType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createSetRotSpeedType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       SetRotSpeedType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createSetRotSpeedType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createSetRotSpeedType", "()Lcrcl/base/SetRotSpeedType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createSetRotSpeedType with signature ()Lcrcl/base/SetRotSpeedType;." << std::endl;
           SetRotSpeedType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    SetRotSpeedType retObject(retVal,false);
    return retObject;
   }
   SetTorqueUnitsType ObjectFactory::createSetTorqueUnitsType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createSetTorqueUnitsType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       SetTorqueUnitsType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createSetTorqueUnitsType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createSetTorqueUnitsType", "()Lcrcl/base/SetTorqueUnitsType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createSetTorqueUnitsType with signature ()Lcrcl/base/SetTorqueUnitsType;." << std::endl;
           SetTorqueUnitsType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    SetTorqueUnitsType retObject(retVal,false);
    return retObject;
   }
   SetTransAccelType ObjectFactory::createSetTransAccelType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createSetTransAccelType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       SetTransAccelType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createSetTransAccelType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createSetTransAccelType", "()Lcrcl/base/SetTransAccelType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createSetTransAccelType with signature ()Lcrcl/base/SetTransAccelType;." << std::endl;
           SetTransAccelType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    SetTransAccelType retObject(retVal,false);
    return retObject;
   }
   SetTransSpeedType ObjectFactory::createSetTransSpeedType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createSetTransSpeedType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       SetTransSpeedType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createSetTransSpeedType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createSetTransSpeedType", "()Lcrcl/base/SetTransSpeedType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createSetTransSpeedType with signature ()Lcrcl/base/SetTransSpeedType;." << std::endl;
           SetTransSpeedType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    SetTransSpeedType retObject(retVal,false);
    return retObject;
   }
   StopMotionType ObjectFactory::createStopMotionType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createStopMotionType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       StopMotionType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createStopMotionType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createStopMotionType", "()Lcrcl/base/StopMotionType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createStopMotionType with signature ()Lcrcl/base/StopMotionType;." << std::endl;
           StopMotionType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    StopMotionType retObject(retVal,false);
    return retObject;
   }
   TransAccelAbsoluteType ObjectFactory::createTransAccelAbsoluteType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createTransAccelAbsoluteType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       TransAccelAbsoluteType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createTransAccelAbsoluteType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createTransAccelAbsoluteType", "()Lcrcl/base/TransAccelAbsoluteType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createTransAccelAbsoluteType with signature ()Lcrcl/base/TransAccelAbsoluteType;." << std::endl;
           TransAccelAbsoluteType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    TransAccelAbsoluteType retObject(retVal,false);
    return retObject;
   }
   TransAccelRelativeType ObjectFactory::createTransAccelRelativeType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createTransAccelRelativeType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       TransAccelRelativeType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createTransAccelRelativeType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createTransAccelRelativeType", "()Lcrcl/base/TransAccelRelativeType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createTransAccelRelativeType with signature ()Lcrcl/base/TransAccelRelativeType;." << std::endl;
           TransAccelRelativeType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    TransAccelRelativeType retObject(retVal,false);
    return retObject;
   }
   TransSpeedAbsoluteType ObjectFactory::createTransSpeedAbsoluteType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createTransSpeedAbsoluteType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       TransSpeedAbsoluteType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createTransSpeedAbsoluteType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createTransSpeedAbsoluteType", "()Lcrcl/base/TransSpeedAbsoluteType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createTransSpeedAbsoluteType with signature ()Lcrcl/base/TransSpeedAbsoluteType;." << std::endl;
           TransSpeedAbsoluteType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    TransSpeedAbsoluteType retObject(retVal,false);
    return retObject;
   }
   TransSpeedRelativeType ObjectFactory::createTransSpeedRelativeType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createTransSpeedRelativeType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       TransSpeedRelativeType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createTransSpeedRelativeType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createTransSpeedRelativeType", "()Lcrcl/base/TransSpeedRelativeType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createTransSpeedRelativeType with signature ()Lcrcl/base/TransSpeedRelativeType;." << std::endl;
           TransSpeedRelativeType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    TransSpeedRelativeType retObject(retVal,false);
    return retObject;
   }
   CommandStatusType ObjectFactory::createCommandStatusType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createCommandStatusType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       CommandStatusType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createCommandStatusType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createCommandStatusType", "()Lcrcl/base/CommandStatusType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createCommandStatusType with signature ()Lcrcl/base/CommandStatusType;." << std::endl;
           CommandStatusType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    CommandStatusType retObject(retVal,false);
    return retObject;
   }
   JointStatusesType ObjectFactory::createJointStatusesType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createJointStatusesType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       JointStatusesType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createJointStatusesType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createJointStatusesType", "()Lcrcl/base/JointStatusesType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createJointStatusesType with signature ()Lcrcl/base/JointStatusesType;." << std::endl;
           JointStatusesType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    JointStatusesType retObject(retVal,false);
    return retObject;
   }
   JointStatusType ObjectFactory::createJointStatusType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createJointStatusType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       JointStatusType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createJointStatusType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createJointStatusType", "()Lcrcl/base/JointStatusType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createJointStatusType with signature ()Lcrcl/base/JointStatusType;." << std::endl;
           JointStatusType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    JointStatusType retObject(retVal,false);
    return retObject;
   }
   ParallelGripperStatusType ObjectFactory::createParallelGripperStatusType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createParallelGripperStatusType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       ParallelGripperStatusType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createParallelGripperStatusType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createParallelGripperStatusType", "()Lcrcl/base/ParallelGripperStatusType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createParallelGripperStatusType with signature ()Lcrcl/base/ParallelGripperStatusType;." << std::endl;
           ParallelGripperStatusType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ParallelGripperStatusType retObject(retVal,false);
    return retObject;
   }
   ThreeFingerGripperStatusType ObjectFactory::createThreeFingerGripperStatusType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createThreeFingerGripperStatusType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       ThreeFingerGripperStatusType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createThreeFingerGripperStatusType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createThreeFingerGripperStatusType", "()Lcrcl/base/ThreeFingerGripperStatusType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createThreeFingerGripperStatusType with signature ()Lcrcl/base/ThreeFingerGripperStatusType;." << std::endl;
           ThreeFingerGripperStatusType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ThreeFingerGripperStatusType retObject(retVal,false);
    return retObject;
   }
   VacuumGripperStatusType ObjectFactory::createVacuumGripperStatusType() {

   if(jthis == NULL) {
       std::cerr << "Call of method createVacuumGripperStatusType of crcl.base.ObjectFactory with jthis == NULL." << std::endl;
       VacuumGripperStatusType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjectFactory::createVacuumGripperStatusType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createVacuumGripperStatusType", "()Lcrcl/base/VacuumGripperStatusType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ObjectFactory has no method named createVacuumGripperStatusType with signature ()Lcrcl/base/VacuumGripperStatusType;." << std::endl;
           VacuumGripperStatusType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    VacuumGripperStatusType retObject(retVal,false);
    return retObject;
   }
   static jclass getNewObjectFactoryClass() {
       jclass clss = getEnv()->FindClass("crcl/base/ObjectFactory");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/ObjectFactory" << std::endl;
       }
       return clss;
   }
   
   static jclass ObjectFactoryClass = NULL;
   static inline jclass getObjectFactoryClass() {
       if (ObjectFactoryClass != NULL) {
           return ObjectFactoryClass;
       }
       ObjectFactoryClass = getNewObjectFactoryClass();
   }
   
   // get JNI handle for class crcl.base.PoseType
   static inline jclass getPoseTypeClass();
   
   PoseType::PoseType(jobject _jthis, bool copy): DataThingType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   PoseType::PoseType(const PoseType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   PoseType::PoseType() {
    JNIEnv *env =getEnv();
    static jclass cls = getPoseTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class PoseType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PoseType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.PoseType
   PoseType::~PoseType() {
   	// Place-holder for later extensibility.
   }

   PointType PoseType::getPoint() {

   if(jthis == NULL) {
       std::cerr << "Call of method getPoint of crcl.base.PoseType with jthis == NULL." << std::endl;
       PointType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseType::getPoint jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getPoint", "()Lcrcl/base/PointType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseType has no method named getPoint with signature ()Lcrcl/base/PointType;." << std::endl;
           PointType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PointType retObject(retVal,false);
    return retObject;
   }
   VectorType PoseType::getXAxis() {

   if(jthis == NULL) {
       std::cerr << "Call of method getXAxis of crcl.base.PoseType with jthis == NULL." << std::endl;
       VectorType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseType::getXAxis jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getXAxis", "()Lcrcl/base/VectorType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseType has no method named getXAxis with signature ()Lcrcl/base/VectorType;." << std::endl;
           VectorType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    VectorType retObject(retVal,false);
    return retObject;
   }
   VectorType PoseType::getZAxis() {

   if(jthis == NULL) {
       std::cerr << "Call of method getZAxis of crcl.base.PoseType with jthis == NULL." << std::endl;
       VectorType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseType::getZAxis jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getZAxis", "()Lcrcl/base/VectorType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseType has no method named getZAxis with signature ()Lcrcl/base/VectorType;." << std::endl;
           VectorType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    VectorType retObject(retVal,false);
    return retObject;
   }
   void PoseType::setPoint(PointType  &pointType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setPoint of crcl.base.PoseType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseType::setPoint jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setPoint", "(Lcrcl/base/PointType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseType has no method named setPoint with signature (Lcrcl/base/PointType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,pointType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void PoseType::setXAxis(VectorType  &vectorType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setXAxis of crcl.base.PoseType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseType::setXAxis jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setXAxis", "(Lcrcl/base/VectorType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseType has no method named setXAxis with signature (Lcrcl/base/VectorType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,vectorType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void PoseType::setZAxis(VectorType  &vectorType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setZAxis of crcl.base.PoseType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseType::setZAxis jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setZAxis", "(Lcrcl/base/VectorType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseType has no method named setZAxis with signature (Lcrcl/base/VectorType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,vectorType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewPoseTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/PoseType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/PoseType" << std::endl;
       }
       return clss;
   }
   
   static jclass PoseTypeClass = NULL;
   static inline jclass getPoseTypeClass() {
       if (PoseTypeClass != NULL) {
           return PoseTypeClass;
       }
       PoseTypeClass = getNewPoseTypeClass();
   }
   
   // get JNI handle for class crcl.base.PoseAndSetType
   static inline jclass getPoseAndSetTypeClass();
   
   PoseAndSetType::PoseAndSetType(jobject _jthis, bool copy): PoseType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   PoseAndSetType::PoseAndSetType(const PoseAndSetType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   PoseAndSetType::PoseAndSetType() {
    JNIEnv *env =getEnv();
    static jclass cls = getPoseAndSetTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class PoseAndSetType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PoseAndSetType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.PoseAndSetType
   PoseAndSetType::~PoseAndSetType() {
   	// Place-holder for later extensibility.
   }

   void PoseAndSetType::setTolerance(PoseToleranceType  &poseToleranceType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setTolerance of crcl.base.PoseAndSetType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseAndSetType::setTolerance jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setTolerance", "(Lcrcl/base/PoseToleranceType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseAndSetType has no method named setTolerance with signature (Lcrcl/base/PoseToleranceType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,poseToleranceType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   PoseToleranceType PoseAndSetType::getTolerance() {

   if(jthis == NULL) {
       std::cerr << "Call of method getTolerance of crcl.base.PoseAndSetType with jthis == NULL." << std::endl;
       PoseToleranceType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseAndSetType::getTolerance jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getTolerance", "()Lcrcl/base/PoseToleranceType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseAndSetType has no method named getTolerance with signature ()Lcrcl/base/PoseToleranceType;." << std::endl;
           PoseToleranceType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PoseToleranceType retObject(retVal,false);
    return retObject;
   }
   jboolean PoseAndSetType::isCoordinated() {

   if(jthis == NULL) {
       std::cerr << "Call of method isCoordinated of crcl.base.PoseAndSetType with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseAndSetType::isCoordinated jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isCoordinated", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseAndSetType has no method named isCoordinated with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PoseAndSetType::setCoordinated(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCoordinated of crcl.base.PoseAndSetType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseAndSetType::setCoordinated jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCoordinated", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseAndSetType has no method named setCoordinated with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   TransSpeedType PoseAndSetType::getTransSpeed() {

   if(jthis == NULL) {
       std::cerr << "Call of method getTransSpeed of crcl.base.PoseAndSetType with jthis == NULL." << std::endl;
       TransSpeedType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseAndSetType::getTransSpeed jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getTransSpeed", "()Lcrcl/base/TransSpeedType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseAndSetType has no method named getTransSpeed with signature ()Lcrcl/base/TransSpeedType;." << std::endl;
           TransSpeedType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    TransSpeedType retObject(retVal,false);
    return retObject;
   }
   void PoseAndSetType::setTransSpeed(TransSpeedType  &transSpeedType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setTransSpeed of crcl.base.PoseAndSetType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseAndSetType::setTransSpeed jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setTransSpeed", "(Lcrcl/base/TransSpeedType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseAndSetType has no method named setTransSpeed with signature (Lcrcl/base/TransSpeedType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,transSpeedType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   RotSpeedType PoseAndSetType::getRotSpeed() {

   if(jthis == NULL) {
       std::cerr << "Call of method getRotSpeed of crcl.base.PoseAndSetType with jthis == NULL." << std::endl;
       RotSpeedType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseAndSetType::getRotSpeed jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getRotSpeed", "()Lcrcl/base/RotSpeedType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseAndSetType has no method named getRotSpeed with signature ()Lcrcl/base/RotSpeedType;." << std::endl;
           RotSpeedType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    RotSpeedType retObject(retVal,false);
    return retObject;
   }
   void PoseAndSetType::setRotSpeed(RotSpeedType  &rotSpeedType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setRotSpeed of crcl.base.PoseAndSetType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseAndSetType::setRotSpeed jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setRotSpeed", "(Lcrcl/base/RotSpeedType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseAndSetType has no method named setRotSpeed with signature (Lcrcl/base/RotSpeedType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,rotSpeedType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   TransAccelType PoseAndSetType::getTransAccel() {

   if(jthis == NULL) {
       std::cerr << "Call of method getTransAccel of crcl.base.PoseAndSetType with jthis == NULL." << std::endl;
       TransAccelType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseAndSetType::getTransAccel jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getTransAccel", "()Lcrcl/base/TransAccelType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseAndSetType has no method named getTransAccel with signature ()Lcrcl/base/TransAccelType;." << std::endl;
           TransAccelType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    TransAccelType retObject(retVal,false);
    return retObject;
   }
   void PoseAndSetType::setTransAccel(TransAccelType  &transAccelType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setTransAccel of crcl.base.PoseAndSetType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseAndSetType::setTransAccel jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setTransAccel", "(Lcrcl/base/TransAccelType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseAndSetType has no method named setTransAccel with signature (Lcrcl/base/TransAccelType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,transAccelType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   RotAccelType PoseAndSetType::getRotAccel() {

   if(jthis == NULL) {
       std::cerr << "Call of method getRotAccel of crcl.base.PoseAndSetType with jthis == NULL." << std::endl;
       RotAccelType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseAndSetType::getRotAccel jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getRotAccel", "()Lcrcl/base/RotAccelType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseAndSetType has no method named getRotAccel with signature ()Lcrcl/base/RotAccelType;." << std::endl;
           RotAccelType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    RotAccelType retObject(retVal,false);
    return retObject;
   }
   void PoseAndSetType::setRotAccel(RotAccelType  &rotAccelType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setRotAccel of crcl.base.PoseAndSetType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseAndSetType::setRotAccel jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setRotAccel", "(Lcrcl/base/RotAccelType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseAndSetType has no method named setRotAccel with signature (Lcrcl/base/RotAccelType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,rotAccelType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewPoseAndSetTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/PoseAndSetType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/PoseAndSetType" << std::endl;
       }
       return clss;
   }
   
   static jclass PoseAndSetTypeClass = NULL;
   static inline jclass getPoseAndSetTypeClass() {
       if (PoseAndSetTypeClass != NULL) {
           return PoseAndSetTypeClass;
       }
       PoseAndSetTypeClass = getNewPoseAndSetTypeClass();
   }
   
   // get JNI handle for class crcl.base.TransAccelType
   static inline jclass getTransAccelTypeClass();
   
   TransAccelType::TransAccelType(jobject _jthis, bool copy): DataThingType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   TransAccelType::TransAccelType(const TransAccelType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   TransAccelType::TransAccelType() {
    JNIEnv *env =getEnv();
    static jclass cls = getTransAccelTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class TransAccelType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new TransAccelType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.TransAccelType
   TransAccelType::~TransAccelType() {
   	// Place-holder for later extensibility.
   }

   static jclass getNewTransAccelTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/TransAccelType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/TransAccelType" << std::endl;
       }
       return clss;
   }
   
   static jclass TransAccelTypeClass = NULL;
   static inline jclass getTransAccelTypeClass() {
       if (TransAccelTypeClass != NULL) {
           return TransAccelTypeClass;
       }
       TransAccelTypeClass = getNewTransAccelTypeClass();
   }
   
   // get JNI handle for class crcl.base.TransAccelRelativeType
   static inline jclass getTransAccelRelativeTypeClass();
   
   TransAccelRelativeType::TransAccelRelativeType(jobject _jthis, bool copy): TransAccelType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   TransAccelRelativeType::TransAccelRelativeType(const TransAccelRelativeType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   TransAccelRelativeType::TransAccelRelativeType() {
    JNIEnv *env =getEnv();
    static jclass cls = getTransAccelRelativeTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class TransAccelRelativeType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new TransAccelRelativeType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.TransAccelRelativeType
   TransAccelRelativeType::~TransAccelRelativeType() {
   	// Place-holder for later extensibility.
   }

   void TransAccelRelativeType::setFraction(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setFraction of crcl.base.TransAccelRelativeType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," TransAccelRelativeType::setFraction jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setFraction", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.TransAccelRelativeType has no method named setFraction with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::math::BigDecimal TransAccelRelativeType::getFraction() {

   if(jthis == NULL) {
       std::cerr << "Call of method getFraction of crcl.base.TransAccelRelativeType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," TransAccelRelativeType::getFraction jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getFraction", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.TransAccelRelativeType has no method named getFraction with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   static jclass getNewTransAccelRelativeTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/TransAccelRelativeType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/TransAccelRelativeType" << std::endl;
       }
       return clss;
   }
   
   static jclass TransAccelRelativeTypeClass = NULL;
   static inline jclass getTransAccelRelativeTypeClass() {
       if (TransAccelRelativeTypeClass != NULL) {
           return TransAccelRelativeTypeClass;
       }
       TransAccelRelativeTypeClass = getNewTransAccelRelativeTypeClass();
   }
   
   // get JNI handle for class crcl.base.DwellType
   static inline jclass getDwellTypeClass();
   
   DwellType::DwellType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   DwellType::DwellType(const DwellType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   DwellType::DwellType() {
    JNIEnv *env =getEnv();
    static jclass cls = getDwellTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class DwellType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new DwellType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.DwellType
   DwellType::~DwellType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::math::BigDecimal DwellType::getDwellTime() {

   if(jthis == NULL) {
       std::cerr << "Call of method getDwellTime of crcl.base.DwellType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," DwellType::getDwellTime jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getDwellTime", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.DwellType has no method named getDwellTime with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void DwellType::setDwellTime(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setDwellTime of crcl.base.DwellType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," DwellType::setDwellTime jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setDwellTime", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.DwellType has no method named setDwellTime with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewDwellTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/DwellType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/DwellType" << std::endl;
       }
       return clss;
   }
   
   static jclass DwellTypeClass = NULL;
   static inline jclass getDwellTypeClass() {
       if (DwellTypeClass != NULL) {
           return DwellTypeClass;
       }
       DwellTypeClass = getNewDwellTypeClass();
   }
   
   // get JNI handle for class crcl.base.SetLengthUnitsType
   static inline jclass getSetLengthUnitsTypeClass();
   
   SetLengthUnitsType::SetLengthUnitsType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SetLengthUnitsType::SetLengthUnitsType(const SetLengthUnitsType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SetLengthUnitsType::SetLengthUnitsType() {
    JNIEnv *env =getEnv();
    static jclass cls = getSetLengthUnitsTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class SetLengthUnitsType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SetLengthUnitsType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.SetLengthUnitsType
   SetLengthUnitsType::~SetLengthUnitsType() {
   	// Place-holder for later extensibility.
   }

   LengthUnitEnumType SetLengthUnitsType::getUnitName() {

   if(jthis == NULL) {
       std::cerr << "Call of method getUnitName of crcl.base.SetLengthUnitsType with jthis == NULL." << std::endl;
       LengthUnitEnumType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetLengthUnitsType::getUnitName jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getUnitName", "()Lcrcl/base/LengthUnitEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetLengthUnitsType has no method named getUnitName with signature ()Lcrcl/base/LengthUnitEnumType;." << std::endl;
           LengthUnitEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    LengthUnitEnumType retObject(retVal,false);
    return retObject;
   }
   void SetLengthUnitsType::setUnitName(LengthUnitEnumType  &lengthUnitEnumType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setUnitName of crcl.base.SetLengthUnitsType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetLengthUnitsType::setUnitName jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setUnitName", "(Lcrcl/base/LengthUnitEnumType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetLengthUnitsType has no method named setUnitName with signature (Lcrcl/base/LengthUnitEnumType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,lengthUnitEnumType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewSetLengthUnitsTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/SetLengthUnitsType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/SetLengthUnitsType" << std::endl;
       }
       return clss;
   }
   
   static jclass SetLengthUnitsTypeClass = NULL;
   static inline jclass getSetLengthUnitsTypeClass() {
       if (SetLengthUnitsTypeClass != NULL) {
           return SetLengthUnitsTypeClass;
       }
       SetLengthUnitsTypeClass = getNewSetLengthUnitsTypeClass();
   }
   
   // get JNI handle for class crcl.base.OpenToolChangerType
   static inline jclass getOpenToolChangerTypeClass();
   
   OpenToolChangerType::OpenToolChangerType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   OpenToolChangerType::OpenToolChangerType(const OpenToolChangerType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   OpenToolChangerType::OpenToolChangerType() {
    JNIEnv *env =getEnv();
    static jclass cls = getOpenToolChangerTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class OpenToolChangerType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new OpenToolChangerType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.OpenToolChangerType
   OpenToolChangerType::~OpenToolChangerType() {
   	// Place-holder for later extensibility.
   }

   static jclass getNewOpenToolChangerTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/OpenToolChangerType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/OpenToolChangerType" << std::endl;
       }
       return clss;
   }
   
   static jclass OpenToolChangerTypeClass = NULL;
   static inline jclass getOpenToolChangerTypeClass() {
       if (OpenToolChangerTypeClass != NULL) {
           return OpenToolChangerTypeClass;
       }
       OpenToolChangerTypeClass = getNewOpenToolChangerTypeClass();
   }
   
   // get JNI handle for class crcl.base.SetTransAccelType
   static inline jclass getSetTransAccelTypeClass();
   
   SetTransAccelType::SetTransAccelType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SetTransAccelType::SetTransAccelType(const SetTransAccelType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SetTransAccelType::SetTransAccelType() {
    JNIEnv *env =getEnv();
    static jclass cls = getSetTransAccelTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class SetTransAccelType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SetTransAccelType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.SetTransAccelType
   SetTransAccelType::~SetTransAccelType() {
   	// Place-holder for later extensibility.
   }

   TransAccelType SetTransAccelType::getTransAccel() {

   if(jthis == NULL) {
       std::cerr << "Call of method getTransAccel of crcl.base.SetTransAccelType with jthis == NULL." << std::endl;
       TransAccelType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetTransAccelType::getTransAccel jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getTransAccel", "()Lcrcl/base/TransAccelType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetTransAccelType has no method named getTransAccel with signature ()Lcrcl/base/TransAccelType;." << std::endl;
           TransAccelType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    TransAccelType retObject(retVal,false);
    return retObject;
   }
   void SetTransAccelType::setTransAccel(TransAccelType  &transAccelType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setTransAccel of crcl.base.SetTransAccelType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetTransAccelType::setTransAccel jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setTransAccel", "(Lcrcl/base/TransAccelType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetTransAccelType has no method named setTransAccel with signature (Lcrcl/base/TransAccelType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,transAccelType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewSetTransAccelTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/SetTransAccelType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/SetTransAccelType" << std::endl;
       }
       return clss;
   }
   
   static jclass SetTransAccelTypeClass = NULL;
   static inline jclass getSetTransAccelTypeClass() {
       if (SetTransAccelTypeClass != NULL) {
           return SetTransAccelTypeClass;
       }
       SetTransAccelTypeClass = getNewSetTransAccelTypeClass();
   }
   
   // get JNI handle for class crcl.base.JointForceTorqueType
   static inline jclass getJointForceTorqueTypeClass();
   
   JointForceTorqueType::JointForceTorqueType(jobject _jthis, bool copy): JointDetailsType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   JointForceTorqueType::JointForceTorqueType(const JointForceTorqueType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   JointForceTorqueType::JointForceTorqueType() {
    JNIEnv *env =getEnv();
    static jclass cls = getJointForceTorqueTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class JointForceTorqueType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new JointForceTorqueType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.JointForceTorqueType
   JointForceTorqueType::~JointForceTorqueType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::math::BigDecimal JointForceTorqueType::getSetting() {

   if(jthis == NULL) {
       std::cerr << "Call of method getSetting of crcl.base.JointForceTorqueType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JointForceTorqueType::getSetting jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getSetting", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.JointForceTorqueType has no method named getSetting with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void JointForceTorqueType::setSetting(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setSetting of crcl.base.JointForceTorqueType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JointForceTorqueType::setSetting jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setSetting", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.JointForceTorqueType has no method named setSetting with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::math::BigDecimal JointForceTorqueType::getChangeRate() {

   if(jthis == NULL) {
       std::cerr << "Call of method getChangeRate of crcl.base.JointForceTorqueType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JointForceTorqueType::getChangeRate jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getChangeRate", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.JointForceTorqueType has no method named getChangeRate with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void JointForceTorqueType::setChangeRate(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setChangeRate of crcl.base.JointForceTorqueType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JointForceTorqueType::setChangeRate jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setChangeRate", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.JointForceTorqueType has no method named setChangeRate with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewJointForceTorqueTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/JointForceTorqueType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/JointForceTorqueType" << std::endl;
       }
       return clss;
   }
   
   static jclass JointForceTorqueTypeClass = NULL;
   static inline jclass getJointForceTorqueTypeClass() {
       if (JointForceTorqueTypeClass != NULL) {
           return JointForceTorqueTypeClass;
       }
       JointForceTorqueTypeClass = getNewJointForceTorqueTypeClass();
   }
   
   // get JNI handle for class crcl.base.PointType
   static inline jclass getPointTypeClass();
   
   PointType::PointType(jobject _jthis, bool copy): DataThingType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   PointType::PointType(const PointType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   PointType::PointType() {
    JNIEnv *env =getEnv();
    static jclass cls = getPointTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class PointType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PointType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.PointType
   PointType::~PointType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::math::BigDecimal PointType::getX() {

   if(jthis == NULL) {
       std::cerr << "Call of method getX of crcl.base.PointType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PointType::getX jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getX", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PointType has no method named getX with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   ::crclj::java::math::BigDecimal PointType::getY() {

   if(jthis == NULL) {
       std::cerr << "Call of method getY of crcl.base.PointType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PointType::getY jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getY", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PointType has no method named getY with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void PointType::setX(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setX of crcl.base.PointType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PointType::setX jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setX", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PointType has no method named setX with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void PointType::setY(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setY of crcl.base.PointType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PointType::setY jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setY", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PointType has no method named setY with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::math::BigDecimal PointType::getZ() {

   if(jthis == NULL) {
       std::cerr << "Call of method getZ of crcl.base.PointType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PointType::getZ jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getZ", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PointType has no method named getZ with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void PointType::setZ(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setZ of crcl.base.PointType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PointType::setZ jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setZ", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PointType has no method named setZ with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewPointTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/PointType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/PointType" << std::endl;
       }
       return clss;
   }
   
   static jclass PointTypeClass = NULL;
   static inline jclass getPointTypeClass() {
       if (PointTypeClass != NULL) {
           return PointTypeClass;
       }
       PointTypeClass = getNewPointTypeClass();
   }
   
   // get JNI handle for class crcl.base.CommandStateEnumType
   static inline jclass getCommandStateEnumTypeClass();
   
   CommandStateEnumType::CommandStateEnumType(jobject _jthis, bool copy): ::crclj::java::lang::Enum(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   CommandStateEnumType::CommandStateEnumType(const CommandStateEnumType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }

   // Destructor for crcl.base.CommandStateEnumType
   CommandStateEnumType::~CommandStateEnumType() {
   	// Place-holder for later extensibility.
   }

   CommandStateEnumType CommandStateEnumType::fromValue(jstring string_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCommandStateEnumTypeClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "fromValue", "(Ljava/lang/String;)Lcrcl/base/CommandStateEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CommandStateEnumType has no method named fromValue with signature (Ljava/lang/String;)Lcrcl/base/CommandStateEnumType;." << std::endl;
           CommandStateEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,string_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    CommandStateEnumType retObject(retVal,false);
    return retObject;
   }
   jstring CommandStateEnumType::value() {

   if(jthis == NULL) {
       std::cerr << "Call of method value of crcl.base.CommandStateEnumType with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CommandStateEnumType::value jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "value", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CommandStateEnumType has no method named value with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jobjectArray CommandStateEnumType::values() {

   JNIEnv *env =getEnv();
   static jclass cls = getCommandStateEnumTypeClass();
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "values", "()[Lcrcl/base/CommandStateEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CommandStateEnumType has no method named values with signature ()[Lcrcl/base/CommandStateEnumType;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallStaticObjectMethod( cls, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   CommandStateEnumType CommandStateEnumType::valueOf(jstring string_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCommandStateEnumTypeClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "valueOf", "(Ljava/lang/String;)Lcrcl/base/CommandStateEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CommandStateEnumType has no method named valueOf with signature (Ljava/lang/String;)Lcrcl/base/CommandStateEnumType;." << std::endl;
           CommandStateEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,string_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    CommandStateEnumType retObject(retVal,false);
    return retObject;
   }
   static jclass getNewCommandStateEnumTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/CommandStateEnumType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/CommandStateEnumType" << std::endl;
       }
       return clss;
   }
   
   static jclass CommandStateEnumTypeClass = NULL;
   static inline jclass getCommandStateEnumTypeClass() {
       if (CommandStateEnumTypeClass != NULL) {
           return CommandStateEnumTypeClass;
       }
       CommandStateEnumTypeClass = getNewCommandStateEnumTypeClass();
   }
  } // end namespace base

   namespace utils{
   
   // get JNI handle for class crcl.utils.CRCLPosemath
   static inline jclass getCRCLPosemathClass();
   
   CRCLPosemath::CRCLPosemath(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   CRCLPosemath::CRCLPosemath(const CRCLPosemath &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }

   // Destructor for crcl.utils.CRCLPosemath
   CRCLPosemath::~CRCLPosemath() {
   	// Place-holder for later extensibility.
   }

   ::crclj::crcl::base::PointType CRCLPosemath::subtract(::crclj::crcl::base::PointType  &pointType_0,::crclj::crcl::base::PointType  &pointType_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "subtract", "(Lcrcl/base/PointType;Lcrcl/base/PointType;)Lcrcl/base/PointType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named subtract with signature (Lcrcl/base/PointType;Lcrcl/base/PointType;)Lcrcl/base/PointType;." << std::endl;
           ::crclj::crcl::base::PointType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,pointType_0.jthis,pointType_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PointType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::PointType CRCLPosemath::multiply(::crclj::java::math::BigDecimal  &bigDecimal_0,::crclj::crcl::base::PointType  &pointType_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "multiply", "(Ljava/math/BigDecimal;Lcrcl/base/PointType;)Lcrcl/base/PointType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named multiply with signature (Ljava/math/BigDecimal;Lcrcl/base/PointType;)Lcrcl/base/PointType;." << std::endl;
           ::crclj::crcl::base::PointType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,bigDecimal_0.jthis,pointType_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PointType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::PointType CRCLPosemath::multiply(::crclj::java::math::BigDecimal  &bigDecimal_0,::crclj::crcl::base::VectorType  &vectorType_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "multiply", "(Ljava/math/BigDecimal;Lcrcl/base/VectorType;)Lcrcl/base/PointType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named multiply with signature (Ljava/math/BigDecimal;Lcrcl/base/VectorType;)Lcrcl/base/PointType;." << std::endl;
           ::crclj::crcl::base::PointType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,bigDecimal_0.jthis,vectorType_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PointType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::PointType CRCLPosemath::multiply(jdouble double_0,::crclj::crcl::base::VectorType  &vectorType_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "multiply", "(DLcrcl/base/VectorType;)Lcrcl/base/PointType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named multiply with signature (DLcrcl/base/VectorType;)Lcrcl/base/PointType;." << std::endl;
           ::crclj::crcl::base::PointType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,double_0,vectorType_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PointType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::PoseType CRCLPosemath::multiply(::crclj::crcl::base::PoseType  &poseType_0,::crclj::crcl::base::PoseType  &poseType_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "multiply", "(Lcrcl/base/PoseType;Lcrcl/base/PoseType;)Lcrcl/base/PoseType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named multiply with signature (Lcrcl/base/PoseType;Lcrcl/base/PoseType;)Lcrcl/base/PoseType;." << std::endl;
           ::crclj::crcl::base::PoseType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,poseType_0.jthis,poseType_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PoseType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::PointType CRCLPosemath::multiply(jdouble double_0,::crclj::crcl::base::PointType  &pointType_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "multiply", "(DLcrcl/base/PointType;)Lcrcl/base/PointType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named multiply with signature (DLcrcl/base/PointType;)Lcrcl/base/PointType;." << std::endl;
           ::crclj::crcl::base::PointType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,double_0,pointType_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PointType retObject(retVal,false);
    return retObject;
   }
   ::crclj::java::math::BigDecimal CRCLPosemath::dot(::crclj::crcl::base::VectorType  &vectorType_0,::crclj::crcl::base::VectorType  &vectorType_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "dot", "(Lcrcl/base/VectorType;Lcrcl/base/VectorType;)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named dot with signature (Lcrcl/base/VectorType;Lcrcl/base/VectorType;)Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,vectorType_0.jthis,vectorType_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   ::crclj::java::math::BigDecimal CRCLPosemath::dot(::crclj::crcl::base::VectorType  &vectorType_0,::crclj::crcl::base::PointType  &pointType_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "dot", "(Lcrcl/base/VectorType;Lcrcl/base/PointType;)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named dot with signature (Lcrcl/base/VectorType;Lcrcl/base/PointType;)Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,vectorType_0.jthis,pointType_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   jdouble CRCLPosemath::norm(::crclj::crcl::base::VectorType  &vectorType_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "norm", "(Lcrcl/base/VectorType;)D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named norm with signature (Lcrcl/base/VectorType;)D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallStaticDoubleMethod( cls, mid ,vectorType_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   ::crclj::crcl::base::PoseType CRCLPosemath::invert(::crclj::crcl::base::PoseType  &poseType_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "invert", "(Lcrcl/base/PoseType;)Lcrcl/base/PoseType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named invert with signature (Lcrcl/base/PoseType;)Lcrcl/base/PoseType;." << std::endl;
           ::crclj::crcl::base::PoseType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,poseType_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PoseType retObject(retVal,false);
    return retObject;
   }
   ::crclj::org::apache::commons::math3::geometry::euclidean::threed::Vector3D CRCLPosemath::toCommonsVector3D(::crclj::crcl::base::PoseType  &poseType_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "toCommonsVector3D", "(Lcrcl/base/PoseType;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named toCommonsVector3D with signature (Lcrcl/base/PoseType;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;." << std::endl;
           ::crclj::org::apache::commons::math3::geometry::euclidean::threed::Vector3D nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,poseType_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::org::apache::commons::math3::geometry::euclidean::threed::Vector3D retObject(retVal,false);
    return retObject;
   }
   ::crclj::org::apache::commons::math3::geometry::euclidean::threed::Vector3D CRCLPosemath::toCommonsVector3D(::crclj::crcl::base::PointType  &pointType_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "toCommonsVector3D", "(Lcrcl/base/PointType;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named toCommonsVector3D with signature (Lcrcl/base/PointType;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;." << std::endl;
           ::crclj::org::apache::commons::math3::geometry::euclidean::threed::Vector3D nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,pointType_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::org::apache::commons::math3::geometry::euclidean::threed::Vector3D retObject(retVal,false);
    return retObject;
   }
   ::crclj::org::apache::commons::math3::geometry::euclidean::threed::Vector3D CRCLPosemath::toCommonsVector3D(::crclj::crcl::base::VectorType  &vectorType_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "toCommonsVector3D", "(Lcrcl/base/VectorType;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named toCommonsVector3D with signature (Lcrcl/base/VectorType;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;." << std::endl;
           ::crclj::org::apache::commons::math3::geometry::euclidean::threed::Vector3D nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,vectorType_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::org::apache::commons::math3::geometry::euclidean::threed::Vector3D retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::VectorType CRCLPosemath::toCRCLUnitVector(::crclj::org::apache::commons::math3::geometry::euclidean::threed::Vector3D  &vector3D_0,::crclj::crcl::base::VectorType  &vectorType_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "toCRCLUnitVector", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lcrcl/base/VectorType;)Lcrcl/base/VectorType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named toCRCLUnitVector with signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lcrcl/base/VectorType;)Lcrcl/base/VectorType;." << std::endl;
           ::crclj::crcl::base::VectorType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,vector3D_0.jthis,vectorType_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::VectorType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::VectorType CRCLPosemath::toCRCLUnitVector(::crclj::org::apache::commons::math3::geometry::euclidean::threed::Vector3D  &vector3D_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "toCRCLUnitVector", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)Lcrcl/base/VectorType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named toCRCLUnitVector with signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)Lcrcl/base/VectorType;." << std::endl;
           ::crclj::crcl::base::VectorType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,vector3D_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::VectorType retObject(retVal,false);
    return retObject;
   }
   ::crclj::org::apache::commons::math3::geometry::euclidean::threed::Rotation CRCLPosemath::toCommonsRotation(::crclj::crcl::base::PoseType  &poseType_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "toCommonsRotation", "(Lcrcl/base/PoseType;)Lorg/apache/commons/math3/geometry/euclidean/threed/Rotation;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named toCommonsRotation with signature (Lcrcl/base/PoseType;)Lorg/apache/commons/math3/geometry/euclidean/threed/Rotation;." << std::endl;
           ::crclj::org::apache::commons::math3::geometry::euclidean::threed::Rotation nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,poseType_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::org::apache::commons::math3::geometry::euclidean::threed::Rotation retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::PointType CRCLPosemath::toCRCLPoint(::crclj::org::apache::commons::math3::geometry::euclidean::threed::Vector3D  &vector3D_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "toCRCLPoint", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)Lcrcl/base/PointType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named toCRCLPoint with signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)Lcrcl/base/PointType;." << std::endl;
           ::crclj::crcl::base::PointType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,vector3D_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PointType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::PointType CRCLPosemath::toCRCLPoint(::crclj::org::apache::commons::math3::geometry::euclidean::threed::Vector3D  &vector3D_0,::crclj::crcl::base::PointType  &pointType_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "toCRCLPoint", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lcrcl/base/PointType;)Lcrcl/base/PointType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named toCRCLPoint with signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lcrcl/base/PointType;)Lcrcl/base/PointType;." << std::endl;
           ::crclj::crcl::base::PointType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,vector3D_0.jthis,pointType_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PointType retObject(retVal,false);
    return retObject;
   }
   ::crclj::rcs::posemath::PmCartesian CRCLPosemath::pointToPmCartesian(::crclj::crcl::base::PointType  &pointType_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "pointToPmCartesian", "(Lcrcl/base/PointType;)Lrcs/posemath/PmCartesian;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named pointToPmCartesian with signature (Lcrcl/base/PointType;)Lrcs/posemath/PmCartesian;." << std::endl;
           ::crclj::rcs::posemath::PmCartesian nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,pointType_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::rcs::posemath::PmCartesian retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::PoseType CRCLPosemath::identityPose() {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "identityPose", "()Lcrcl/base/PoseType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named identityPose with signature ()Lcrcl/base/PoseType;." << std::endl;
           ::crclj::crcl::base::PoseType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PoseType retObject(retVal,false);
    return retObject;
   }
   jstring CRCLPosemath::poseToString(::crclj::crcl::base::PoseType  &poseType_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "poseToString", "(Lcrcl/base/PoseType;)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named poseToString with signature (Lcrcl/base/PoseType;)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallStaticObjectMethod( cls, mid ,poseType_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   ::crclj::rcs::posemath::PmPose CRCLPosemath::toPmPose(::crclj::crcl::base::PoseType  &poseType_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "toPmPose", "(Lcrcl/base/PoseType;)Lrcs/posemath/PmPose;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named toPmPose with signature (Lcrcl/base/PoseType;)Lrcs/posemath/PmPose;." << std::endl;
           ::crclj::rcs::posemath::PmPose nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,poseType_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::rcs::posemath::PmPose retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::VectorType CRCLPosemath::cross(::crclj::crcl::base::VectorType  &vectorType_0,::crclj::crcl::base::VectorType  &vectorType_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "cross", "(Lcrcl/base/VectorType;Lcrcl/base/VectorType;)Lcrcl/base/VectorType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named cross with signature (Lcrcl/base/VectorType;Lcrcl/base/VectorType;)Lcrcl/base/VectorType;." << std::endl;
           ::crclj::crcl::base::VectorType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,vectorType_0.jthis,vectorType_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::VectorType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::PoseType CRCLPosemath::pointXAxisZAxisToPose(::crclj::crcl::base::PointType  &pointType_0,::crclj::crcl::base::VectorType  &vectorType_1,::crclj::crcl::base::VectorType  &vectorType_2) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "pointXAxisZAxisToPose", "(Lcrcl/base/PointType;Lcrcl/base/VectorType;Lcrcl/base/VectorType;)Lcrcl/base/PoseType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named pointXAxisZAxisToPose with signature (Lcrcl/base/PointType;Lcrcl/base/VectorType;Lcrcl/base/VectorType;)Lcrcl/base/PoseType;." << std::endl;
           ::crclj::crcl::base::PoseType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,pointType_0.jthis,vectorType_1.jthis,vectorType_2.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PoseType retObject(retVal,false);
    return retObject;
   }
   jdouble CRCLPosemath::diffPoints(::crclj::crcl::base::PointType  &pointType_0,::crclj::crcl::base::PointType  &pointType_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "diffPoints", "(Lcrcl/base/PointType;Lcrcl/base/PointType;)D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named diffPoints with signature (Lcrcl/base/PointType;Lcrcl/base/PointType;)D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallStaticDoubleMethod( cls, mid ,pointType_0.jthis,pointType_1.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jdouble CRCLPosemath::diffPosesTran(::crclj::crcl::base::PoseType  &poseType_0,::crclj::crcl::base::PoseType  &poseType_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "diffPosesTran", "(Lcrcl/base/PoseType;Lcrcl/base/PoseType;)D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named diffPosesTran with signature (Lcrcl/base/PoseType;Lcrcl/base/PoseType;)D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallStaticDoubleMethod( cls, mid ,poseType_0.jthis,poseType_1.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   ::crclj::rcs::posemath::PmCartesian CRCLPosemath::vectorToPmCartesian(::crclj::crcl::base::VectorType  &vectorType_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "vectorToPmCartesian", "(Lcrcl/base/VectorType;)Lrcs/posemath/PmCartesian;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named vectorToPmCartesian with signature (Lcrcl/base/VectorType;)Lrcs/posemath/PmCartesian;." << std::endl;
           ::crclj::rcs::posemath::PmCartesian nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,vectorType_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::rcs::posemath::PmCartesian retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::PoseType CRCLPosemath::toPoseType(::crclj::rcs::posemath::PmCartesian  &pmCartesian_0,::crclj::rcs::posemath::PmRotationVector  &pmRotationVector_1,::crclj::crcl::base::PoseType  &poseType_2) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "toPoseType", "(Lrcs/posemath/PmCartesian;Lrcs/posemath/PmRotationVector;Lcrcl/base/PoseType;)Lcrcl/base/PoseType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named toPoseType with signature (Lrcs/posemath/PmCartesian;Lrcs/posemath/PmRotationVector;Lcrcl/base/PoseType;)Lcrcl/base/PoseType;." << std::endl;
           ::crclj::crcl::base::PoseType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,pmCartesian_0.jthis,pmRotationVector_1.jthis,poseType_2.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PoseType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::PoseType CRCLPosemath::toPoseType(::crclj::rcs::posemath::PmCartesian  &pmCartesian_0,::crclj::rcs::posemath::PmRotationVector  &pmRotationVector_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "toPoseType", "(Lrcs/posemath/PmCartesian;Lrcs/posemath/PmRotationVector;)Lcrcl/base/PoseType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named toPoseType with signature (Lrcs/posemath/PmCartesian;Lrcs/posemath/PmRotationVector;)Lcrcl/base/PoseType;." << std::endl;
           ::crclj::crcl::base::PoseType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,pmCartesian_0.jthis,pmRotationVector_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PoseType retObject(retVal,false);
    return retObject;
   }
   ::crclj::rcs::posemath::PmRotationMatrix CRCLPosemath::toPmRotationMatrix(::crclj::crcl::base::PoseType  &poseType_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "toPmRotationMatrix", "(Lcrcl/base/PoseType;)Lrcs/posemath/PmRotationMatrix;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named toPmRotationMatrix with signature (Lcrcl/base/PoseType;)Lrcs/posemath/PmRotationMatrix;." << std::endl;
           ::crclj::rcs::posemath::PmRotationMatrix nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,poseType_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::rcs::posemath::PmRotationMatrix retObject(retVal,false);
    return retObject;
   }
   ::crclj::rcs::posemath::PmRotationVector CRCLPosemath::toPmRotationVector(::crclj::crcl::base::PoseType  &poseType_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "toPmRotationVector", "(Lcrcl/base/PoseType;)Lrcs/posemath/PmRotationVector;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named toPmRotationVector with signature (Lcrcl/base/PoseType;)Lrcs/posemath/PmRotationVector;." << std::endl;
           ::crclj::rcs::posemath::PmRotationVector nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,poseType_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::rcs::posemath::PmRotationVector retObject(retVal,false);
    return retObject;
   }
   ::crclj::rcs::posemath::PmRpy CRCLPosemath::toPmRpy(::crclj::crcl::base::PoseType  &poseType_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "toPmRpy", "(Lcrcl/base/PoseType;)Lrcs/posemath/PmRpy;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named toPmRpy with signature (Lcrcl/base/PoseType;)Lrcs/posemath/PmRpy;." << std::endl;
           ::crclj::rcs::posemath::PmRpy nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,poseType_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::rcs::posemath::PmRpy retObject(retVal,false);
    return retObject;
   }
   jdouble CRCLPosemath::maxDiffDoubleArray(jdoubleArray doubleArray_0,jdoubleArray doubleArray_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "maxDiffDoubleArray", "([D[D)D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named maxDiffDoubleArray with signature ([D[D)D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallStaticDoubleMethod( cls, mid ,doubleArray_0,doubleArray_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jdouble CRCLPosemath::diffPosesRot(::crclj::crcl::base::PoseType  &poseType_0,::crclj::crcl::base::PoseType  &poseType_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "diffPosesRot", "(Lcrcl/base/PoseType;Lcrcl/base/PoseType;)D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named diffPosesRot with signature (Lcrcl/base/PoseType;Lcrcl/base/PoseType;)D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallStaticDoubleMethod( cls, mid ,poseType_0.jthis,poseType_1.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   ::crclj::crcl::base::PointType CRCLPosemath::toPointType(::crclj::rcs::posemath::PmCartesian  &pmCartesian_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "toPointType", "(Lrcs/posemath/PmCartesian;)Lcrcl/base/PointType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named toPointType with signature (Lrcs/posemath/PmCartesian;)Lcrcl/base/PointType;." << std::endl;
           ::crclj::crcl::base::PointType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,pmCartesian_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PointType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::VectorType CRCLPosemath::toCRCLVector(::crclj::org::apache::commons::math3::geometry::euclidean::threed::Vector3D  &vector3D_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "toCRCLVector", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)Lcrcl/base/VectorType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named toCRCLVector with signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)Lcrcl/base/VectorType;." << std::endl;
           ::crclj::crcl::base::VectorType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,vector3D_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::VectorType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::VectorType CRCLPosemath::toCRCLVector(::crclj::org::apache::commons::math3::geometry::euclidean::threed::Vector3D  &vector3D_0,::crclj::crcl::base::VectorType  &vectorType_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "toCRCLVector", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lcrcl/base/VectorType;)Lcrcl/base/VectorType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named toCRCLVector with signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lcrcl/base/VectorType;)Lcrcl/base/VectorType;." << std::endl;
           ::crclj::crcl::base::VectorType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,vector3D_0.jthis,vectorType_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::VectorType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::PointType CRCLPosemath::add(::crclj::crcl::base::PointType  &pointType_0,::crclj::crcl::base::PointType  &pointType_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "add", "(Lcrcl/base/PointType;Lcrcl/base/PointType;)Lcrcl/base/PointType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named add with signature (Lcrcl/base/PointType;Lcrcl/base/PointType;)Lcrcl/base/PointType;." << std::endl;
           ::crclj::crcl::base::PointType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,pointType_0.jthis,pointType_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PointType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::VectorType CRCLPosemath::normalize(::crclj::crcl::base::VectorType  &vectorType_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "normalize", "(Lcrcl/base/VectorType;)Lcrcl/base/VectorType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named normalize with signature (Lcrcl/base/VectorType;)Lcrcl/base/VectorType;." << std::endl;
           ::crclj::crcl::base::VectorType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,vectorType_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::VectorType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::PoseType CRCLPosemath::shift(::crclj::crcl::base::PoseType  &poseType_0,::crclj::crcl::base::PointType  &pointType_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLPosemathClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "shift", "(Lcrcl/base/PoseType;Lcrcl/base/PointType;)Lcrcl/base/PoseType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLPosemath has no method named shift with signature (Lcrcl/base/PoseType;Lcrcl/base/PointType;)Lcrcl/base/PoseType;." << std::endl;
           ::crclj::crcl::base::PoseType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,poseType_0.jthis,pointType_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PoseType retObject(retVal,false);
    return retObject;
   }
   static jclass getNewCRCLPosemathClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/CRCLPosemath");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/CRCLPosemath" << std::endl;
       }
       return clss;
   }
   
   static jclass CRCLPosemathClass = NULL;
   static inline jclass getCRCLPosemathClass() {
       if (CRCLPosemathClass != NULL) {
           return CRCLPosemathClass;
       }
       CRCLPosemathClass = getNewCRCLPosemathClass();
   }
   
   // get JNI handle for class crcl.utils.XpathUtils
   static inline jclass getXpathUtilsClass();
   
   XpathUtils::XpathUtils(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   XpathUtils::XpathUtils(const XpathUtils &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }

   // Destructor for crcl.utils.XpathUtils
   XpathUtils::~XpathUtils() {
   	// Place-holder for later extensibility.
   }

   jobjectArray XpathUtils::getSchemaFiles() {

   if(jthis == NULL) {
       std::cerr << "Call of method getSchemaFiles of crcl.utils.XpathUtils with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XpathUtils::getSchemaFiles jthis=",jthis);
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getSchemaFiles", "()[Ljava/io/File;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.XpathUtils has no method named getSchemaFiles with signature ()[Ljava/io/File;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void XpathUtils::setSchemaFiles(jobjectArray fileArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setSchemaFiles of crcl.utils.XpathUtils with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XpathUtils::setSchemaFiles jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setSchemaFiles", "([Ljava/io/File;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.XpathUtils has no method named setSchemaFiles with signature ([Ljava/io/File;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,fileArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   jstring XpathUtils::getDocumentation(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method getDocumentation of crcl.utils.XpathUtils with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XpathUtils::getDocumentation jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getDocumentation", "(Ljava/lang/String;)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.XpathUtils has no method named getDocumentation with signature (Ljava/lang/String;)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring XpathUtils::nodeToString(::crclj::org::w3c::dom::Node  &node_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method nodeToString of crcl.utils.XpathUtils with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XpathUtils::nodeToString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "nodeToString", "(Lorg/w3c/dom/Node;)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.XpathUtils has no method named nodeToString with signature (Lorg/w3c/dom/Node;)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid ,node_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring XpathUtils::queryXml(::crclj::java::io::File  &file_0,jstring string_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method queryXml of crcl.utils.XpathUtils with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XpathUtils::queryXml jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "queryXml", "(Ljava/io/File;Ljava/lang/String;)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.XpathUtils has no method named queryXml with signature (Ljava/io/File;Ljava/lang/String;)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid ,file_0.jthis,string_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring XpathUtils::queryXml(jobjectArray fileArray_0,jstring string_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method queryXml of crcl.utils.XpathUtils with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XpathUtils::queryXml jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "queryXml", "([Ljava/io/File;Ljava/lang/String;)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.XpathUtils has no method named queryXml with signature ([Ljava/io/File;Ljava/lang/String;)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid ,fileArray_0,string_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring XpathUtils::nodeListToString(::crclj::org::w3c::dom::NodeList  &nodeList_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method nodeListToString of crcl.utils.XpathUtils with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XpathUtils::nodeListToString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "nodeListToString", "(Lorg/w3c/dom/NodeList;)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.XpathUtils has no method named nodeListToString with signature (Lorg/w3c/dom/NodeList;)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid ,nodeList_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring XpathUtils::queryXmlString(jstring string_0,jstring string_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method queryXmlString of crcl.utils.XpathUtils with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XpathUtils::queryXmlString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "queryXmlString", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.XpathUtils has no method named queryXmlString with signature (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid ,string_0,string_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewXpathUtilsClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/XpathUtils");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/XpathUtils" << std::endl;
       }
       return clss;
   }
   
   static jclass XpathUtilsClass = NULL;
   static inline jclass getXpathUtilsClass() {
       if (XpathUtilsClass != NULL) {
           return XpathUtilsClass;
       }
       XpathUtilsClass = getNewXpathUtilsClass();
   }
   
   // get JNI handle for class crcl.utils.ListChooserJPanel
   static inline jclass getListChooserJPanelClass();
   
   ListChooserJPanel::ListChooserJPanel(jobject _jthis, bool copy): ::crclj::javax::swing::JPanel(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   ListChooserJPanel::ListChooserJPanel(const ListChooserJPanel &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }

   // Destructor for crcl.utils.ListChooserJPanel
   ListChooserJPanel::~ListChooserJPanel() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::lang::Object ListChooserJPanel::getSelectedChoice() {

   if(jthis == NULL) {
       std::cerr << "Call of method getSelectedChoice of crcl.utils.ListChooserJPanel with jthis == NULL." << std::endl;
       ::crclj::java::lang::Object nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ListChooserJPanel::getSelectedChoice jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getSelectedChoice", "()Ljava/lang/Object;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.ListChooserJPanel has no method named getSelectedChoice with signature ()Ljava/lang/Object;." << std::endl;
           ::crclj::java::lang::Object nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::lang::Object retObject(retVal,false);
    return retObject;
   }
   ::crclj::java::lang::Object ListChooserJPanel::Choose(::crclj::java::awt::Frame  &frame_0,jstring string_1,jobjectArray objectArray_2,::crclj::java::lang::Object  &object_3) {

   JNIEnv *env =getEnv();
   static jclass cls = getListChooserJPanelClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "Choose", "(Ljava/awt/Frame;Ljava/lang/String;[Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.ListChooserJPanel has no method named Choose with signature (Ljava/awt/Frame;Ljava/lang/String;[Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;." << std::endl;
           ::crclj::java::lang::Object nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,frame_0.jthis,string_1,objectArray_2,object_3.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::lang::Object retObject(retVal,false);
    return retObject;
   }
   static jclass getNewListChooserJPanelClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/ListChooserJPanel");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/ListChooserJPanel" << std::endl;
       }
       return clss;
   }
   
   static jclass ListChooserJPanelClass = NULL;
   static inline jclass getListChooserJPanelClass() {
       if (ListChooserJPanelClass != NULL) {
           return ListChooserJPanelClass;
       }
       ListChooserJPanelClass = getNewListChooserJPanelClass();
   }
  } // end namespace utils
 } // end namespace crcl

  namespace java{
   namespace awt{
   
   // get JNI handle for class java.awt.Window
   static inline jclass getWindowClass();
   
   Window::Window(jobject _jthis, bool copy): Container(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   Window::Window(const Window &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   Window::Window(Window  &window_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getWindowClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/awt/Window;)V");
        if (NULL == mid) {
            std::cerr << "Class Window has no method constructor signature (Ljava/awt/Window;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,window_0.jthis);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Window jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   Window::Window(Frame  &frame_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getWindowClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/awt/Frame;)V");
        if (NULL == mid) {
            std::cerr << "Class Window has no method constructor signature (Ljava/awt/Frame;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,frame_0.jthis);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Window jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for java.awt.Window
   Window::~Window() {
   	// Place-holder for later extensibility.
   }

   void Window::addNotify() {

   if(jthis == NULL) {
       std::cerr << "Call of method addNotify of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::addNotify jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "addNotify", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named addNotify with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Window::setOpacity(jfloat float_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setOpacity of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::setOpacity jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setOpacity", "(F)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named setOpacity with signature (F)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,float_0 );
       }
   }
   releaseEnv(env);
   
   }
   void Window::removeNotify() {

   if(jthis == NULL) {
       std::cerr << "Call of method removeNotify of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::removeNotify jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "removeNotify", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named removeNotify with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jfloat Window::getOpacity() {

   if(jthis == NULL) {
       std::cerr << "Call of method getOpacity of java.awt.Window with jthis == NULL." << std::endl;
       return (jfloat) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::getOpacity jthis=",jthis);
   jfloat retVal= (jfloat) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getOpacity", "()F");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named getOpacity with signature ()F." << std::endl;
           return (jfloat) -1.0;
       } else {
           retVal= (jfloat)  env->CallFloatMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jobjectArray Window::getWindows() {

   JNIEnv *env =getEnv();
   static jclass cls = getWindowClass();
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "getWindows", "()[Ljava/awt/Window;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named getWindows with signature ()[Ljava/awt/Window;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallStaticObjectMethod( cls, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   ::crclj::java::util::List Window::getIconImages() {

   if(jthis == NULL) {
       std::cerr << "Call of method getIconImages of java.awt.Window with jthis == NULL." << std::endl;
       ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::getIconImages jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getIconImages", "()Ljava/util/List;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named getIconImages with signature ()Ljava/util/List;." << std::endl;
           ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::util::List retObject(retVal,false);
    return retObject;
   }
   void Window::setIconImages(::crclj::java::util::List  &list_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setIconImages of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::setIconImages jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setIconImages", "(Ljava/util/List;)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named setIconImages with signature (Ljava/util/List;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,list_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void Window::setLocation(jint int_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method setLocation of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::setLocation jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setLocation", "(II)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named setLocation with signature (II)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0,int_1 );
       }
   }
   releaseEnv(env);
   
   }
   void Window::reshape(jint int_0,jint int_1,jint int_2,jint int_3) {

   if(jthis == NULL) {
       std::cerr << "Call of method reshape of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::reshape jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "reshape", "(IIII)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named reshape with signature (IIII)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0,int_1,int_2,int_3 );
       }
   }
   releaseEnv(env);
   
   }
   void Window::show() {

   if(jthis == NULL) {
       std::cerr << "Call of method show of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::show jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "show", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named show with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Window::hide() {

   if(jthis == NULL) {
       std::cerr << "Call of method hide of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::hide jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "hide", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named hide with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Window::toFront() {

   if(jthis == NULL) {
       std::cerr << "Call of method toFront of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::toFront jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toFront", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named toFront with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Window::toBack() {

   if(jthis == NULL) {
       std::cerr << "Call of method toBack of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::toBack jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toBack", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named toBack with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jstring Window::getWarningString() {

   if(jthis == NULL) {
       std::cerr << "Call of method getWarningString of java.awt.Window with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::getWarningString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getWarningString", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named getWarningString with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jobjectArray Window::getOwnedWindows() {

   if(jthis == NULL) {
       std::cerr << "Call of method getOwnedWindows of java.awt.Window with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::getOwnedWindows jthis=",jthis);
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getOwnedWindows", "()[Ljava/awt/Window;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named getOwnedWindows with signature ()[Ljava/awt/Window;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jobjectArray Window::getOwnerlessWindows() {

   JNIEnv *env =getEnv();
   static jclass cls = getWindowClass();
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "getOwnerlessWindows", "()[Ljava/awt/Window;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named getOwnerlessWindows with signature ()[Ljava/awt/Window;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallStaticObjectMethod( cls, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Window::setAlwaysOnTop(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setAlwaysOnTop of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::setAlwaysOnTop jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setAlwaysOnTop", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named setAlwaysOnTop with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean Window::isAlwaysOnTopSupported() {

   if(jthis == NULL) {
       std::cerr << "Call of method isAlwaysOnTopSupported of java.awt.Window with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::isAlwaysOnTopSupported jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isAlwaysOnTopSupported", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named isAlwaysOnTopSupported with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Window::isAlwaysOnTop() {

   if(jthis == NULL) {
       std::cerr << "Call of method isAlwaysOnTop of java.awt.Window with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::isAlwaysOnTop jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isAlwaysOnTop", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named isAlwaysOnTop with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   Component Window::getFocusOwner() {

   if(jthis == NULL) {
       std::cerr << "Call of method getFocusOwner of java.awt.Window with jthis == NULL." << std::endl;
       Component nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::getFocusOwner jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getFocusOwner", "()Ljava/awt/Component;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named getFocusOwner with signature ()Ljava/awt/Component;." << std::endl;
           Component nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Component retObject(retVal,false);
    return retObject;
   }
   Component Window::getMostRecentFocusOwner() {

   if(jthis == NULL) {
       std::cerr << "Call of method getMostRecentFocusOwner of java.awt.Window with jthis == NULL." << std::endl;
       Component nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::getMostRecentFocusOwner jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getMostRecentFocusOwner", "()Ljava/awt/Component;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named getMostRecentFocusOwner with signature ()Ljava/awt/Component;." << std::endl;
           Component nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Component retObject(retVal,false);
    return retObject;
   }
   jboolean Window::isActive() {

   if(jthis == NULL) {
       std::cerr << "Call of method isActive of java.awt.Window with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::isActive jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isActive", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named isActive with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Window::isFocused() {

   if(jthis == NULL) {
       std::cerr << "Call of method isFocused of java.awt.Window with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::isFocused jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isFocused", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named isFocused with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Window::setFocusCycleRoot(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setFocusCycleRoot of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::setFocusCycleRoot jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setFocusCycleRoot", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named setFocusCycleRoot with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean Window::isFocusCycleRoot() {

   if(jthis == NULL) {
       std::cerr << "Call of method isFocusCycleRoot of java.awt.Window with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::isFocusCycleRoot jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isFocusCycleRoot", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named isFocusCycleRoot with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   Container Window::getFocusCycleRootAncestor() {

   if(jthis == NULL) {
       std::cerr << "Call of method getFocusCycleRootAncestor of java.awt.Window with jthis == NULL." << std::endl;
       Container nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::getFocusCycleRootAncestor jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getFocusCycleRootAncestor", "()Ljava/awt/Container;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named getFocusCycleRootAncestor with signature ()Ljava/awt/Container;." << std::endl;
           Container nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Container retObject(retVal,false);
    return retObject;
   }
   jboolean Window::isFocusableWindow() {

   if(jthis == NULL) {
       std::cerr << "Call of method isFocusableWindow of java.awt.Window with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::isFocusableWindow jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isFocusableWindow", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named isFocusableWindow with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Window::getFocusableWindowState() {

   if(jthis == NULL) {
       std::cerr << "Call of method getFocusableWindowState of java.awt.Window with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::getFocusableWindowState jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getFocusableWindowState", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named getFocusableWindowState with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Window::setFocusableWindowState(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setFocusableWindowState of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::setFocusableWindowState jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setFocusableWindowState", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named setFocusableWindowState with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   void Window::setAutoRequestFocus(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setAutoRequestFocus of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::setAutoRequestFocus jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setAutoRequestFocus", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named setAutoRequestFocus with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean Window::isAutoRequestFocus() {

   if(jthis == NULL) {
       std::cerr << "Call of method isAutoRequestFocus of java.awt.Window with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::isAutoRequestFocus jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isAutoRequestFocus", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named isAutoRequestFocus with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Window::isValidateRoot() {

   if(jthis == NULL) {
       std::cerr << "Call of method isValidateRoot of java.awt.Window with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::isValidateRoot jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isValidateRoot", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named isValidateRoot with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Window::isShowing() {

   if(jthis == NULL) {
       std::cerr << "Call of method isShowing of java.awt.Window with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::isShowing jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isShowing", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named isShowing with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Window::applyResourceBundle(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method applyResourceBundle of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::applyResourceBundle jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "applyResourceBundle", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named applyResourceBundle with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   void Window::setLocationRelativeTo(Component  &component_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setLocationRelativeTo of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::setLocationRelativeTo jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setLocationRelativeTo", "(Ljava/awt/Component;)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named setLocationRelativeTo with signature (Ljava/awt/Component;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,component_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void Window::createBufferStrategy(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method createBufferStrategy of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::createBufferStrategy jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createBufferStrategy", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named createBufferStrategy with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   void Window::setLocationByPlatform(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setLocationByPlatform of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::setLocationByPlatform jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setLocationByPlatform", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named setLocationByPlatform with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean Window::isLocationByPlatform() {

   if(jthis == NULL) {
       std::cerr << "Call of method isLocationByPlatform of java.awt.Window with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::isLocationByPlatform jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isLocationByPlatform", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named isLocationByPlatform with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Window::setBounds(jint int_0,jint int_1,jint int_2,jint int_3) {

   if(jthis == NULL) {
       std::cerr << "Call of method setBounds of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::setBounds jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setBounds", "(IIII)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named setBounds with signature (IIII)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0,int_1,int_2,int_3 );
       }
   }
   releaseEnv(env);
   
   }
   void Window::dispose() {

   if(jthis == NULL) {
       std::cerr << "Call of method dispose of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::dispose jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "dispose", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named dispose with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Window::pack() {

   if(jthis == NULL) {
       std::cerr << "Call of method pack of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::pack jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "pack", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named pack with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Window::setVisible(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setVisible of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::setVisible jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setVisible", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named setVisible with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean Window::isOpaque() {

   if(jthis == NULL) {
       std::cerr << "Call of method isOpaque of java.awt.Window with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::isOpaque jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isOpaque", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named isOpaque with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Window::setSize(jint int_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method setSize of java.awt.Window with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::setSize jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setSize", "(II)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named setSize with signature (II)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0,int_1 );
       }
   }
   releaseEnv(env);
   
   }
   Window Window::getOwner() {

   if(jthis == NULL) {
       std::cerr << "Call of method getOwner of java.awt.Window with jthis == NULL." << std::endl;
       Window nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Window::getOwner jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getOwner", "()Ljava/awt/Window;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Window has no method named getOwner with signature ()Ljava/awt/Window;." << std::endl;
           Window nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Window retObject(retVal,false);
    return retObject;
   }
   static jclass getNewWindowClass() {
       jclass clss = getEnv()->FindClass("java/awt/Window");
       if (NULL == clss) {
           std::cerr << " Can't find class java/awt/Window" << std::endl;
       }
       return clss;
   }
   
   static jclass WindowClass = NULL;
   static inline jclass getWindowClass() {
       if (WindowClass != NULL) {
           return WindowClass;
       }
       WindowClass = getNewWindowClass();
   }
   
   // get JNI handle for class java.awt.Frame
   static inline jclass getFrameClass();
   
   Frame::Frame(jobject _jthis, bool copy): Window(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   Frame::Frame(const Frame &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   Frame::Frame(jstring string_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getFrameClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        if (NULL == mid) {
            std::cerr << "Class Frame has no method constructor signature (Ljava/lang/String;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,string_0);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Frame jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   Frame::Frame() {
    JNIEnv *env =getEnv();
    static jclass cls = getFrameClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class Frame has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Frame jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for java.awt.Frame
   Frame::~Frame() {
   	// Place-holder for later extensibility.
   }

   void Frame::addNotify() {

   if(jthis == NULL) {
       std::cerr << "Call of method addNotify of java.awt.Frame with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Frame::addNotify jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "addNotify", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Frame has no method named addNotify with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jstring Frame::getTitle() {

   if(jthis == NULL) {
       std::cerr << "Call of method getTitle of java.awt.Frame with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Frame::getTitle jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getTitle", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Frame has no method named getTitle with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Frame::isResizable() {

   if(jthis == NULL) {
       std::cerr << "Call of method isResizable of java.awt.Frame with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Frame::isResizable jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isResizable", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Frame has no method named isResizable with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Frame::setResizable(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setResizable of java.awt.Frame with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Frame::setResizable jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setResizable", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Frame has no method named setResizable with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   void Frame::setState(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setState of java.awt.Frame with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Frame::setState jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setState", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Frame has no method named setState with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   void Frame::setExtendedState(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setExtendedState of java.awt.Frame with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Frame::setExtendedState jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setExtendedState", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Frame has no method named setExtendedState with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   jint Frame::getExtendedState() {

   if(jthis == NULL) {
       std::cerr << "Call of method getExtendedState of java.awt.Frame with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Frame::getExtendedState jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getExtendedState", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Frame has no method named getExtendedState with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean Frame::isUndecorated() {

   if(jthis == NULL) {
       std::cerr << "Call of method isUndecorated of java.awt.Frame with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Frame::isUndecorated jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isUndecorated", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Frame has no method named isUndecorated with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Frame::setOpacity(jfloat float_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setOpacity of java.awt.Frame with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Frame::setOpacity jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setOpacity", "(F)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Frame has no method named setOpacity with signature (F)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,float_0 );
       }
   }
   releaseEnv(env);
   
   }
   void Frame::removeNotify() {

   if(jthis == NULL) {
       std::cerr << "Call of method removeNotify of java.awt.Frame with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Frame::removeNotify jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "removeNotify", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Frame has no method named removeNotify with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Frame::setCursor(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCursor of java.awt.Frame with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Frame::setCursor jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCursor", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Frame has no method named setCursor with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   jint Frame::getCursorType() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCursorType of java.awt.Frame with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Frame::getCursorType jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCursorType", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Frame has no method named getCursorType with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jobjectArray Frame::getFrames() {

   JNIEnv *env =getEnv();
   static jclass cls = getFrameClass();
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "getFrames", "()[Ljava/awt/Frame;");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Frame has no method named getFrames with signature ()[Ljava/awt/Frame;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallStaticObjectMethod( cls, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Frame::setUndecorated(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setUndecorated of java.awt.Frame with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Frame::setUndecorated jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setUndecorated", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Frame has no method named setUndecorated with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   void Frame::setTitle(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setTitle of java.awt.Frame with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Frame::setTitle jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setTitle", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Frame has no method named setTitle with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   jint Frame::getState() {

   if(jthis == NULL) {
       std::cerr << "Call of method getState of java.awt.Frame with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Frame::getState jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getState", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.awt.Frame has no method named getState with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewFrameClass() {
       jclass clss = getEnv()->FindClass("java/awt/Frame");
       if (NULL == clss) {
           std::cerr << " Can't find class java/awt/Frame" << std::endl;
       }
       return clss;
   }
   
   static jclass FrameClass = NULL;
   static inline jclass getFrameClass() {
       if (FrameClass != NULL) {
           return FrameClass;
       }
       FrameClass = getNewFrameClass();
   }
  } // end namespace awt
 } // end namespace java

  namespace javax{
   namespace swing{
   
   // get JNI handle for class javax.swing.JFrame
   static inline jclass getJFrameClass();
   
   JFrame::JFrame(jobject _jthis, bool copy): ::crclj::java::awt::Frame(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   JFrame::JFrame(const JFrame &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   JFrame::JFrame() {
    JNIEnv *env =getEnv();
    static jclass cls = getJFrameClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class JFrame has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new JFrame jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   JFrame::JFrame(jstring string_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getJFrameClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        if (NULL == mid) {
            std::cerr << "Class JFrame has no method constructor signature (Ljava/lang/String;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,string_0);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new JFrame jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for javax.swing.JFrame
   JFrame::~JFrame() {
   	// Place-holder for later extensibility.
   }

   jint JFrame::getDefaultCloseOperation() {

   if(jthis == NULL) {
       std::cerr << "Call of method getDefaultCloseOperation of javax.swing.JFrame with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JFrame::getDefaultCloseOperation jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getDefaultCloseOperation", "()I");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JFrame has no method named getDefaultCloseOperation with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void JFrame::setContentPane(::crclj::java::awt::Container  &container_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setContentPane of javax.swing.JFrame with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JFrame::setContentPane jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setContentPane", "(Ljava/awt/Container;)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JFrame has no method named setContentPane with signature (Ljava/awt/Container;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,container_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::awt::Component JFrame::getGlassPane() {

   if(jthis == NULL) {
       std::cerr << "Call of method getGlassPane of javax.swing.JFrame with jthis == NULL." << std::endl;
       ::crclj::java::awt::Component nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JFrame::getGlassPane jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getGlassPane", "()Ljava/awt/Component;");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JFrame has no method named getGlassPane with signature ()Ljava/awt/Component;." << std::endl;
           ::crclj::java::awt::Component nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::awt::Component retObject(retVal,false);
    return retObject;
   }
   void JFrame::setGlassPane(::crclj::java::awt::Component  &component_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setGlassPane of javax.swing.JFrame with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JFrame::setGlassPane jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setGlassPane", "(Ljava/awt/Component;)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JFrame has no method named setGlassPane with signature (Ljava/awt/Component;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,component_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void JFrame::repaint(jlong long_0,jint int_1,jint int_2,jint int_3,jint int_4) {

   if(jthis == NULL) {
       std::cerr << "Call of method repaint of javax.swing.JFrame with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JFrame::repaint jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "repaint", "(JIIII)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JFrame has no method named repaint with signature (JIIII)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,long_0,int_1,int_2,int_3,int_4 );
       }
   }
   releaseEnv(env);
   
   }
   void JFrame::setDefaultLookAndFeelDecorated(jboolean boolean_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getJFrameClass();
   
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "setDefaultLookAndFeelDecorated", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JFrame has no method named setDefaultLookAndFeelDecorated with signature (Z)V." << std::endl;
           
       } else {
            env->CallStaticVoidMethod( cls, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean JFrame::isDefaultLookAndFeelDecorated() {

   JNIEnv *env =getEnv();
   static jclass cls = getJFrameClass();
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "isDefaultLookAndFeelDecorated", "()Z");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JFrame has no method named isDefaultLookAndFeelDecorated with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallStaticBooleanMethod( cls, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   ::crclj::java::awt::Container JFrame::getContentPane() {

   if(jthis == NULL) {
       std::cerr << "Call of method getContentPane of javax.swing.JFrame with jthis == NULL." << std::endl;
       ::crclj::java::awt::Container nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JFrame::getContentPane jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getContentPane", "()Ljava/awt/Container;");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JFrame has no method named getContentPane with signature ()Ljava/awt/Container;." << std::endl;
           ::crclj::java::awt::Container nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::awt::Container retObject(retVal,false);
    return retObject;
   }
   void JFrame::setDefaultCloseOperation(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setDefaultCloseOperation of javax.swing.JFrame with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JFrame::setDefaultCloseOperation jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setDefaultCloseOperation", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JFrame has no method named setDefaultCloseOperation with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   void JFrame::remove(::crclj::java::awt::Component  &component_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method remove of javax.swing.JFrame with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JFrame::remove jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "remove", "(Ljava/awt/Component;)V");
       if (NULL == mid) {
           std::cerr << "Class javax.swing.JFrame has no method named remove with signature (Ljava/awt/Component;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,component_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewJFrameClass() {
       jclass clss = getEnv()->FindClass("javax/swing/JFrame");
       if (NULL == clss) {
           std::cerr << " Can't find class javax/swing/JFrame" << std::endl;
       }
       return clss;
   }
   
   static jclass JFrameClass = NULL;
   static inline jclass getJFrameClass() {
       if (JFrameClass != NULL) {
           return JFrameClass;
       }
       JFrameClass = getNewJFrameClass();
   }
  } // end namespace swing
 } // end namespace javax

  namespace crcl{
   namespace utils{
   
   // get JNI handle for class crcl.utils.LauncherJFrame
   static inline jclass getLauncherJFrameClass();
   
   LauncherJFrame::LauncherJFrame(jobject _jthis, bool copy): ::crclj::javax::swing::JFrame(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   LauncherJFrame::LauncherJFrame(const LauncherJFrame &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   LauncherJFrame::LauncherJFrame() {
    JNIEnv *env =getEnv();
    static jclass cls = getLauncherJFrameClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class LauncherJFrame has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new LauncherJFrame jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.LauncherJFrame
   LauncherJFrame::~LauncherJFrame() {
   	// Place-holder for later extensibility.
   }

   void LauncherJFrame::main(jobjectArray stringArray_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getLauncherJFrameClass();
   
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "main", "([Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.LauncherJFrame has no method named main with signature ([Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallStaticVoidMethod( cls, mid ,stringArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void LauncherJFrame::main(int argc, const char **argv) {
           if(argc <1 || argv==NULL) {
                main(NULL);
           } else {
               JNIEnv *env =getEnv();
               jclass strClss = getStringClass();
               jobjectArray stringArray = env->NewObjectArray(argc,strClss,getEmptyString());
               for(int i = 0; i < argc; i++) {
                   jstring str = env->NewStringUTF(argv[i]);
                   env->SetObjectArrayElement(stringArray,i,str);
               }
                main(stringArray);
               for(int i = 0; i < argc; i++) {
                   jobject str = env->GetObjectArrayElement(stringArray,i);
                   jobjectRefType ref = env->GetObjectRefType(str);
                   if(ref == JNIGlobalRefType) {
                       env->DeleteGlobalRef(str);
                   }
               }
               jobjectRefType ref = env->GetObjectRefType(stringArray);
               if(ref == JNIGlobalRefType) {
                   env->DeleteGlobalRef(stringArray);
               }
               return ;
           }
   }
   static jclass getNewLauncherJFrameClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/LauncherJFrame");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/LauncherJFrame" << std::endl;
       }
       return clss;
   }
   
   static jclass LauncherJFrameClass = NULL;
   static inline jclass getLauncherJFrameClass() {
       if (LauncherJFrameClass != NULL) {
           return LauncherJFrameClass;
       }
       LauncherJFrameClass = getNewLauncherJFrameClass();
   }
   
   // get JNI handle for class crcl.utils.SimulatedKinematicsPlausible
   static inline jclass getSimulatedKinematicsPlausibleClass();
   
   SimulatedKinematicsPlausible::SimulatedKinematicsPlausible(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SimulatedKinematicsPlausible::SimulatedKinematicsPlausible(const SimulatedKinematicsPlausible &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SimulatedKinematicsPlausible::SimulatedKinematicsPlausible() {
    JNIEnv *env =getEnv();
    static jclass cls = getSimulatedKinematicsPlausibleClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class SimulatedKinematicsPlausible has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SimulatedKinematicsPlausible jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.SimulatedKinematicsPlausible
   SimulatedKinematicsPlausible::~SimulatedKinematicsPlausible() {
   	// Place-holder for later extensibility.
   }

   jdouble SimulatedKinematicsPlausible::getScale() {

   if(jthis == NULL) {
       std::cerr << "Call of method getScale of crcl.utils.SimulatedKinematicsPlausible with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimulatedKinematicsPlausible::getScale jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getScale", "()D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimulatedKinematicsPlausible has no method named getScale with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimulatedKinematicsPlausible::setScale(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setScale of crcl.utils.SimulatedKinematicsPlausible with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimulatedKinematicsPlausible::setScale jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setScale", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimulatedKinematicsPlausible has no method named setScale with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimulatedKinematicsPlausible::setSeglengths(jdoubleArray doubleArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setSeglengths of crcl.utils.SimulatedKinematicsPlausible with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimulatedKinematicsPlausible::setSeglengths jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setSeglengths", "([D)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimulatedKinematicsPlausible has no method named setSeglengths with signature ([D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,doubleArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::crcl::base::PoseType SimulatedKinematicsPlausible::jointsToPose(jdoubleArray doubleArray_0,::crclj::crcl::base::PoseType  &poseType_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method jointsToPose of crcl.utils.SimulatedKinematicsPlausible with jthis == NULL." << std::endl;
       ::crclj::crcl::base::PoseType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimulatedKinematicsPlausible::jointsToPose jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "jointsToPose", "([DLcrcl/base/PoseType;)Lcrcl/base/PoseType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimulatedKinematicsPlausible has no method named jointsToPose with signature ([DLcrcl/base/PoseType;)Lcrcl/base/PoseType;." << std::endl;
           ::crclj::crcl::base::PoseType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,doubleArray_0,poseType_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PoseType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::PoseType SimulatedKinematicsPlausible::jointsToPose(jdoubleArray doubleArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method jointsToPose of crcl.utils.SimulatedKinematicsPlausible with jthis == NULL." << std::endl;
       ::crclj::crcl::base::PoseType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimulatedKinematicsPlausible::jointsToPose jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "jointsToPose", "([D)Lcrcl/base/PoseType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimulatedKinematicsPlausible has no method named jointsToPose with signature ([D)Lcrcl/base/PoseType;." << std::endl;
           ::crclj::crcl::base::PoseType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,doubleArray_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PoseType retObject(retVal,false);
    return retObject;
   }
   jdoubleArray SimulatedKinematicsPlausible::getSeglengths() {

   if(jthis == NULL) {
       std::cerr << "Call of method getSeglengths of crcl.utils.SimulatedKinematicsPlausible with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimulatedKinematicsPlausible::getSeglengths jthis=",jthis);
   jdoubleArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getSeglengths", "()[D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimulatedKinematicsPlausible has no method named getSeglengths with signature ()[D." << std::endl;
           return NULL;
       } else {
           retVal= (jdoubleArray)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jdoubleArray SimulatedKinematicsPlausible::poseToJoints(jdoubleArray doubleArray_0,::crclj::crcl::base::PoseType  &poseType_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method poseToJoints of crcl.utils.SimulatedKinematicsPlausible with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimulatedKinematicsPlausible::poseToJoints jthis=",jthis);
   jdoubleArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "poseToJoints", "([DLcrcl/base/PoseType;)[D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimulatedKinematicsPlausible has no method named poseToJoints with signature ([DLcrcl/base/PoseType;)[D." << std::endl;
           return NULL;
       } else {
           retVal= (jdoubleArray)  env->CallObjectMethod(jthis, mid ,doubleArray_0,poseType_1.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewSimulatedKinematicsPlausibleClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/SimulatedKinematicsPlausible");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/SimulatedKinematicsPlausible" << std::endl;
       }
       return clss;
   }
   
   static jclass SimulatedKinematicsPlausibleClass = NULL;
   static inline jclass getSimulatedKinematicsPlausibleClass() {
       if (SimulatedKinematicsPlausibleClass != NULL) {
           return SimulatedKinematicsPlausibleClass;
       }
       SimulatedKinematicsPlausibleClass = getNewSimulatedKinematicsPlausibleClass();
   }
   
   // get JNI handle for class crcl.utils.GripperJFrame
   static inline jclass getGripperJFrameClass();
   
   GripperJFrame::GripperJFrame(jobject _jthis, bool copy): ::crclj::javax::swing::JFrame(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   GripperJFrame::GripperJFrame(const GripperJFrame &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   GripperJFrame::GripperJFrame() {
    JNIEnv *env =getEnv();
    static jclass cls = getGripperJFrameClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class GripperJFrame has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new GripperJFrame jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.GripperJFrame
   GripperJFrame::~GripperJFrame() {
   	// Place-holder for later extensibility.
   }

   void GripperJFrame::setPort(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setPort of crcl.utils.GripperJFrame with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," GripperJFrame::setPort jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setPort", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.GripperJFrame has no method named setPort with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   jint GripperJFrame::getDelayMillis() {

   if(jthis == NULL) {
       std::cerr << "Call of method getDelayMillis of crcl.utils.GripperJFrame with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," GripperJFrame::getDelayMillis jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getDelayMillis", "()I");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.GripperJFrame has no method named getDelayMillis with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void GripperJFrame::setDelayMillis(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setDelayMillis of crcl.utils.GripperJFrame with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," GripperJFrame::setDelayMillis jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setDelayMillis", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.GripperJFrame has no method named setDelayMillis with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   void GripperJFrame::main(jobjectArray stringArray_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getGripperJFrameClass();
   
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "main", "([Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.GripperJFrame has no method named main with signature ([Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallStaticVoidMethod( cls, mid ,stringArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void GripperJFrame::main(int argc, const char **argv) {
           if(argc <1 || argv==NULL) {
                main(NULL);
           } else {
               JNIEnv *env =getEnv();
               jclass strClss = getStringClass();
               jobjectArray stringArray = env->NewObjectArray(argc,strClss,getEmptyString());
               for(int i = 0; i < argc; i++) {
                   jstring str = env->NewStringUTF(argv[i]);
                   env->SetObjectArrayElement(stringArray,i,str);
               }
                main(stringArray);
               for(int i = 0; i < argc; i++) {
                   jobject str = env->GetObjectArrayElement(stringArray,i);
                   jobjectRefType ref = env->GetObjectRefType(str);
                   if(ref == JNIGlobalRefType) {
                       env->DeleteGlobalRef(str);
                   }
               }
               jobjectRefType ref = env->GetObjectRefType(stringArray);
               if(ref == JNIGlobalRefType) {
                   env->DeleteGlobalRef(stringArray);
               }
               return ;
           }
   }
   jint GripperJFrame::getPort() {

   if(jthis == NULL) {
       std::cerr << "Call of method getPort of crcl.utils.GripperJFrame with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," GripperJFrame::getPort jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getPort", "()I");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.GripperJFrame has no method named getPort with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewGripperJFrameClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/GripperJFrame");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/GripperJFrame" << std::endl;
       }
       return clss;
   }
   
   static jclass GripperJFrameClass = NULL;
   static inline jclass getGripperJFrameClass() {
       if (GripperJFrameClass != NULL) {
           return GripperJFrameClass;
       }
       GripperJFrameClass = getNewGripperJFrameClass();
   }
  } // end namespace utils

   namespace base{
   
   // get JNI handle for class crcl.base.RotAccelType
   static inline jclass getRotAccelTypeClass();
   
   RotAccelType::RotAccelType(jobject _jthis, bool copy): DataThingType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   RotAccelType::RotAccelType(const RotAccelType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   RotAccelType::RotAccelType() {
    JNIEnv *env =getEnv();
    static jclass cls = getRotAccelTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class RotAccelType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new RotAccelType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.RotAccelType
   RotAccelType::~RotAccelType() {
   	// Place-holder for later extensibility.
   }

   static jclass getNewRotAccelTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/RotAccelType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/RotAccelType" << std::endl;
       }
       return clss;
   }
   
   static jclass RotAccelTypeClass = NULL;
   static inline jclass getRotAccelTypeClass() {
       if (RotAccelTypeClass != NULL) {
           return RotAccelTypeClass;
       }
       RotAccelTypeClass = getNewRotAccelTypeClass();
   }
   
   // get JNI handle for class crcl.base.ActuateJointsType
   static inline jclass getActuateJointsTypeClass();
   
   ActuateJointsType::ActuateJointsType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   ActuateJointsType::ActuateJointsType(const ActuateJointsType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   ActuateJointsType::ActuateJointsType() {
    JNIEnv *env =getEnv();
    static jclass cls = getActuateJointsTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class ActuateJointsType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new ActuateJointsType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.ActuateJointsType
   ActuateJointsType::~ActuateJointsType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::util::List ActuateJointsType::getActuateJoint() {

   if(jthis == NULL) {
       std::cerr << "Call of method getActuateJoint of crcl.base.ActuateJointsType with jthis == NULL." << std::endl;
       ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ActuateJointsType::getActuateJoint jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getActuateJoint", "()Ljava/util/List;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ActuateJointsType has no method named getActuateJoint with signature ()Ljava/util/List;." << std::endl;
           ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::util::List retObject(retVal,false);
    return retObject;
   }
   static jclass getNewActuateJointsTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/ActuateJointsType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/ActuateJointsType" << std::endl;
       }
       return clss;
   }
   
   static jclass ActuateJointsTypeClass = NULL;
   static inline jclass getActuateJointsTypeClass() {
       if (ActuateJointsTypeClass != NULL) {
           return ActuateJointsTypeClass;
       }
       ActuateJointsTypeClass = getNewActuateJointsTypeClass();
   }
   
   // get JNI handle for class crcl.base.MessageType
   static inline jclass getMessageTypeClass();
   
   MessageType::MessageType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   MessageType::MessageType(const MessageType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   MessageType::MessageType() {
    JNIEnv *env =getEnv();
    static jclass cls = getMessageTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class MessageType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new MessageType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.MessageType
   MessageType::~MessageType() {
   	// Place-holder for later extensibility.
   }

   void MessageType::setMessage(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setMessage of crcl.base.MessageType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MessageType::setMessage jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setMessage", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MessageType has no method named setMessage with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   jstring MessageType::getMessage() {

   if(jthis == NULL) {
       std::cerr << "Call of method getMessage of crcl.base.MessageType with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MessageType::getMessage jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getMessage", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MessageType has no method named getMessage with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewMessageTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/MessageType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/MessageType" << std::endl;
       }
       return clss;
   }
   
   static jclass MessageTypeClass = NULL;
   static inline jclass getMessageTypeClass() {
       if (MessageTypeClass != NULL) {
           return MessageTypeClass;
       }
       MessageTypeClass = getNewMessageTypeClass();
   }
   
   // get JNI handle for class crcl.base.AngleUnitEnumType
   static inline jclass getAngleUnitEnumTypeClass();
   
   AngleUnitEnumType::AngleUnitEnumType(jobject _jthis, bool copy): ::crclj::java::lang::Enum(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   AngleUnitEnumType::AngleUnitEnumType(const AngleUnitEnumType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }

   // Destructor for crcl.base.AngleUnitEnumType
   AngleUnitEnumType::~AngleUnitEnumType() {
   	// Place-holder for later extensibility.
   }

   AngleUnitEnumType AngleUnitEnumType::fromValue(jstring string_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getAngleUnitEnumTypeClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "fromValue", "(Ljava/lang/String;)Lcrcl/base/AngleUnitEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.AngleUnitEnumType has no method named fromValue with signature (Ljava/lang/String;)Lcrcl/base/AngleUnitEnumType;." << std::endl;
           AngleUnitEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,string_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    AngleUnitEnumType retObject(retVal,false);
    return retObject;
   }
   jstring AngleUnitEnumType::value() {

   if(jthis == NULL) {
       std::cerr << "Call of method value of crcl.base.AngleUnitEnumType with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," AngleUnitEnumType::value jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "value", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.AngleUnitEnumType has no method named value with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jobjectArray AngleUnitEnumType::values() {

   JNIEnv *env =getEnv();
   static jclass cls = getAngleUnitEnumTypeClass();
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "values", "()[Lcrcl/base/AngleUnitEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.AngleUnitEnumType has no method named values with signature ()[Lcrcl/base/AngleUnitEnumType;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallStaticObjectMethod( cls, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   AngleUnitEnumType AngleUnitEnumType::valueOf(jstring string_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getAngleUnitEnumTypeClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "valueOf", "(Ljava/lang/String;)Lcrcl/base/AngleUnitEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.AngleUnitEnumType has no method named valueOf with signature (Ljava/lang/String;)Lcrcl/base/AngleUnitEnumType;." << std::endl;
           AngleUnitEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,string_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    AngleUnitEnumType retObject(retVal,false);
    return retObject;
   }
   static jclass getNewAngleUnitEnumTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/AngleUnitEnumType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/AngleUnitEnumType" << std::endl;
       }
       return clss;
   }
   
   static jclass AngleUnitEnumTypeClass = NULL;
   static inline jclass getAngleUnitEnumTypeClass() {
       if (AngleUnitEnumTypeClass != NULL) {
           return AngleUnitEnumTypeClass;
       }
       AngleUnitEnumTypeClass = getNewAngleUnitEnumTypeClass();
   }
   
   // get JNI handle for class crcl.base.TransAccelAbsoluteType
   static inline jclass getTransAccelAbsoluteTypeClass();
   
   TransAccelAbsoluteType::TransAccelAbsoluteType(jobject _jthis, bool copy): TransAccelType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   TransAccelAbsoluteType::TransAccelAbsoluteType(const TransAccelAbsoluteType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   TransAccelAbsoluteType::TransAccelAbsoluteType() {
    JNIEnv *env =getEnv();
    static jclass cls = getTransAccelAbsoluteTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class TransAccelAbsoluteType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new TransAccelAbsoluteType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.TransAccelAbsoluteType
   TransAccelAbsoluteType::~TransAccelAbsoluteType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::math::BigDecimal TransAccelAbsoluteType::getSetting() {

   if(jthis == NULL) {
       std::cerr << "Call of method getSetting of crcl.base.TransAccelAbsoluteType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," TransAccelAbsoluteType::getSetting jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getSetting", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.TransAccelAbsoluteType has no method named getSetting with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void TransAccelAbsoluteType::setSetting(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setSetting of crcl.base.TransAccelAbsoluteType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," TransAccelAbsoluteType::setSetting jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setSetting", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.TransAccelAbsoluteType has no method named setSetting with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewTransAccelAbsoluteTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/TransAccelAbsoluteType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/TransAccelAbsoluteType" << std::endl;
       }
       return clss;
   }
   
   static jclass TransAccelAbsoluteTypeClass = NULL;
   static inline jclass getTransAccelAbsoluteTypeClass() {
       if (TransAccelAbsoluteTypeClass != NULL) {
           return TransAccelAbsoluteTypeClass;
       }
       TransAccelAbsoluteTypeClass = getNewTransAccelAbsoluteTypeClass();
   }
   
   // get JNI handle for class crcl.base.TorqueUnitEnumType
   static inline jclass getTorqueUnitEnumTypeClass();
   
   TorqueUnitEnumType::TorqueUnitEnumType(jobject _jthis, bool copy): ::crclj::java::lang::Enum(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   TorqueUnitEnumType::TorqueUnitEnumType(const TorqueUnitEnumType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }

   // Destructor for crcl.base.TorqueUnitEnumType
   TorqueUnitEnumType::~TorqueUnitEnumType() {
   	// Place-holder for later extensibility.
   }

   TorqueUnitEnumType TorqueUnitEnumType::fromValue(jstring string_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getTorqueUnitEnumTypeClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "fromValue", "(Ljava/lang/String;)Lcrcl/base/TorqueUnitEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.TorqueUnitEnumType has no method named fromValue with signature (Ljava/lang/String;)Lcrcl/base/TorqueUnitEnumType;." << std::endl;
           TorqueUnitEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,string_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    TorqueUnitEnumType retObject(retVal,false);
    return retObject;
   }
   jstring TorqueUnitEnumType::value() {

   if(jthis == NULL) {
       std::cerr << "Call of method value of crcl.base.TorqueUnitEnumType with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," TorqueUnitEnumType::value jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "value", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.TorqueUnitEnumType has no method named value with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jobjectArray TorqueUnitEnumType::values() {

   JNIEnv *env =getEnv();
   static jclass cls = getTorqueUnitEnumTypeClass();
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "values", "()[Lcrcl/base/TorqueUnitEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.TorqueUnitEnumType has no method named values with signature ()[Lcrcl/base/TorqueUnitEnumType;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallStaticObjectMethod( cls, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   TorqueUnitEnumType TorqueUnitEnumType::valueOf(jstring string_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getTorqueUnitEnumTypeClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "valueOf", "(Ljava/lang/String;)Lcrcl/base/TorqueUnitEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.TorqueUnitEnumType has no method named valueOf with signature (Ljava/lang/String;)Lcrcl/base/TorqueUnitEnumType;." << std::endl;
           TorqueUnitEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,string_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    TorqueUnitEnumType retObject(retVal,false);
    return retObject;
   }
   static jclass getNewTorqueUnitEnumTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/TorqueUnitEnumType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/TorqueUnitEnumType" << std::endl;
       }
       return clss;
   }
   
   static jclass TorqueUnitEnumTypeClass = NULL;
   static inline jclass getTorqueUnitEnumTypeClass() {
       if (TorqueUnitEnumTypeClass != NULL) {
           return TorqueUnitEnumTypeClass;
       }
       TorqueUnitEnumTypeClass = getNewTorqueUnitEnumTypeClass();
   }
   
   // get JNI handle for class crcl.base.TransSpeedType
   static inline jclass getTransSpeedTypeClass();
   
   TransSpeedType::TransSpeedType(jobject _jthis, bool copy): DataThingType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   TransSpeedType::TransSpeedType(const TransSpeedType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   TransSpeedType::TransSpeedType() {
    JNIEnv *env =getEnv();
    static jclass cls = getTransSpeedTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class TransSpeedType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new TransSpeedType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.TransSpeedType
   TransSpeedType::~TransSpeedType() {
   	// Place-holder for later extensibility.
   }

   static jclass getNewTransSpeedTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/TransSpeedType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/TransSpeedType" << std::endl;
       }
       return clss;
   }
   
   static jclass TransSpeedTypeClass = NULL;
   static inline jclass getTransSpeedTypeClass() {
       if (TransSpeedTypeClass != NULL) {
           return TransSpeedTypeClass;
       }
       TransSpeedTypeClass = getNewTransSpeedTypeClass();
   }
   
   // get JNI handle for class crcl.base.TransSpeedRelativeType
   static inline jclass getTransSpeedRelativeTypeClass();
   
   TransSpeedRelativeType::TransSpeedRelativeType(jobject _jthis, bool copy): TransSpeedType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   TransSpeedRelativeType::TransSpeedRelativeType(const TransSpeedRelativeType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   TransSpeedRelativeType::TransSpeedRelativeType() {
    JNIEnv *env =getEnv();
    static jclass cls = getTransSpeedRelativeTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class TransSpeedRelativeType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new TransSpeedRelativeType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.TransSpeedRelativeType
   TransSpeedRelativeType::~TransSpeedRelativeType() {
   	// Place-holder for later extensibility.
   }

   void TransSpeedRelativeType::setFraction(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setFraction of crcl.base.TransSpeedRelativeType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," TransSpeedRelativeType::setFraction jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setFraction", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.TransSpeedRelativeType has no method named setFraction with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::math::BigDecimal TransSpeedRelativeType::getFraction() {

   if(jthis == NULL) {
       std::cerr << "Call of method getFraction of crcl.base.TransSpeedRelativeType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," TransSpeedRelativeType::getFraction jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getFraction", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.TransSpeedRelativeType has no method named getFraction with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   static jclass getNewTransSpeedRelativeTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/TransSpeedRelativeType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/TransSpeedRelativeType" << std::endl;
       }
       return clss;
   }
   
   static jclass TransSpeedRelativeTypeClass = NULL;
   static inline jclass getTransSpeedRelativeTypeClass() {
       if (TransSpeedRelativeTypeClass != NULL) {
           return TransSpeedRelativeTypeClass;
       }
       TransSpeedRelativeTypeClass = getNewTransSpeedRelativeTypeClass();
   }
   
   // get JNI handle for class crcl.base.RunProgramType
   static inline jclass getRunProgramTypeClass();
   
   RunProgramType::RunProgramType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   RunProgramType::RunProgramType(const RunProgramType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   RunProgramType::RunProgramType() {
    JNIEnv *env =getEnv();
    static jclass cls = getRunProgramTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class RunProgramType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new RunProgramType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.RunProgramType
   RunProgramType::~RunProgramType() {
   	// Place-holder for later extensibility.
   }

   jstring RunProgramType::getProgramText() {

   if(jthis == NULL) {
       std::cerr << "Call of method getProgramText of crcl.base.RunProgramType with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," RunProgramType::getProgramText jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getProgramText", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.RunProgramType has no method named getProgramText with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void RunProgramType::setProgramText(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setProgramText of crcl.base.RunProgramType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," RunProgramType::setProgramText jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setProgramText", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.RunProgramType has no method named setProgramText with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewRunProgramTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/RunProgramType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/RunProgramType" << std::endl;
       }
       return clss;
   }
   
   static jclass RunProgramTypeClass = NULL;
   static inline jclass getRunProgramTypeClass() {
       if (RunProgramTypeClass != NULL) {
           return RunProgramTypeClass;
       }
       RunProgramTypeClass = getNewRunProgramTypeClass();
   }
  } // end namespace base

   namespace utils{
   
   // get JNI handle for class crcl.utils.PerfTest
   static inline jclass getPerfTestClass();
   
   PerfTest::PerfTest(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   PerfTest::PerfTest(const PerfTest &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   PerfTest::PerfTest() {
    JNIEnv *env =getEnv();
    static jclass cls = getPerfTestClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class PerfTest has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PerfTest jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.PerfTest
   PerfTest::~PerfTest() {
   	// Place-holder for later extensibility.
   }

   void PerfTest::runPerfTest(jboolean boolean_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getPerfTestClass();
   
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "runPerfTest", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PerfTest has no method named runPerfTest with signature (Z)V." << std::endl;
           
       } else {
            env->CallStaticVoidMethod( cls, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PerfTest::main(jobjectArray stringArray_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getPerfTestClass();
   
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "main", "([Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PerfTest has no method named main with signature ([Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallStaticVoidMethod( cls, mid ,stringArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PerfTest::main(int argc, const char **argv) {
           if(argc <1 || argv==NULL) {
                main(NULL);
           } else {
               JNIEnv *env =getEnv();
               jclass strClss = getStringClass();
               jobjectArray stringArray = env->NewObjectArray(argc,strClss,getEmptyString());
               for(int i = 0; i < argc; i++) {
                   jstring str = env->NewStringUTF(argv[i]);
                   env->SetObjectArrayElement(stringArray,i,str);
               }
                main(stringArray);
               for(int i = 0; i < argc; i++) {
                   jobject str = env->GetObjectArrayElement(stringArray,i);
                   jobjectRefType ref = env->GetObjectRefType(str);
                   if(ref == JNIGlobalRefType) {
                       env->DeleteGlobalRef(str);
                   }
               }
               jobjectRefType ref = env->GetObjectRefType(stringArray);
               if(ref == JNIGlobalRefType) {
                   env->DeleteGlobalRef(stringArray);
               }
               return ;
           }
   }
   static jclass getNewPerfTestClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/PerfTest");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/PerfTest" << std::endl;
       }
       return clss;
   }
   
   static jclass PerfTestClass = NULL;
   static inline jclass getPerfTestClass() {
       if (PerfTestClass != NULL) {
           return PerfTestClass;
       }
       PerfTestClass = getNewPerfTestClass();
   }
  } // end namespace utils

   namespace base{
   
   // get JNI handle for class crcl.base.RotSpeedType
   static inline jclass getRotSpeedTypeClass();
   
   RotSpeedType::RotSpeedType(jobject _jthis, bool copy): DataThingType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   RotSpeedType::RotSpeedType(const RotSpeedType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   RotSpeedType::RotSpeedType() {
    JNIEnv *env =getEnv();
    static jclass cls = getRotSpeedTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class RotSpeedType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new RotSpeedType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.RotSpeedType
   RotSpeedType::~RotSpeedType() {
   	// Place-holder for later extensibility.
   }

   static jclass getNewRotSpeedTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/RotSpeedType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/RotSpeedType" << std::endl;
       }
       return clss;
   }
   
   static jclass RotSpeedTypeClass = NULL;
   static inline jclass getRotSpeedTypeClass() {
       if (RotSpeedTypeClass != NULL) {
           return RotSpeedTypeClass;
       }
       RotSpeedTypeClass = getNewRotSpeedTypeClass();
   }
   
   // get JNI handle for class crcl.base.GripperStatusType
   static inline jclass getGripperStatusTypeClass();
   
   GripperStatusType::GripperStatusType(jobject _jthis, bool copy): DataThingType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   GripperStatusType::GripperStatusType(const GripperStatusType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   GripperStatusType::GripperStatusType() {
    JNIEnv *env =getEnv();
    static jclass cls = getGripperStatusTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class GripperStatusType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new GripperStatusType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.GripperStatusType
   GripperStatusType::~GripperStatusType() {
   	// Place-holder for later extensibility.
   }

   jstring GripperStatusType::getGripperName() {

   if(jthis == NULL) {
       std::cerr << "Call of method getGripperName of crcl.base.GripperStatusType with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," GripperStatusType::getGripperName jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getGripperName", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.GripperStatusType has no method named getGripperName with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void GripperStatusType::setGripperName(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setGripperName of crcl.base.GripperStatusType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," GripperStatusType::setGripperName jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setGripperName", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.GripperStatusType has no method named setGripperName with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewGripperStatusTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/GripperStatusType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/GripperStatusType" << std::endl;
       }
       return clss;
   }
   
   static jclass GripperStatusTypeClass = NULL;
   static inline jclass getGripperStatusTypeClass() {
       if (GripperStatusTypeClass != NULL) {
           return GripperStatusTypeClass;
       }
       GripperStatusTypeClass = getNewGripperStatusTypeClass();
   }
   
   // get JNI handle for class crcl.base.SetTransSpeedType
   static inline jclass getSetTransSpeedTypeClass();
   
   SetTransSpeedType::SetTransSpeedType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SetTransSpeedType::SetTransSpeedType(const SetTransSpeedType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SetTransSpeedType::SetTransSpeedType() {
    JNIEnv *env =getEnv();
    static jclass cls = getSetTransSpeedTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class SetTransSpeedType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SetTransSpeedType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.SetTransSpeedType
   SetTransSpeedType::~SetTransSpeedType() {
   	// Place-holder for later extensibility.
   }

   TransSpeedType SetTransSpeedType::getTransSpeed() {

   if(jthis == NULL) {
       std::cerr << "Call of method getTransSpeed of crcl.base.SetTransSpeedType with jthis == NULL." << std::endl;
       TransSpeedType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetTransSpeedType::getTransSpeed jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getTransSpeed", "()Lcrcl/base/TransSpeedType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetTransSpeedType has no method named getTransSpeed with signature ()Lcrcl/base/TransSpeedType;." << std::endl;
           TransSpeedType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    TransSpeedType retObject(retVal,false);
    return retObject;
   }
   void SetTransSpeedType::setTransSpeed(TransSpeedType  &transSpeedType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setTransSpeed of crcl.base.SetTransSpeedType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetTransSpeedType::setTransSpeed jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setTransSpeed", "(Lcrcl/base/TransSpeedType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetTransSpeedType has no method named setTransSpeed with signature (Lcrcl/base/TransSpeedType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,transSpeedType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewSetTransSpeedTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/SetTransSpeedType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/SetTransSpeedType" << std::endl;
       }
       return clss;
   }
   
   static jclass SetTransSpeedTypeClass = NULL;
   static inline jclass getSetTransSpeedTypeClass() {
       if (SetTransSpeedTypeClass != NULL) {
           return SetTransSpeedTypeClass;
       }
       SetTransSpeedTypeClass = getNewSetTransSpeedTypeClass();
   }
   
   // get JNI handle for class crcl.base.SetForceUnitsType
   static inline jclass getSetForceUnitsTypeClass();
   
   SetForceUnitsType::SetForceUnitsType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SetForceUnitsType::SetForceUnitsType(const SetForceUnitsType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SetForceUnitsType::SetForceUnitsType() {
    JNIEnv *env =getEnv();
    static jclass cls = getSetForceUnitsTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class SetForceUnitsType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SetForceUnitsType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.SetForceUnitsType
   SetForceUnitsType::~SetForceUnitsType() {
   	// Place-holder for later extensibility.
   }

   ForceUnitEnumType SetForceUnitsType::getUnitName() {

   if(jthis == NULL) {
       std::cerr << "Call of method getUnitName of crcl.base.SetForceUnitsType with jthis == NULL." << std::endl;
       ForceUnitEnumType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetForceUnitsType::getUnitName jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getUnitName", "()Lcrcl/base/ForceUnitEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetForceUnitsType has no method named getUnitName with signature ()Lcrcl/base/ForceUnitEnumType;." << std::endl;
           ForceUnitEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ForceUnitEnumType retObject(retVal,false);
    return retObject;
   }
   void SetForceUnitsType::setUnitName(ForceUnitEnumType  &forceUnitEnumType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setUnitName of crcl.base.SetForceUnitsType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetForceUnitsType::setUnitName jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setUnitName", "(Lcrcl/base/ForceUnitEnumType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetForceUnitsType has no method named setUnitName with signature (Lcrcl/base/ForceUnitEnumType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,forceUnitEnumType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewSetForceUnitsTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/SetForceUnitsType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/SetForceUnitsType" << std::endl;
       }
       return clss;
   }
   
   static jclass SetForceUnitsTypeClass = NULL;
   static inline jclass getSetForceUnitsTypeClass() {
       if (SetForceUnitsTypeClass != NULL) {
           return SetForceUnitsTypeClass;
       }
       SetForceUnitsTypeClass = getNewSetForceUnitsTypeClass();
   }
   
   // get JNI handle for class crcl.base.RotAccelRelativeType
   static inline jclass getRotAccelRelativeTypeClass();
   
   RotAccelRelativeType::RotAccelRelativeType(jobject _jthis, bool copy): RotAccelType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   RotAccelRelativeType::RotAccelRelativeType(const RotAccelRelativeType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   RotAccelRelativeType::RotAccelRelativeType() {
    JNIEnv *env =getEnv();
    static jclass cls = getRotAccelRelativeTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class RotAccelRelativeType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new RotAccelRelativeType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.RotAccelRelativeType
   RotAccelRelativeType::~RotAccelRelativeType() {
   	// Place-holder for later extensibility.
   }

   void RotAccelRelativeType::setFraction(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setFraction of crcl.base.RotAccelRelativeType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," RotAccelRelativeType::setFraction jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setFraction", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.RotAccelRelativeType has no method named setFraction with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::math::BigDecimal RotAccelRelativeType::getFraction() {

   if(jthis == NULL) {
       std::cerr << "Call of method getFraction of crcl.base.RotAccelRelativeType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," RotAccelRelativeType::getFraction jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getFraction", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.RotAccelRelativeType has no method named getFraction with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   static jclass getNewRotAccelRelativeTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/RotAccelRelativeType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/RotAccelRelativeType" << std::endl;
       }
       return clss;
   }
   
   static jclass RotAccelRelativeTypeClass = NULL;
   static inline jclass getRotAccelRelativeTypeClass() {
       if (RotAccelRelativeTypeClass != NULL) {
           return RotAccelRelativeTypeClass;
       }
       RotAccelRelativeTypeClass = getNewRotAccelRelativeTypeClass();
   }
  } // end namespace base

   namespace utils{
   
   // get JNI handle for class crcl.utils.SimServerOuterStub
   static inline jclass getSimServerOuterStubClass();
   
   SimServerOuterStub::SimServerOuterStub(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SimServerOuterStub::SimServerOuterStub(const SimServerOuterStub &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SimServerOuterStub::SimServerOuterStub() {
    JNIEnv *env =getEnv();
    static jclass cls = getSimServerOuterStubClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class SimServerOuterStub has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SimServerOuterStub jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   SimServerOuterStub::SimServerOuterStub(jboolean boolean_0,jboolean boolean_1,jboolean boolean_2,jboolean boolean_3,jboolean boolean_4,jboolean boolean_5,jboolean boolean_6,jboolean boolean_7,jboolean boolean_8,jboolean boolean_9) {
    JNIEnv *env =getEnv();
    static jclass cls = getSimServerOuterStubClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(ZZZZZZZZZZ)V");
        if (NULL == mid) {
            std::cerr << "Class SimServerOuterStub has no method constructor signature (ZZZZZZZZZZ)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,boolean_0,boolean_1,boolean_2,boolean_3,boolean_4,boolean_5,boolean_6,boolean_7,boolean_8,boolean_9);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SimServerOuterStub jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.SimServerOuterStub
   SimServerOuterStub::~SimServerOuterStub() {
   	// Place-holder for later extensibility.
   }

   void SimServerOuterStub::showMessage(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method showMessage of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::showMessage jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "showMessage", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named showMessage with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimServerOuterStub::showDebugMessage(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method showDebugMessage of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::showDebugMessage jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "showDebugMessage", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named showDebugMessage with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean SimServerOuterStub::isEXISelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isEXISelected of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::isEXISelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isEXISelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named isEXISelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean SimServerOuterStub::isSendStatusWithoutRequestSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isSendStatusWithoutRequestSelected of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::isSendStatusWithoutRequestSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isSendStatusWithoutRequestSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named isSendStatusWithoutRequestSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServerOuterStub::updateConnectedClients(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method updateConnectedClients of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::updateConnectedClients jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updateConnectedClients", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named updateConnectedClients with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean SimServerOuterStub::isValidateXMLSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isValidateXMLSelected of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::isValidateXMLSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isValidateXMLSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named isValidateXMLSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean SimServerOuterStub::isAppendZeroSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isAppendZeroSelected of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::isAppendZeroSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isAppendZeroSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named isAppendZeroSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean SimServerOuterStub::isRandomPacketSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isRandomPacketSelected of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::isRandomPacketSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isRandomPacketSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named isRandomPacketSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean SimServerOuterStub::isReplaceStateSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isReplaceStateSelected of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::isReplaceStateSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isReplaceStateSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named isReplaceStateSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean SimServerOuterStub::isEditingStatus() {

   if(jthis == NULL) {
       std::cerr << "Call of method isEditingStatus of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::isEditingStatus jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isEditingStatus", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named isEditingStatus with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServerOuterStub::updateCycleCount(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method updateCycleCount of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::updateCycleCount jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updateCycleCount", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named updateCycleCount with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimServerOuterStub::updatePanels(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method updatePanels of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::updatePanels jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updatePanels", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named updatePanels with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimServerOuterStub::updateIsInitialized(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method updateIsInitialized of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::updateIsInitialized jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updateIsInitialized", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named updateIsInitialized with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimServerOuterStub::updateCurrentCommandType(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method updateCurrentCommandType of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::updateCurrentCommandType jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updateCurrentCommandType", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named updateCurrentCommandType with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimServerOuterStub::updateEndEffector(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method updateEndEffector of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::updateEndEffector jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updateEndEffector", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named updateEndEffector with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimServerOuterStub::updateToolChangerIsOpen(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method updateToolChangerIsOpen of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::updateToolChangerIsOpen jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updateToolChangerIsOpen", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named updateToolChangerIsOpen with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean SimServerOuterStub::isInitializedSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isInitializedSelected of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::isInitializedSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isInitializedSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named isInitializedSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServerOuterStub::finishSetCurrentWaypoint(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method finishSetCurrentWaypoint of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::finishSetCurrentWaypoint jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "finishSetCurrentWaypoint", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named finishSetCurrentWaypoint with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimServerOuterStub::updateLengthUnit(::crclj::crcl::base::LengthUnitEnumType  &lengthUnitEnumType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method updateLengthUnit of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::updateLengthUnit jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updateLengthUnit", "(Lcrcl/base/LengthUnitEnumType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named updateLengthUnit with signature (Lcrcl/base/LengthUnitEnumType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,lengthUnitEnumType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void SimServerOuterStub::updateNumWaypoints(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method updateNumWaypoints of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::updateNumWaypoints jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updateNumWaypoints", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named updateNumWaypoints with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean SimServerOuterStub::isDebugMoveDoneSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isDebugMoveDoneSelected of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::isDebugMoveDoneSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isDebugMoveDoneSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named isDebugMoveDoneSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean SimServerOuterStub::isDebugSendStatusSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isDebugSendStatusSelected of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::isDebugSendStatusSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isDebugSendStatusSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named isDebugSendStatusSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean SimServerOuterStub::isDebugReadCommandSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isDebugReadCommandSelected of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::isDebugReadCommandSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isDebugReadCommandSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named isDebugReadCommandSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean SimServerOuterStub::isReplaceXmlHeaderSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isReplaceXmlHeaderSelected of crcl.utils.SimServerOuterStub with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerOuterStub::isReplaceXmlHeaderSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isReplaceXmlHeaderSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerOuterStub has no method named isReplaceXmlHeaderSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewSimServerOuterStubClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/SimServerOuterStub");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/SimServerOuterStub" << std::endl;
       }
       return clss;
   }
   
   static jclass SimServerOuterStubClass = NULL;
   static inline jclass getSimServerOuterStubClass() {
       if (SimServerOuterStubClass != NULL) {
           return SimServerOuterStubClass;
       }
       SimServerOuterStubClass = getNewSimServerOuterStubClass();
   }
   
   // get JNI handle for class crcl.utils.SimServerOuter
   static inline jclass getSimServerOuterClass();
   
   SimServerOuter::SimServerOuter(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SimServerOuter::SimServerOuter(const SimServerOuter &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SimServerOuter::SimServerOuter() {
   JNIEnv *env =getEnv();
   static jclass cls = getSimServerOuterClass();
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
       if (NULL == mid) {
           std::cerr << "Class SimServerOuter has no method constructor signature ()V" << std::endl;
       } else {
           jthis = env->NewObject(cls, mid );
           jobjectRefType ref = env->GetObjectRefType(jthis);
           if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SimServerOuter jthis=",jthis);
           if(ref != JNIGlobalRefType) {
               jthis = env->NewGlobalRef(jthis);
           }
       }
   }
   releaseEnv(env);
   }


   // Destructor for crcl.utils.SimServerOuter
   SimServerOuter::~SimServerOuter() {
   	// Place-holder for later extensibility.
   }

   static jclass getNewSimServerOuterClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/SimServerOuter");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/SimServerOuter" << std::endl;
       }
       return clss;
   }
   
   static jclass SimServerOuterClass = NULL;
   static inline jclass getSimServerOuterClass() {
       if (SimServerOuterClass != NULL) {
           return SimServerOuterClass;
       }
       SimServerOuterClass = getNewSimServerOuterClass();
   }
   
   // get JNI handle for class crcl.utils.SimServerInner
   static inline jclass getSimServerInnerClass();
   
   SimServerInner::SimServerInner(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SimServerInner::SimServerInner(const SimServerInner &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SimServerInner::SimServerInner(SimServerOuter  &simServerOuter_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getSimServerInnerClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Lcrcl/utils/SimServerOuter;)V");
        if (NULL == mid) {
            std::cerr << "Class SimServerInner has no method constructor signature (Lcrcl/utils/SimServerOuter;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,simServerOuter_0.jthis);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SimServerInner jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.SimServerInner
   SimServerInner::~SimServerInner() {
   	// Place-holder for later extensibility.
   }

   ::crclj::crcl::base::CRCLStatusType SimServerInner::getStatus() {

   if(jthis == NULL) {
       std::cerr << "Call of method getStatus of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       ::crclj::crcl::base::CRCLStatusType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getStatus jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getStatus", "()Lcrcl/base/CRCLStatusType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getStatus with signature ()Lcrcl/base/CRCLStatusType;." << std::endl;
           ::crclj::crcl::base::CRCLStatusType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::CRCLStatusType retObject(retVal,false);
    return retObject;
   }
   void SimServerInner::setCmdSchema(jobjectArray fileArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCmdSchema of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setCmdSchema jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCmdSchema", "([Ljava/io/File;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setCmdSchema with signature ([Ljava/io/File;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,fileArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimServerInner::setStatSchema(jobjectArray fileArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setStatSchema of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setStatSchema jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setStatSchema", "([Ljava/io/File;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setStatSchema with signature ([Ljava/io/File;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,fileArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   SimRobotEnum SimServerInner::getRobotType() {

   if(jthis == NULL) {
       std::cerr << "Call of method getRobotType of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       SimRobotEnum nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getRobotType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getRobotType", "()Lcrcl/utils/SimRobotEnum;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getRobotType with signature ()Lcrcl/utils/SimRobotEnum;." << std::endl;
           SimRobotEnum nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    SimRobotEnum retObject(retVal,false);
    return retObject;
   }
   void SimServerInner::setRobotType(SimRobotEnum  &simRobotEnum_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setRobotType of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setRobotType jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setRobotType", "(Lcrcl/utils/SimRobotEnum;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setRobotType with signature (Lcrcl/utils/SimRobotEnum;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,simRobotEnum_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::crcl::base::CommandStateEnumType SimServerInner::getCommandState() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCommandState of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       ::crclj::crcl::base::CommandStateEnumType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getCommandState jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCommandState", "()Lcrcl/base/CommandStateEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getCommandState with signature ()Lcrcl/base/CommandStateEnumType;." << std::endl;
           ::crclj::crcl::base::CommandStateEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::CommandStateEnumType retObject(retVal,false);
    return retObject;
   }
   void SimServerInner::setCommandState(::crclj::crcl::base::CommandStateEnumType  &commandStateEnumType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCommandState of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setCommandState jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCommandState", "(Lcrcl/base/CommandStateEnumType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setCommandState with signature (Lcrcl/base/CommandStateEnumType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,commandStateEnumType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   jboolean SimServerInner::isMoveStraight() {

   if(jthis == NULL) {
       std::cerr << "Call of method isMoveStraight of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::isMoveStraight jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isMoveStraight", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named isMoveStraight with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServerInner::setMoveStraight(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setMoveStraight of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setMoveStraight jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setMoveStraight", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setMoveStraight with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimServerInner::setJointPosition(jdouble double_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method setJointPosition of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setJointPosition jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setJointPosition", "(DI)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setJointPosition with signature (DI)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0,int_1 );
       }
   }
   releaseEnv(env);
   
   }
   jdoubleArray SimServerInner::getSeglengths() {

   if(jthis == NULL) {
       std::cerr << "Call of method getSeglengths of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getSeglengths jthis=",jthis);
   jdoubleArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getSeglengths", "()[D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getSeglengths with signature ()[D." << std::endl;
           return NULL;
       } else {
           retVal= (jdoubleArray)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServerInner::setPort(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setPort of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setPort jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setPort", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setPort with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   jlong SimServerInner::getDelayMillis() {

   if(jthis == NULL) {
       std::cerr << "Call of method getDelayMillis of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       return (jlong) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getDelayMillis jthis=",jthis);
   jlong retVal= (jlong) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getDelayMillis", "()J");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getDelayMillis with signature ()J." << std::endl;
           return (jlong) -1;
       } else {
           retVal= (jlong)  env->CallLongMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServerInner::setDelayMillis(jlong long_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setDelayMillis of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setDelayMillis jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setDelayMillis", "(J)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setDelayMillis with signature (J)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,long_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimServerInner::restartServer() {

   if(jthis == NULL) {
       std::cerr << "Call of method restartServer of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::restartServer jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "restartServer", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named restartServer with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void SimServerInner::updateConnectedClients() {

   if(jthis == NULL) {
       std::cerr << "Call of method updateConnectedClients of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::updateConnectedClients jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updateConnectedClients", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named updateConnectedClients with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   XpathUtils SimServerInner::getXpu() {

   if(jthis == NULL) {
       std::cerr << "Call of method getXpu of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       XpathUtils nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getXpu jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getXpu", "()Lcrcl/utils/XpathUtils;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getXpu with signature ()Lcrcl/utils/XpathUtils;." << std::endl;
           XpathUtils nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    XpathUtils retObject(retVal,false);
    return retObject;
   }
   void SimServerInner::simulatedTeleportToPose(::crclj::crcl::base::PoseType  &poseType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method simulatedTeleportToPose of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::simulatedTeleportToPose jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "simulatedTeleportToPose", "(Lcrcl/base/PoseType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named simulatedTeleportToPose with signature (Lcrcl/base/PoseType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,poseType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void SimServerInner::setCommandedJointPosition(jdouble double_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCommandedJointPosition of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setCommandedJointPosition jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCommandedJointPosition", "(DI)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setCommandedJointPosition with signature (DI)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0,int_1 );
       }
   }
   releaseEnv(env);
   
   }
   jdoubleArray SimServerInner::getJointPositions() {

   if(jthis == NULL) {
       std::cerr << "Call of method getJointPositions of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getJointPositions jthis=",jthis);
   jdoubleArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getJointPositions", "()[D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getJointPositions with signature ()[D." << std::endl;
           return NULL;
       } else {
           retVal= (jdoubleArray)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServerInner::setGoalPose(::crclj::crcl::base::PoseType  &poseType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setGoalPose of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setGoalPose jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setGoalPose", "(Lcrcl/base/PoseType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setGoalPose with signature (Lcrcl/base/PoseType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,poseType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   jboolean SimServerInner::isFinishedMove() {

   if(jthis == NULL) {
       std::cerr << "Call of method isFinishedMove of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::isFinishedMove jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isFinishedMove", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named isFinishedMove with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean SimServerInner::checkPose(::crclj::crcl::base::PoseType  &poseType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method checkPose of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::checkPose jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "checkPose", "(Lcrcl/base/PoseType;)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named checkPose with signature (Lcrcl/base/PoseType;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,poseType_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jdouble SimServerInner::getJointSpeedMax() {

   if(jthis == NULL) {
       std::cerr << "Call of method getJointSpeedMax of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getJointSpeedMax jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getJointSpeedMax", "()D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getJointSpeedMax with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServerInner::setJointSpeedMax(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setJointSpeedMax of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setJointSpeedMax jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setJointSpeedMax", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setJointSpeedMax with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::crcl::base::PoseType SimServerInner::limitSpeedAccel(::crclj::crcl::base::PoseType  &poseType_0,::crclj::crcl::base::PoseType  &poseType_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method limitSpeedAccel of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       ::crclj::crcl::base::PoseType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::limitSpeedAccel jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "limitSpeedAccel", "(Lcrcl/base/PoseType;Lcrcl/base/PoseType;)Lcrcl/base/PoseType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named limitSpeedAccel with signature (Lcrcl/base/PoseType;Lcrcl/base/PoseType;)Lcrcl/base/PoseType;." << std::endl;
           ::crclj::crcl::base::PoseType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,poseType_0.jthis,poseType_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PoseType retObject(retVal,false);
    return retObject;
   }
   jdoubleArray SimServerInner::getStraightMoveCommandedJointVals(::crclj::crcl::base::PoseType  &poseType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method getStraightMoveCommandedJointVals of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getStraightMoveCommandedJointVals jthis=",jthis);
   jdoubleArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getStraightMoveCommandedJointVals", "(Lcrcl/base/PoseType;)[D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getStraightMoveCommandedJointVals with signature (Lcrcl/base/PoseType;)[D." << std::endl;
           return NULL;
       } else {
           retVal= (jdoubleArray)  env->CallObjectMethod(jthis, mid ,poseType_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServerInner::setStatus(::crclj::crcl::base::CRCLStatusType  &cRCLStatusType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setStatus of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setStatus jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setStatus", "(Lcrcl/base/CRCLStatusType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setStatus with signature (Lcrcl/base/CRCLStatusType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,cRCLStatusType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void SimServerInner::closeServer() {

   if(jthis == NULL) {
       std::cerr << "Call of method closeServer of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::closeServer jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "closeServer", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named closeServer with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::javax::xml::datatype::XMLGregorianCalendar SimServerInner::getXMLGregorianCalendarNow() {

   if(jthis == NULL) {
       std::cerr << "Call of method getXMLGregorianCalendarNow of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       ::crclj::javax::xml::datatype::XMLGregorianCalendar nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getXMLGregorianCalendarNow jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getXMLGregorianCalendarNow", "()Ljavax/xml/datatype/XMLGregorianCalendar;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getXMLGregorianCalendarNow with signature ()Ljavax/xml/datatype/XMLGregorianCalendar;." << std::endl;
           ::crclj::javax::xml::datatype::XMLGregorianCalendar nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::javax::xml::datatype::XMLGregorianCalendar retObject(retVal,false);
    return retObject;
   }
   void SimServerInner::goalPoseToCommandedPositions(::crclj::crcl::base::PoseType  &poseType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method goalPoseToCommandedPositions of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::goalPoseToCommandedPositions jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "goalPoseToCommandedPositions", "(Lcrcl/base/PoseType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named goalPoseToCommandedPositions with signature (Lcrcl/base/PoseType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,poseType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   jint SimServerInner::getCurrentWaypoint() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCurrentWaypoint of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getCurrentWaypoint jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCurrentWaypoint", "()I");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getCurrentWaypoint with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServerInner::setCurrentWaypoint(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCurrentWaypoint of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setCurrentWaypoint jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCurrentWaypoint", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setCurrentWaypoint with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimServerInner::printClientStates(::crclj::java::io::PrintStream  &printStream_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method printClientStates of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::printClientStates jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "printClientStates", "(Ljava/io/PrintStream;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named printClientStates with signature (Ljava/io/PrintStream;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,printStream_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void SimServerInner::printAllClientStates(::crclj::java::io::PrintStream  &printStream_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getSimServerInnerClass();
   
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "printAllClientStates", "(Ljava/io/PrintStream;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named printAllClientStates with signature (Ljava/io/PrintStream;)V." << std::endl;
           
       } else {
            env->CallStaticVoidMethod( cls, mid ,printStream_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void SimServerInner::runAcceptClients() {

   if(jthis == NULL) {
       std::cerr << "Call of method runAcceptClients of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::runAcceptClients jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "runAcceptClients", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named runAcceptClients with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jdouble SimServerInner::getCurTransSpeed() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCurTransSpeed of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getCurTransSpeed jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCurTransSpeed", "()D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getCurTransSpeed with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServerInner::setCurTransSpeed(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCurTransSpeed of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setCurTransSpeed jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCurTransSpeed", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setCurTransSpeed with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   jdouble SimServerInner::getCommandedTransSpeed() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCommandedTransSpeed of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getCommandedTransSpeed jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCommandedTransSpeed", "()D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getCommandedTransSpeed with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServerInner::setCommandedTransSpeed(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCommandedTransSpeed of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setCommandedTransSpeed jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCommandedTransSpeed", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setCommandedTransSpeed with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   jdouble SimServerInner::getCurTransAccel() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCurTransAccel of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getCurTransAccel jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCurTransAccel", "()D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getCurTransAccel with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServerInner::setCurTransAccel(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCurTransAccel of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setCurTransAccel jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCurTransAccel", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setCurTransAccel with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   jdouble SimServerInner::getCommandedTransAccel() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCommandedTransAccel of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getCommandedTransAccel jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCommandedTransAccel", "()D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getCommandedTransAccel with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServerInner::setCommandedTransAccel(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCommandedTransAccel of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setCommandedTransAccel jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCommandedTransAccel", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setCommandedTransAccel with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   jdouble SimServerInner::getCurRotSpeed() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCurRotSpeed of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getCurRotSpeed jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCurRotSpeed", "()D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getCurRotSpeed with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServerInner::setCurRotSpeed(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCurRotSpeed of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setCurRotSpeed jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCurRotSpeed", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setCurRotSpeed with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   jdouble SimServerInner::getCommandedRotSpeed() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCommandedRotSpeed of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getCommandedRotSpeed jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCommandedRotSpeed", "()D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getCommandedRotSpeed with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServerInner::setCommandedRotSpeed(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCommandedRotSpeed of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setCommandedRotSpeed jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCommandedRotSpeed", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setCommandedRotSpeed with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   jdouble SimServerInner::getCurRotAccel() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCurRotAccel of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getCurRotAccel jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCurRotAccel", "()D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getCurRotAccel with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServerInner::setCurRotAccel(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCurRotAccel of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setCurRotAccel jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCurRotAccel", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setCurRotAccel with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   jdouble SimServerInner::getCommandedRotAccel() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCommandedRotAccel of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getCommandedRotAccel jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCommandedRotAccel", "()D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getCommandedRotAccel with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServerInner::setCommandedRotAccel(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCommandedRotAccel of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setCommandedRotAccel jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCommandedRotAccel", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setCommandedRotAccel with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::crcl::base::AngleUnitEnumType SimServerInner::getAngleType() {

   if(jthis == NULL) {
       std::cerr << "Call of method getAngleType of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       ::crclj::crcl::base::AngleUnitEnumType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getAngleType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getAngleType", "()Lcrcl/base/AngleUnitEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getAngleType with signature ()Lcrcl/base/AngleUnitEnumType;." << std::endl;
           ::crclj::crcl::base::AngleUnitEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::AngleUnitEnumType retObject(retVal,false);
    return retObject;
   }
   void SimServerInner::setAngleType(::crclj::crcl::base::AngleUnitEnumType  &angleUnitEnumType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setAngleType of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setAngleType jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setAngleType", "(Lcrcl/base/AngleUnitEnumType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setAngleType with signature (Lcrcl/base/AngleUnitEnumType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,angleUnitEnumType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::crcl::base::PoseToleranceType SimServerInner::getExpectedEndPoseTolerance() {

   if(jthis == NULL) {
       std::cerr << "Call of method getExpectedEndPoseTolerance of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       ::crclj::crcl::base::PoseToleranceType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getExpectedEndPoseTolerance jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getExpectedEndPoseTolerance", "()Lcrcl/base/PoseToleranceType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getExpectedEndPoseTolerance with signature ()Lcrcl/base/PoseToleranceType;." << std::endl;
           ::crclj::crcl::base::PoseToleranceType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PoseToleranceType retObject(retVal,false);
    return retObject;
   }
   void SimServerInner::setExpectedEndPoseTolerance(::crclj::crcl::base::PoseToleranceType  &poseToleranceType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setExpectedEndPoseTolerance of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setExpectedEndPoseTolerance jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setExpectedEndPoseTolerance", "(Lcrcl/base/PoseToleranceType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setExpectedEndPoseTolerance with signature (Lcrcl/base/PoseToleranceType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,poseToleranceType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::crcl::base::PoseToleranceType SimServerInner::getExpectedIntermediatePoseTolerance() {

   if(jthis == NULL) {
       std::cerr << "Call of method getExpectedIntermediatePoseTolerance of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       ::crclj::crcl::base::PoseToleranceType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getExpectedIntermediatePoseTolerance jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getExpectedIntermediatePoseTolerance", "()Lcrcl/base/PoseToleranceType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getExpectedIntermediatePoseTolerance with signature ()Lcrcl/base/PoseToleranceType;." << std::endl;
           ::crclj::crcl::base::PoseToleranceType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PoseToleranceType retObject(retVal,false);
    return retObject;
   }
   void SimServerInner::setExpectedIntermediatePoseTolerance(::crclj::crcl::base::PoseToleranceType  &poseToleranceType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setExpectedIntermediatePoseTolerance of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setExpectedIntermediatePoseTolerance jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setExpectedIntermediatePoseTolerance", "(Lcrcl/base/PoseToleranceType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setExpectedIntermediatePoseTolerance with signature (Lcrcl/base/PoseToleranceType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,poseToleranceType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void SimServerInner::setLengthUnit(::crclj::crcl::base::LengthUnitEnumType  &lengthUnitEnumType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setLengthUnit of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setLengthUnit jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setLengthUnit", "(Lcrcl/base/LengthUnitEnumType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setLengthUnit with signature (Lcrcl/base/LengthUnitEnumType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,lengthUnitEnumType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::util::List SimServerInner::getWaypoints() {

   if(jthis == NULL) {
       std::cerr << "Call of method getWaypoints of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getWaypoints jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getWaypoints", "()Ljava/util/List;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getWaypoints with signature ()Ljava/util/List;." << std::endl;
           ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::util::List retObject(retVal,false);
    return retObject;
   }
   void SimServerInner::setWaypoints(::crclj::java::util::List  &list_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setWaypoints of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::setWaypoints jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setWaypoints", "(Ljava/util/List;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named setWaypoints with signature (Ljava/util/List;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,list_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   jstring SimServerInner::getStatusXmlString() {

   if(jthis == NULL) {
       std::cerr << "Call of method getStatusXmlString of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getStatusXmlString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getStatusXmlString", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getStatusXmlString with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   CRCLSocket SimServerInner::getCheckerCRCLSocket() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCheckerCRCLSocket of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       CRCLSocket nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getCheckerCRCLSocket jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCheckerCRCLSocket", "()Lcrcl/utils/CRCLSocket;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getCheckerCRCLSocket with signature ()Lcrcl/utils/CRCLSocket;." << std::endl;
           CRCLSocket nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    CRCLSocket retObject(retVal,false);
    return retObject;
   }
   void SimServerInner::reset() {

   if(jthis == NULL) {
       std::cerr << "Call of method reset of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::reset jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "reset", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named reset with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jint SimServerInner::getPort() {

   if(jthis == NULL) {
       std::cerr << "Call of method getPort of crcl.utils.SimServerInner with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServerInner::getPort jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getPort", "()I");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServerInner has no method named getPort with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewSimServerInnerClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/SimServerInner");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/SimServerInner" << std::endl;
       }
       return clss;
   }
   
   static jclass SimServerInnerClass = NULL;
   static inline jclass getSimServerInnerClass() {
       if (SimServerInnerClass != NULL) {
           return SimServerInnerClass;
       }
       SimServerInnerClass = getNewSimServerInnerClass();
   }
   
   // get JNI handle for class crcl.utils.MultiLineStringJPanel
   static inline jclass getMultiLineStringJPanelClass();
   
   MultiLineStringJPanel::MultiLineStringJPanel(jobject _jthis, bool copy): ::crclj::javax::swing::JPanel(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   MultiLineStringJPanel::MultiLineStringJPanel(const MultiLineStringJPanel &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   MultiLineStringJPanel::MultiLineStringJPanel() {
    JNIEnv *env =getEnv();
    static jclass cls = getMultiLineStringJPanelClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class MultiLineStringJPanel has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new MultiLineStringJPanel jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.MultiLineStringJPanel
   MultiLineStringJPanel::~MultiLineStringJPanel() {
   	// Place-holder for later extensibility.
   }

   jstring MultiLineStringJPanel::editText(jstring string_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getMultiLineStringJPanelClass();
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "editText", "(Ljava/lang/String;)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.MultiLineStringJPanel has no method named editText with signature (Ljava/lang/String;)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallStaticObjectMethod( cls, mid ,string_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring MultiLineStringJPanel::editText(jstring string_0,::crclj::java::awt::Frame  &frame_1,jstring string_2,jboolean boolean_3) {

   JNIEnv *env =getEnv();
   static jclass cls = getMultiLineStringJPanelClass();
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "editText", "(Ljava/lang/String;Ljava/awt/Frame;Ljava/lang/String;Z)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.MultiLineStringJPanel has no method named editText with signature (Ljava/lang/String;Ljava/awt/Frame;Ljava/lang/String;Z)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallStaticObjectMethod( cls, mid ,string_0,frame_1.jthis,string_2,boolean_3 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean MultiLineStringJPanel::showText(jstring string_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getMultiLineStringJPanelClass();
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "showText", "(Ljava/lang/String;)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.MultiLineStringJPanel has no method named showText with signature (Ljava/lang/String;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallStaticBooleanMethod( cls, mid ,string_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean MultiLineStringJPanel::showText(jstring string_0,::crclj::java::awt::Frame  &frame_1,jstring string_2,jboolean boolean_3) {

   JNIEnv *env =getEnv();
   static jclass cls = getMultiLineStringJPanelClass();
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "showText", "(Ljava/lang/String;Ljava/awt/Frame;Ljava/lang/String;Z)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.MultiLineStringJPanel has no method named showText with signature (Ljava/lang/String;Ljava/awt/Frame;Ljava/lang/String;Z)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallStaticBooleanMethod( cls, mid ,string_0,frame_1.jthis,string_2,boolean_3 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewMultiLineStringJPanelClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/MultiLineStringJPanel");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/MultiLineStringJPanel" << std::endl;
       }
       return clss;
   }
   
   static jclass MultiLineStringJPanelClass = NULL;
   static inline jclass getMultiLineStringJPanelClass() {
       if (MultiLineStringJPanelClass != NULL) {
           return MultiLineStringJPanelClass;
       }
       MultiLineStringJPanelClass = getNewMultiLineStringJPanelClass();
   }
   
   // get JNI handle for class crcl.utils.ObjTableJPanel
   static inline jclass getObjTableJPanelClass();
   
   ObjTableJPanel::ObjTableJPanel(jobject _jthis, bool copy): ::crclj::javax::swing::JPanel(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   ObjTableJPanel::ObjTableJPanel(const ObjTableJPanel &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   ObjTableJPanel::ObjTableJPanel() {
    JNIEnv *env =getEnv();
    static jclass cls = getObjTableJPanelClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class ObjTableJPanel has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new ObjTableJPanel jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.ObjTableJPanel
   ObjTableJPanel::~ObjTableJPanel() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::lang::Object ObjTableJPanel::getObj() {

   if(jthis == NULL) {
       std::cerr << "Call of method getObj of crcl.utils.ObjTableJPanel with jthis == NULL." << std::endl;
       ::crclj::java::lang::Object nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjTableJPanel::getObj jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getObj", "()Ljava/lang/Object;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.ObjTableJPanel has no method named getObj with signature ()Ljava/lang/Object;." << std::endl;
           ::crclj::java::lang::Object nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::lang::Object retObject(retVal,false);
    return retObject;
   }
   void ObjTableJPanel::setObj(::crclj::java::lang::Object  &object_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setObj of crcl.utils.ObjTableJPanel with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ObjTableJPanel::setObj jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setObj", "(Ljava/lang/Object;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.ObjTableJPanel has no method named setObj with signature (Ljava/lang/Object;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,object_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::lang::Object ObjTableJPanel::editObject(::crclj::java::lang::Object  &object_0,XpathUtils  &xpathUtils_1,::crclj::java::util::function::Predicate  &predicate_2) {

   JNIEnv *env =getEnv();
   static jclass cls = getObjTableJPanelClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "editObject", "(Ljava/lang/Object;Lcrcl/utils/XpathUtils;Ljava/util/function/Predicate;)Ljava/lang/Object;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.ObjTableJPanel has no method named editObject with signature (Ljava/lang/Object;Lcrcl/utils/XpathUtils;Ljava/util/function/Predicate;)Ljava/lang/Object;." << std::endl;
           ::crclj::java::lang::Object nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,object_0.jthis,xpathUtils_1.jthis,predicate_2.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::lang::Object retObject(retVal,false);
    return retObject;
   }
   ::crclj::java::lang::Object ObjTableJPanel::editObject(::crclj::java::lang::Object  &object_0,::crclj::java::awt::Frame  &frame_1,jstring string_2,jboolean boolean_3,XpathUtils  &xpathUtils_4,::crclj::java::util::function::Predicate  &predicate_5) {

   JNIEnv *env =getEnv();
   static jclass cls = getObjTableJPanelClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "editObject", "(Ljava/lang/Object;Ljava/awt/Frame;Ljava/lang/String;ZLcrcl/utils/XpathUtils;Ljava/util/function/Predicate;)Ljava/lang/Object;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.ObjTableJPanel has no method named editObject with signature (Ljava/lang/Object;Ljava/awt/Frame;Ljava/lang/String;ZLcrcl/utils/XpathUtils;Ljava/util/function/Predicate;)Ljava/lang/Object;." << std::endl;
           ::crclj::java::lang::Object nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,object_0.jthis,frame_1.jthis,string_2,boolean_3,xpathUtils_4.jthis,predicate_5.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::lang::Object retObject(retVal,false);
    return retObject;
   }
   void ObjTableJPanel::main(jobjectArray stringArray_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getObjTableJPanelClass();
   
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "main", "([Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.ObjTableJPanel has no method named main with signature ([Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallStaticVoidMethod( cls, mid ,stringArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void ObjTableJPanel::main(int argc, const char **argv) {
           if(argc <1 || argv==NULL) {
                main(NULL);
           } else {
               JNIEnv *env =getEnv();
               jclass strClss = getStringClass();
               jobjectArray stringArray = env->NewObjectArray(argc,strClss,getEmptyString());
               for(int i = 0; i < argc; i++) {
                   jstring str = env->NewStringUTF(argv[i]);
                   env->SetObjectArrayElement(stringArray,i,str);
               }
                main(stringArray);
               for(int i = 0; i < argc; i++) {
                   jobject str = env->GetObjectArrayElement(stringArray,i);
                   jobjectRefType ref = env->GetObjectRefType(str);
                   if(ref == JNIGlobalRefType) {
                       env->DeleteGlobalRef(str);
                   }
               }
               jobjectRefType ref = env->GetObjectRefType(stringArray);
               if(ref == JNIGlobalRefType) {
                   env->DeleteGlobalRef(stringArray);
               }
               return ;
           }
   }
   ::crclj::java::util::List ObjTableJPanel::getClasses() {

   JNIEnv *env =getEnv();
   static jclass cls = getObjTableJPanelClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "getClasses", "()Ljava/util/List;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.ObjTableJPanel has no method named getClasses with signature ()Ljava/util/List;." << std::endl;
           ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::util::List retObject(retVal,false);
    return retObject;
   }
   static jclass getNewObjTableJPanelClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/ObjTableJPanel");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/ObjTableJPanel" << std::endl;
       }
       return clss;
   }
   
   static jclass ObjTableJPanelClass = NULL;
   static inline jclass getObjTableJPanelClass() {
       if (ObjTableJPanelClass != NULL) {
           return ObjTableJPanelClass;
       }
       ObjTableJPanelClass = getNewObjTableJPanelClass();
   }
  } // end namespace utils

   namespace base{
   
   // get JNI handle for class crcl.base.CRCLProgramType
   static inline jclass getCRCLProgramTypeClass();
   
   CRCLProgramType::CRCLProgramType(jobject _jthis, bool copy): DataThingType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   CRCLProgramType::CRCLProgramType(const CRCLProgramType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   CRCLProgramType::CRCLProgramType() {
    JNIEnv *env =getEnv();
    static jclass cls = getCRCLProgramTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class CRCLProgramType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new CRCLProgramType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.CRCLProgramType
   CRCLProgramType::~CRCLProgramType() {
   	// Place-holder for later extensibility.
   }

   InitCanonType CRCLProgramType::getInitCanon() {

   if(jthis == NULL) {
       std::cerr << "Call of method getInitCanon of crcl.base.CRCLProgramType with jthis == NULL." << std::endl;
       InitCanonType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLProgramType::getInitCanon jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getInitCanon", "()Lcrcl/base/InitCanonType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CRCLProgramType has no method named getInitCanon with signature ()Lcrcl/base/InitCanonType;." << std::endl;
           InitCanonType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    InitCanonType retObject(retVal,false);
    return retObject;
   }
   void CRCLProgramType::setInitCanon(InitCanonType  &initCanonType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setInitCanon of crcl.base.CRCLProgramType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLProgramType::setInitCanon jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setInitCanon", "(Lcrcl/base/InitCanonType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CRCLProgramType has no method named setInitCanon with signature (Lcrcl/base/InitCanonType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,initCanonType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::util::List CRCLProgramType::getMiddleCommand() {

   if(jthis == NULL) {
       std::cerr << "Call of method getMiddleCommand of crcl.base.CRCLProgramType with jthis == NULL." << std::endl;
       ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLProgramType::getMiddleCommand jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getMiddleCommand", "()Ljava/util/List;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CRCLProgramType has no method named getMiddleCommand with signature ()Ljava/util/List;." << std::endl;
           ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::util::List retObject(retVal,false);
    return retObject;
   }
   EndCanonType CRCLProgramType::getEndCanon() {

   if(jthis == NULL) {
       std::cerr << "Call of method getEndCanon of crcl.base.CRCLProgramType with jthis == NULL." << std::endl;
       EndCanonType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLProgramType::getEndCanon jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getEndCanon", "()Lcrcl/base/EndCanonType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CRCLProgramType has no method named getEndCanon with signature ()Lcrcl/base/EndCanonType;." << std::endl;
           EndCanonType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    EndCanonType retObject(retVal,false);
    return retObject;
   }
   void CRCLProgramType::setEndCanon(EndCanonType  &endCanonType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setEndCanon of crcl.base.CRCLProgramType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLProgramType::setEndCanon jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setEndCanon", "(Lcrcl/base/EndCanonType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CRCLProgramType has no method named setEndCanon with signature (Lcrcl/base/EndCanonType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,endCanonType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewCRCLProgramTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/CRCLProgramType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/CRCLProgramType" << std::endl;
       }
       return clss;
   }
   
   static jclass CRCLProgramTypeClass = NULL;
   static inline jclass getCRCLProgramTypeClass() {
       if (CRCLProgramTypeClass != NULL) {
           return CRCLProgramTypeClass;
       }
       CRCLProgramTypeClass = getNewCRCLProgramTypeClass();
   }
   
   // get JNI handle for class crcl.base.VectorType
   static inline jclass getVectorTypeClass();
   
   VectorType::VectorType(jobject _jthis, bool copy): DataThingType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   VectorType::VectorType(const VectorType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   VectorType::VectorType() {
    JNIEnv *env =getEnv();
    static jclass cls = getVectorTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class VectorType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new VectorType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.VectorType
   VectorType::~VectorType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::math::BigDecimal VectorType::getK() {

   if(jthis == NULL) {
       std::cerr << "Call of method getK of crcl.base.VectorType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," VectorType::getK jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getK", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.VectorType has no method named getK with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   ::crclj::java::math::BigDecimal VectorType::getI() {

   if(jthis == NULL) {
       std::cerr << "Call of method getI of crcl.base.VectorType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," VectorType::getI jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getI", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.VectorType has no method named getI with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   ::crclj::java::math::BigDecimal VectorType::getJ() {

   if(jthis == NULL) {
       std::cerr << "Call of method getJ of crcl.base.VectorType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," VectorType::getJ jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getJ", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.VectorType has no method named getJ with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void VectorType::setI(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setI of crcl.base.VectorType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," VectorType::setI jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setI", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.VectorType has no method named setI with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void VectorType::setJ(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setJ of crcl.base.VectorType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," VectorType::setJ jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setJ", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.VectorType has no method named setJ with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void VectorType::setK(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setK of crcl.base.VectorType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," VectorType::setK jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setK", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.VectorType has no method named setK with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewVectorTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/VectorType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/VectorType" << std::endl;
       }
       return clss;
   }
   
   static jclass VectorTypeClass = NULL;
   static inline jclass getVectorTypeClass() {
       if (VectorTypeClass != NULL) {
           return VectorTypeClass;
       }
       VectorTypeClass = getNewVectorTypeClass();
   }
   
   // get JNI handle for class crcl.base.SetEndEffectorType
   static inline jclass getSetEndEffectorTypeClass();
   
   SetEndEffectorType::SetEndEffectorType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SetEndEffectorType::SetEndEffectorType(const SetEndEffectorType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SetEndEffectorType::SetEndEffectorType() {
    JNIEnv *env =getEnv();
    static jclass cls = getSetEndEffectorTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class SetEndEffectorType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SetEndEffectorType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.SetEndEffectorType
   SetEndEffectorType::~SetEndEffectorType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::math::BigDecimal SetEndEffectorType::getSetting() {

   if(jthis == NULL) {
       std::cerr << "Call of method getSetting of crcl.base.SetEndEffectorType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetEndEffectorType::getSetting jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getSetting", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetEndEffectorType has no method named getSetting with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void SetEndEffectorType::setSetting(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setSetting of crcl.base.SetEndEffectorType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetEndEffectorType::setSetting jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setSetting", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetEndEffectorType has no method named setSetting with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewSetEndEffectorTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/SetEndEffectorType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/SetEndEffectorType" << std::endl;
       }
       return clss;
   }
   
   static jclass SetEndEffectorTypeClass = NULL;
   static inline jclass getSetEndEffectorTypeClass() {
       if (SetEndEffectorTypeClass != NULL) {
           return SetEndEffectorTypeClass;
       }
       SetEndEffectorTypeClass = getNewSetEndEffectorTypeClass();
   }
   
   // get JNI handle for class crcl.base.SetTorqueUnitsType
   static inline jclass getSetTorqueUnitsTypeClass();
   
   SetTorqueUnitsType::SetTorqueUnitsType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SetTorqueUnitsType::SetTorqueUnitsType(const SetTorqueUnitsType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SetTorqueUnitsType::SetTorqueUnitsType() {
    JNIEnv *env =getEnv();
    static jclass cls = getSetTorqueUnitsTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class SetTorqueUnitsType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SetTorqueUnitsType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.SetTorqueUnitsType
   SetTorqueUnitsType::~SetTorqueUnitsType() {
   	// Place-holder for later extensibility.
   }

   TorqueUnitEnumType SetTorqueUnitsType::getUnitName() {

   if(jthis == NULL) {
       std::cerr << "Call of method getUnitName of crcl.base.SetTorqueUnitsType with jthis == NULL." << std::endl;
       TorqueUnitEnumType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetTorqueUnitsType::getUnitName jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getUnitName", "()Lcrcl/base/TorqueUnitEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetTorqueUnitsType has no method named getUnitName with signature ()Lcrcl/base/TorqueUnitEnumType;." << std::endl;
           TorqueUnitEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    TorqueUnitEnumType retObject(retVal,false);
    return retObject;
   }
   void SetTorqueUnitsType::setUnitName(TorqueUnitEnumType  &torqueUnitEnumType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setUnitName of crcl.base.SetTorqueUnitsType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetTorqueUnitsType::setUnitName jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setUnitName", "(Lcrcl/base/TorqueUnitEnumType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetTorqueUnitsType has no method named setUnitName with signature (Lcrcl/base/TorqueUnitEnumType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,torqueUnitEnumType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewSetTorqueUnitsTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/SetTorqueUnitsType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/SetTorqueUnitsType" << std::endl;
       }
       return clss;
   }
   
   static jclass SetTorqueUnitsTypeClass = NULL;
   static inline jclass getSetTorqueUnitsTypeClass() {
       if (SetTorqueUnitsTypeClass != NULL) {
           return SetTorqueUnitsTypeClass;
       }
       SetTorqueUnitsTypeClass = getNewSetTorqueUnitsTypeClass();
   }
   
   // get JNI handle for class crcl.base.ConfigureJointReportType
   static inline jclass getConfigureJointReportTypeClass();
   
   ConfigureJointReportType::ConfigureJointReportType(jobject _jthis, bool copy): DataThingType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   ConfigureJointReportType::ConfigureJointReportType(const ConfigureJointReportType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   ConfigureJointReportType::ConfigureJointReportType() {
    JNIEnv *env =getEnv();
    static jclass cls = getConfigureJointReportTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class ConfigureJointReportType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new ConfigureJointReportType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.ConfigureJointReportType
   ConfigureJointReportType::~ConfigureJointReportType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::math::BigInteger ConfigureJointReportType::getJointNumber() {

   if(jthis == NULL) {
       std::cerr << "Call of method getJointNumber of crcl.base.ConfigureJointReportType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ConfigureJointReportType::getJointNumber jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getJointNumber", "()Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ConfigureJointReportType has no method named getJointNumber with signature ()Ljava/math/BigInteger;." << std::endl;
           ::crclj::java::math::BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigInteger retObject(retVal,false);
    return retObject;
   }
   void ConfigureJointReportType::setJointNumber(::crclj::java::math::BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setJointNumber of crcl.base.ConfigureJointReportType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ConfigureJointReportType::setJointNumber jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setJointNumber", "(Ljava/math/BigInteger;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ConfigureJointReportType has no method named setJointNumber with signature (Ljava/math/BigInteger;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   jboolean ConfigureJointReportType::isReportPosition() {

   if(jthis == NULL) {
       std::cerr << "Call of method isReportPosition of crcl.base.ConfigureJointReportType with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ConfigureJointReportType::isReportPosition jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isReportPosition", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ConfigureJointReportType has no method named isReportPosition with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void ConfigureJointReportType::setReportPosition(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setReportPosition of crcl.base.ConfigureJointReportType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ConfigureJointReportType::setReportPosition jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setReportPosition", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ConfigureJointReportType has no method named setReportPosition with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean ConfigureJointReportType::isReportTorqueOrForce() {

   if(jthis == NULL) {
       std::cerr << "Call of method isReportTorqueOrForce of crcl.base.ConfigureJointReportType with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ConfigureJointReportType::isReportTorqueOrForce jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isReportTorqueOrForce", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ConfigureJointReportType has no method named isReportTorqueOrForce with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void ConfigureJointReportType::setReportTorqueOrForce(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setReportTorqueOrForce of crcl.base.ConfigureJointReportType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ConfigureJointReportType::setReportTorqueOrForce jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setReportTorqueOrForce", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ConfigureJointReportType has no method named setReportTorqueOrForce with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean ConfigureJointReportType::isReportVelocity() {

   if(jthis == NULL) {
       std::cerr << "Call of method isReportVelocity of crcl.base.ConfigureJointReportType with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ConfigureJointReportType::isReportVelocity jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isReportVelocity", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ConfigureJointReportType has no method named isReportVelocity with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void ConfigureJointReportType::setReportVelocity(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setReportVelocity of crcl.base.ConfigureJointReportType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ConfigureJointReportType::setReportVelocity jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setReportVelocity", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ConfigureJointReportType has no method named setReportVelocity with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewConfigureJointReportTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/ConfigureJointReportType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/ConfigureJointReportType" << std::endl;
       }
       return clss;
   }
   
   static jclass ConfigureJointReportTypeClass = NULL;
   static inline jclass getConfigureJointReportTypeClass() {
       if (ConfigureJointReportTypeClass != NULL) {
           return ConfigureJointReportTypeClass;
       }
       ConfigureJointReportTypeClass = getNewConfigureJointReportTypeClass();
   }
   
   // get JNI handle for class crcl.base.SetRotAccelType
   static inline jclass getSetRotAccelTypeClass();
   
   SetRotAccelType::SetRotAccelType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SetRotAccelType::SetRotAccelType(const SetRotAccelType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SetRotAccelType::SetRotAccelType() {
    JNIEnv *env =getEnv();
    static jclass cls = getSetRotAccelTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class SetRotAccelType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SetRotAccelType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.SetRotAccelType
   SetRotAccelType::~SetRotAccelType() {
   	// Place-holder for later extensibility.
   }

   RotAccelType SetRotAccelType::getRotAccel() {

   if(jthis == NULL) {
       std::cerr << "Call of method getRotAccel of crcl.base.SetRotAccelType with jthis == NULL." << std::endl;
       RotAccelType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetRotAccelType::getRotAccel jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getRotAccel", "()Lcrcl/base/RotAccelType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetRotAccelType has no method named getRotAccel with signature ()Lcrcl/base/RotAccelType;." << std::endl;
           RotAccelType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    RotAccelType retObject(retVal,false);
    return retObject;
   }
   void SetRotAccelType::setRotAccel(RotAccelType  &rotAccelType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setRotAccel of crcl.base.SetRotAccelType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetRotAccelType::setRotAccel jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setRotAccel", "(Lcrcl/base/RotAccelType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetRotAccelType has no method named setRotAccel with signature (Lcrcl/base/RotAccelType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,rotAccelType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewSetRotAccelTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/SetRotAccelType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/SetRotAccelType" << std::endl;
       }
       return clss;
   }
   
   static jclass SetRotAccelTypeClass = NULL;
   static inline jclass getSetRotAccelTypeClass() {
       if (SetRotAccelTypeClass != NULL) {
           return SetRotAccelTypeClass;
       }
       SetRotAccelTypeClass = getNewSetRotAccelTypeClass();
   }
   
   // get JNI handle for class crcl.base.SetAngleUnitsType
   static inline jclass getSetAngleUnitsTypeClass();
   
   SetAngleUnitsType::SetAngleUnitsType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SetAngleUnitsType::SetAngleUnitsType(const SetAngleUnitsType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SetAngleUnitsType::SetAngleUnitsType() {
    JNIEnv *env =getEnv();
    static jclass cls = getSetAngleUnitsTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class SetAngleUnitsType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SetAngleUnitsType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.SetAngleUnitsType
   SetAngleUnitsType::~SetAngleUnitsType() {
   	// Place-holder for later extensibility.
   }

   AngleUnitEnumType SetAngleUnitsType::getUnitName() {

   if(jthis == NULL) {
       std::cerr << "Call of method getUnitName of crcl.base.SetAngleUnitsType with jthis == NULL." << std::endl;
       AngleUnitEnumType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetAngleUnitsType::getUnitName jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getUnitName", "()Lcrcl/base/AngleUnitEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetAngleUnitsType has no method named getUnitName with signature ()Lcrcl/base/AngleUnitEnumType;." << std::endl;
           AngleUnitEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    AngleUnitEnumType retObject(retVal,false);
    return retObject;
   }
   void SetAngleUnitsType::setUnitName(AngleUnitEnumType  &angleUnitEnumType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setUnitName of crcl.base.SetAngleUnitsType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetAngleUnitsType::setUnitName jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setUnitName", "(Lcrcl/base/AngleUnitEnumType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetAngleUnitsType has no method named setUnitName with signature (Lcrcl/base/AngleUnitEnumType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,angleUnitEnumType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewSetAngleUnitsTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/SetAngleUnitsType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/SetAngleUnitsType" << std::endl;
       }
       return clss;
   }
   
   static jclass SetAngleUnitsTypeClass = NULL;
   static inline jclass getSetAngleUnitsTypeClass() {
       if (SetAngleUnitsTypeClass != NULL) {
           return SetAngleUnitsTypeClass;
       }
       SetAngleUnitsTypeClass = getNewSetAngleUnitsTypeClass();
   }
   
   // get JNI handle for class crcl.base.CommandStatusType
   static inline jclass getCommandStatusTypeClass();
   
   CommandStatusType::CommandStatusType(jobject _jthis, bool copy): DataThingType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   CommandStatusType::CommandStatusType(const CommandStatusType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   CommandStatusType::CommandStatusType() {
    JNIEnv *env =getEnv();
    static jclass cls = getCommandStatusTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class CommandStatusType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new CommandStatusType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.CommandStatusType
   CommandStatusType::~CommandStatusType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::math::BigInteger CommandStatusType::getCommandID() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCommandID of crcl.base.CommandStatusType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CommandStatusType::getCommandID jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCommandID", "()Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CommandStatusType has no method named getCommandID with signature ()Ljava/math/BigInteger;." << std::endl;
           ::crclj::java::math::BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigInteger retObject(retVal,false);
    return retObject;
   }
   void CommandStatusType::setCommandID(::crclj::java::math::BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCommandID of crcl.base.CommandStatusType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CommandStatusType::setCommandID jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCommandID", "(Ljava/math/BigInteger;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CommandStatusType has no method named setCommandID with signature (Ljava/math/BigInteger;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   CommandStateEnumType CommandStatusType::getCommandState() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCommandState of crcl.base.CommandStatusType with jthis == NULL." << std::endl;
       CommandStateEnumType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CommandStatusType::getCommandState jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCommandState", "()Lcrcl/base/CommandStateEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CommandStatusType has no method named getCommandState with signature ()Lcrcl/base/CommandStateEnumType;." << std::endl;
           CommandStateEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    CommandStateEnumType retObject(retVal,false);
    return retObject;
   }
   ::crclj::java::math::BigInteger CommandStatusType::getStatusID() {

   if(jthis == NULL) {
       std::cerr << "Call of method getStatusID of crcl.base.CommandStatusType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CommandStatusType::getStatusID jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getStatusID", "()Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CommandStatusType has no method named getStatusID with signature ()Ljava/math/BigInteger;." << std::endl;
           ::crclj::java::math::BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigInteger retObject(retVal,false);
    return retObject;
   }
   void CommandStatusType::setStatusID(::crclj::java::math::BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setStatusID of crcl.base.CommandStatusType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CommandStatusType::setStatusID jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setStatusID", "(Ljava/math/BigInteger;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CommandStatusType has no method named setStatusID with signature (Ljava/math/BigInteger;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void CommandStatusType::setCommandState(CommandStateEnumType  &commandStateEnumType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCommandState of crcl.base.CommandStatusType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CommandStatusType::setCommandState jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCommandState", "(Lcrcl/base/CommandStateEnumType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CommandStatusType has no method named setCommandState with signature (Lcrcl/base/CommandStateEnumType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,commandStateEnumType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewCommandStatusTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/CommandStatusType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/CommandStatusType" << std::endl;
       }
       return clss;
   }
   
   static jclass CommandStatusTypeClass = NULL;
   static inline jclass getCommandStatusTypeClass() {
       if (CommandStatusTypeClass != NULL) {
           return CommandStatusTypeClass;
       }
       CommandStatusTypeClass = getNewCommandStatusTypeClass();
   }
   
   // get JNI handle for class crcl.base.RotSpeedRelativeType
   static inline jclass getRotSpeedRelativeTypeClass();
   
   RotSpeedRelativeType::RotSpeedRelativeType(jobject _jthis, bool copy): RotSpeedType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   RotSpeedRelativeType::RotSpeedRelativeType(const RotSpeedRelativeType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   RotSpeedRelativeType::RotSpeedRelativeType() {
    JNIEnv *env =getEnv();
    static jclass cls = getRotSpeedRelativeTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class RotSpeedRelativeType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new RotSpeedRelativeType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.RotSpeedRelativeType
   RotSpeedRelativeType::~RotSpeedRelativeType() {
   	// Place-holder for later extensibility.
   }

   void RotSpeedRelativeType::setFraction(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setFraction of crcl.base.RotSpeedRelativeType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," RotSpeedRelativeType::setFraction jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setFraction", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.RotSpeedRelativeType has no method named setFraction with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::math::BigDecimal RotSpeedRelativeType::getFraction() {

   if(jthis == NULL) {
       std::cerr << "Call of method getFraction of crcl.base.RotSpeedRelativeType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," RotSpeedRelativeType::getFraction jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getFraction", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.RotSpeedRelativeType has no method named getFraction with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   static jclass getNewRotSpeedRelativeTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/RotSpeedRelativeType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/RotSpeedRelativeType" << std::endl;
       }
       return clss;
   }
   
   static jclass RotSpeedRelativeTypeClass = NULL;
   static inline jclass getRotSpeedRelativeTypeClass() {
       if (RotSpeedRelativeTypeClass != NULL) {
           return RotSpeedRelativeTypeClass;
       }
       RotSpeedRelativeTypeClass = getNewRotSpeedRelativeTypeClass();
   }
   
   // get JNI handle for class crcl.base.RotAccelAbsoluteType
   static inline jclass getRotAccelAbsoluteTypeClass();
   
   RotAccelAbsoluteType::RotAccelAbsoluteType(jobject _jthis, bool copy): RotAccelType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   RotAccelAbsoluteType::RotAccelAbsoluteType(const RotAccelAbsoluteType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   RotAccelAbsoluteType::RotAccelAbsoluteType() {
    JNIEnv *env =getEnv();
    static jclass cls = getRotAccelAbsoluteTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class RotAccelAbsoluteType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new RotAccelAbsoluteType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.RotAccelAbsoluteType
   RotAccelAbsoluteType::~RotAccelAbsoluteType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::math::BigDecimal RotAccelAbsoluteType::getSetting() {

   if(jthis == NULL) {
       std::cerr << "Call of method getSetting of crcl.base.RotAccelAbsoluteType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," RotAccelAbsoluteType::getSetting jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getSetting", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.RotAccelAbsoluteType has no method named getSetting with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void RotAccelAbsoluteType::setSetting(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setSetting of crcl.base.RotAccelAbsoluteType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," RotAccelAbsoluteType::setSetting jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setSetting", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.RotAccelAbsoluteType has no method named setSetting with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewRotAccelAbsoluteTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/RotAccelAbsoluteType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/RotAccelAbsoluteType" << std::endl;
       }
       return clss;
   }
   
   static jclass RotAccelAbsoluteTypeClass = NULL;
   static inline jclass getRotAccelAbsoluteTypeClass() {
       if (RotAccelAbsoluteTypeClass != NULL) {
           return RotAccelAbsoluteTypeClass;
       }
       RotAccelAbsoluteTypeClass = getNewRotAccelAbsoluteTypeClass();
   }
   
   // get JNI handle for class crcl.base.SetMotionCoordinationType
   static inline jclass getSetMotionCoordinationTypeClass();
   
   SetMotionCoordinationType::SetMotionCoordinationType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SetMotionCoordinationType::SetMotionCoordinationType(const SetMotionCoordinationType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SetMotionCoordinationType::SetMotionCoordinationType() {
    JNIEnv *env =getEnv();
    static jclass cls = getSetMotionCoordinationTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class SetMotionCoordinationType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SetMotionCoordinationType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.SetMotionCoordinationType
   SetMotionCoordinationType::~SetMotionCoordinationType() {
   	// Place-holder for later extensibility.
   }

   jboolean SetMotionCoordinationType::isCoordinated() {

   if(jthis == NULL) {
       std::cerr << "Call of method isCoordinated of crcl.base.SetMotionCoordinationType with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetMotionCoordinationType::isCoordinated jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isCoordinated", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetMotionCoordinationType has no method named isCoordinated with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SetMotionCoordinationType::setCoordinated(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCoordinated of crcl.base.SetMotionCoordinationType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetMotionCoordinationType::setCoordinated jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCoordinated", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetMotionCoordinationType has no method named setCoordinated with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewSetMotionCoordinationTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/SetMotionCoordinationType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/SetMotionCoordinationType" << std::endl;
       }
       return clss;
   }
   
   static jclass SetMotionCoordinationTypeClass = NULL;
   static inline jclass getSetMotionCoordinationTypeClass() {
       if (SetMotionCoordinationTypeClass != NULL) {
           return SetMotionCoordinationTypeClass;
       }
       SetMotionCoordinationTypeClass = getNewSetMotionCoordinationTypeClass();
   }
   
   // get JNI handle for class crcl.base.ActuateJointType
   static inline jclass getActuateJointTypeClass();
   
   ActuateJointType::ActuateJointType(jobject _jthis, bool copy): DataThingType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   ActuateJointType::ActuateJointType(const ActuateJointType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   ActuateJointType::ActuateJointType() {
    JNIEnv *env =getEnv();
    static jclass cls = getActuateJointTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class ActuateJointType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new ActuateJointType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.ActuateJointType
   ActuateJointType::~ActuateJointType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::math::BigInteger ActuateJointType::getJointNumber() {

   if(jthis == NULL) {
       std::cerr << "Call of method getJointNumber of crcl.base.ActuateJointType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ActuateJointType::getJointNumber jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getJointNumber", "()Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ActuateJointType has no method named getJointNumber with signature ()Ljava/math/BigInteger;." << std::endl;
           ::crclj::java::math::BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigInteger retObject(retVal,false);
    return retObject;
   }
   ::crclj::java::math::BigDecimal ActuateJointType::getJointPosition() {

   if(jthis == NULL) {
       std::cerr << "Call of method getJointPosition of crcl.base.ActuateJointType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ActuateJointType::getJointPosition jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getJointPosition", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ActuateJointType has no method named getJointPosition with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void ActuateJointType::setJointNumber(::crclj::java::math::BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setJointNumber of crcl.base.ActuateJointType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ActuateJointType::setJointNumber jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setJointNumber", "(Ljava/math/BigInteger;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ActuateJointType has no method named setJointNumber with signature (Ljava/math/BigInteger;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void ActuateJointType::setJointPosition(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setJointPosition of crcl.base.ActuateJointType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ActuateJointType::setJointPosition jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setJointPosition", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ActuateJointType has no method named setJointPosition with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   JointDetailsType ActuateJointType::getJointDetails() {

   if(jthis == NULL) {
       std::cerr << "Call of method getJointDetails of crcl.base.ActuateJointType with jthis == NULL." << std::endl;
       JointDetailsType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ActuateJointType::getJointDetails jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getJointDetails", "()Lcrcl/base/JointDetailsType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ActuateJointType has no method named getJointDetails with signature ()Lcrcl/base/JointDetailsType;." << std::endl;
           JointDetailsType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    JointDetailsType retObject(retVal,false);
    return retObject;
   }
   void ActuateJointType::setJointDetails(JointDetailsType  &jointDetailsType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setJointDetails of crcl.base.ActuateJointType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ActuateJointType::setJointDetails jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setJointDetails", "(Lcrcl/base/JointDetailsType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ActuateJointType has no method named setJointDetails with signature (Lcrcl/base/JointDetailsType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,jointDetailsType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewActuateJointTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/ActuateJointType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/ActuateJointType" << std::endl;
       }
       return clss;
   }
   
   static jclass ActuateJointTypeClass = NULL;
   static inline jclass getActuateJointTypeClass() {
       if (ActuateJointTypeClass != NULL) {
           return ActuateJointTypeClass;
       }
       ActuateJointTypeClass = getNewActuateJointTypeClass();
   }
   
   // get JNI handle for class crcl.base.TransSpeedAbsoluteType
   static inline jclass getTransSpeedAbsoluteTypeClass();
   
   TransSpeedAbsoluteType::TransSpeedAbsoluteType(jobject _jthis, bool copy): TransSpeedType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   TransSpeedAbsoluteType::TransSpeedAbsoluteType(const TransSpeedAbsoluteType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   TransSpeedAbsoluteType::TransSpeedAbsoluteType() {
    JNIEnv *env =getEnv();
    static jclass cls = getTransSpeedAbsoluteTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class TransSpeedAbsoluteType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new TransSpeedAbsoluteType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.TransSpeedAbsoluteType
   TransSpeedAbsoluteType::~TransSpeedAbsoluteType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::math::BigDecimal TransSpeedAbsoluteType::getSetting() {

   if(jthis == NULL) {
       std::cerr << "Call of method getSetting of crcl.base.TransSpeedAbsoluteType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," TransSpeedAbsoluteType::getSetting jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getSetting", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.TransSpeedAbsoluteType has no method named getSetting with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void TransSpeedAbsoluteType::setSetting(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setSetting of crcl.base.TransSpeedAbsoluteType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," TransSpeedAbsoluteType::setSetting jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setSetting", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.TransSpeedAbsoluteType has no method named setSetting with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewTransSpeedAbsoluteTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/TransSpeedAbsoluteType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/TransSpeedAbsoluteType" << std::endl;
       }
       return clss;
   }
   
   static jclass TransSpeedAbsoluteTypeClass = NULL;
   static inline jclass getTransSpeedAbsoluteTypeClass() {
       if (TransSpeedAbsoluteTypeClass != NULL) {
           return TransSpeedAbsoluteTypeClass;
       }
       TransSpeedAbsoluteTypeClass = getNewTransSpeedAbsoluteTypeClass();
   }
   
   // get JNI handle for class crcl.base.PoseToleranceType
   static inline jclass getPoseToleranceTypeClass();
   
   PoseToleranceType::PoseToleranceType(jobject _jthis, bool copy): DataThingType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   PoseToleranceType::PoseToleranceType(const PoseToleranceType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   PoseToleranceType::PoseToleranceType() {
    JNIEnv *env =getEnv();
    static jclass cls = getPoseToleranceTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class PoseToleranceType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PoseToleranceType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.PoseToleranceType
   PoseToleranceType::~PoseToleranceType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::math::BigDecimal PoseToleranceType::getXPointTolerance() {

   if(jthis == NULL) {
       std::cerr << "Call of method getXPointTolerance of crcl.base.PoseToleranceType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseToleranceType::getXPointTolerance jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getXPointTolerance", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseToleranceType has no method named getXPointTolerance with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void PoseToleranceType::setXPointTolerance(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setXPointTolerance of crcl.base.PoseToleranceType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseToleranceType::setXPointTolerance jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setXPointTolerance", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseToleranceType has no method named setXPointTolerance with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::math::BigDecimal PoseToleranceType::getYPointTolerance() {

   if(jthis == NULL) {
       std::cerr << "Call of method getYPointTolerance of crcl.base.PoseToleranceType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseToleranceType::getYPointTolerance jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getYPointTolerance", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseToleranceType has no method named getYPointTolerance with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void PoseToleranceType::setYPointTolerance(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setYPointTolerance of crcl.base.PoseToleranceType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseToleranceType::setYPointTolerance jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setYPointTolerance", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseToleranceType has no method named setYPointTolerance with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::math::BigDecimal PoseToleranceType::getZPointTolerance() {

   if(jthis == NULL) {
       std::cerr << "Call of method getZPointTolerance of crcl.base.PoseToleranceType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseToleranceType::getZPointTolerance jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getZPointTolerance", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseToleranceType has no method named getZPointTolerance with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void PoseToleranceType::setZPointTolerance(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setZPointTolerance of crcl.base.PoseToleranceType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseToleranceType::setZPointTolerance jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setZPointTolerance", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseToleranceType has no method named setZPointTolerance with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::math::BigDecimal PoseToleranceType::getXAxisTolerance() {

   if(jthis == NULL) {
       std::cerr << "Call of method getXAxisTolerance of crcl.base.PoseToleranceType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseToleranceType::getXAxisTolerance jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getXAxisTolerance", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseToleranceType has no method named getXAxisTolerance with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void PoseToleranceType::setXAxisTolerance(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setXAxisTolerance of crcl.base.PoseToleranceType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseToleranceType::setXAxisTolerance jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setXAxisTolerance", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseToleranceType has no method named setXAxisTolerance with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::math::BigDecimal PoseToleranceType::getZAxisTolerance() {

   if(jthis == NULL) {
       std::cerr << "Call of method getZAxisTolerance of crcl.base.PoseToleranceType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseToleranceType::getZAxisTolerance jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getZAxisTolerance", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseToleranceType has no method named getZAxisTolerance with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void PoseToleranceType::setZAxisTolerance(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setZAxisTolerance of crcl.base.PoseToleranceType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PoseToleranceType::setZAxisTolerance jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setZAxisTolerance", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.PoseToleranceType has no method named setZAxisTolerance with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewPoseToleranceTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/PoseToleranceType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/PoseToleranceType" << std::endl;
       }
       return clss;
   }
   
   static jclass PoseToleranceTypeClass = NULL;
   static inline jclass getPoseToleranceTypeClass() {
       if (PoseToleranceTypeClass != NULL) {
           return PoseToleranceTypeClass;
       }
       PoseToleranceTypeClass = getNewPoseToleranceTypeClass();
   }
   
   // get JNI handle for class crcl.base.StopMotionType
   static inline jclass getStopMotionTypeClass();
   
   StopMotionType::StopMotionType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   StopMotionType::StopMotionType(const StopMotionType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   StopMotionType::StopMotionType() {
    JNIEnv *env =getEnv();
    static jclass cls = getStopMotionTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class StopMotionType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new StopMotionType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.StopMotionType
   StopMotionType::~StopMotionType() {
   	// Place-holder for later extensibility.
   }

   StopConditionEnumType StopMotionType::getStopCondition() {

   if(jthis == NULL) {
       std::cerr << "Call of method getStopCondition of crcl.base.StopMotionType with jthis == NULL." << std::endl;
       StopConditionEnumType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," StopMotionType::getStopCondition jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getStopCondition", "()Lcrcl/base/StopConditionEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.StopMotionType has no method named getStopCondition with signature ()Lcrcl/base/StopConditionEnumType;." << std::endl;
           StopConditionEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    StopConditionEnumType retObject(retVal,false);
    return retObject;
   }
   void StopMotionType::setStopCondition(StopConditionEnumType  &stopConditionEnumType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setStopCondition of crcl.base.StopMotionType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," StopMotionType::setStopCondition jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setStopCondition", "(Lcrcl/base/StopConditionEnumType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.StopMotionType has no method named setStopCondition with signature (Lcrcl/base/StopConditionEnumType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,stopConditionEnumType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewStopMotionTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/StopMotionType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/StopMotionType" << std::endl;
       }
       return clss;
   }
   
   static jclass StopMotionTypeClass = NULL;
   static inline jclass getStopMotionTypeClass() {
       if (StopMotionTypeClass != NULL) {
           return StopMotionTypeClass;
       }
       StopMotionTypeClass = getNewStopMotionTypeClass();
   }
   
   // get JNI handle for class crcl.base.ConfigureJointReportsType
   static inline jclass getConfigureJointReportsTypeClass();
   
   ConfigureJointReportsType::ConfigureJointReportsType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   ConfigureJointReportsType::ConfigureJointReportsType(const ConfigureJointReportsType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   ConfigureJointReportsType::ConfigureJointReportsType() {
    JNIEnv *env =getEnv();
    static jclass cls = getConfigureJointReportsTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class ConfigureJointReportsType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new ConfigureJointReportsType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.ConfigureJointReportsType
   ConfigureJointReportsType::~ConfigureJointReportsType() {
   	// Place-holder for later extensibility.
   }

   jboolean ConfigureJointReportsType::isResetAll() {

   if(jthis == NULL) {
       std::cerr << "Call of method isResetAll of crcl.base.ConfigureJointReportsType with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ConfigureJointReportsType::isResetAll jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isResetAll", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ConfigureJointReportsType has no method named isResetAll with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void ConfigureJointReportsType::setResetAll(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setResetAll of crcl.base.ConfigureJointReportsType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ConfigureJointReportsType::setResetAll jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setResetAll", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ConfigureJointReportsType has no method named setResetAll with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::util::List ConfigureJointReportsType::getConfigureJointReport() {

   if(jthis == NULL) {
       std::cerr << "Call of method getConfigureJointReport of crcl.base.ConfigureJointReportsType with jthis == NULL." << std::endl;
       ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ConfigureJointReportsType::getConfigureJointReport jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getConfigureJointReport", "()Ljava/util/List;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ConfigureJointReportsType has no method named getConfigureJointReport with signature ()Ljava/util/List;." << std::endl;
           ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::util::List retObject(retVal,false);
    return retObject;
   }
   static jclass getNewConfigureJointReportsTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/ConfigureJointReportsType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/ConfigureJointReportsType" << std::endl;
       }
       return clss;
   }
   
   static jclass ConfigureJointReportsTypeClass = NULL;
   static inline jclass getConfigureJointReportsTypeClass() {
       if (ConfigureJointReportsTypeClass != NULL) {
           return ConfigureJointReportsTypeClass;
       }
       ConfigureJointReportsTypeClass = getNewConfigureJointReportsTypeClass();
   }
   
   // get JNI handle for class crcl.base.CRCLCommandInstanceType
   static inline jclass getCRCLCommandInstanceTypeClass();
   
   CRCLCommandInstanceType::CRCLCommandInstanceType(jobject _jthis, bool copy): DataThingType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   CRCLCommandInstanceType::CRCLCommandInstanceType(const CRCLCommandInstanceType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   CRCLCommandInstanceType::CRCLCommandInstanceType() {
    JNIEnv *env =getEnv();
    static jclass cls = getCRCLCommandInstanceTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class CRCLCommandInstanceType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new CRCLCommandInstanceType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.CRCLCommandInstanceType
   CRCLCommandInstanceType::~CRCLCommandInstanceType() {
   	// Place-holder for later extensibility.
   }

   CRCLCommandType CRCLCommandInstanceType::getCRCLCommand() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCRCLCommand of crcl.base.CRCLCommandInstanceType with jthis == NULL." << std::endl;
       CRCLCommandType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLCommandInstanceType::getCRCLCommand jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCRCLCommand", "()Lcrcl/base/CRCLCommandType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CRCLCommandInstanceType has no method named getCRCLCommand with signature ()Lcrcl/base/CRCLCommandType;." << std::endl;
           CRCLCommandType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    CRCLCommandType retObject(retVal,false);
    return retObject;
   }
   void CRCLCommandInstanceType::setCRCLCommand(CRCLCommandType  &cRCLCommandType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCRCLCommand of crcl.base.CRCLCommandInstanceType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLCommandInstanceType::setCRCLCommand jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCRCLCommand", "(Lcrcl/base/CRCLCommandType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.CRCLCommandInstanceType has no method named setCRCLCommand with signature (Lcrcl/base/CRCLCommandType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,cRCLCommandType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewCRCLCommandInstanceTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/CRCLCommandInstanceType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/CRCLCommandInstanceType" << std::endl;
       }
       return clss;
   }
   
   static jclass CRCLCommandInstanceTypeClass = NULL;
   static inline jclass getCRCLCommandInstanceTypeClass() {
       if (CRCLCommandInstanceTypeClass != NULL) {
           return CRCLCommandInstanceTypeClass;
       }
       CRCLCommandInstanceTypeClass = getNewCRCLCommandInstanceTypeClass();
   }
   
   // get JNI handle for class crcl.base.SetRotSpeedType
   static inline jclass getSetRotSpeedTypeClass();
   
   SetRotSpeedType::SetRotSpeedType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SetRotSpeedType::SetRotSpeedType(const SetRotSpeedType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SetRotSpeedType::SetRotSpeedType() {
    JNIEnv *env =getEnv();
    static jclass cls = getSetRotSpeedTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class SetRotSpeedType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SetRotSpeedType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.SetRotSpeedType
   SetRotSpeedType::~SetRotSpeedType() {
   	// Place-holder for later extensibility.
   }

   RotSpeedType SetRotSpeedType::getRotSpeed() {

   if(jthis == NULL) {
       std::cerr << "Call of method getRotSpeed of crcl.base.SetRotSpeedType with jthis == NULL." << std::endl;
       RotSpeedType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetRotSpeedType::getRotSpeed jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getRotSpeed", "()Lcrcl/base/RotSpeedType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetRotSpeedType has no method named getRotSpeed with signature ()Lcrcl/base/RotSpeedType;." << std::endl;
           RotSpeedType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    RotSpeedType retObject(retVal,false);
    return retObject;
   }
   void SetRotSpeedType::setRotSpeed(RotSpeedType  &rotSpeedType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setRotSpeed of crcl.base.SetRotSpeedType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetRotSpeedType::setRotSpeed jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setRotSpeed", "(Lcrcl/base/RotSpeedType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetRotSpeedType has no method named setRotSpeed with signature (Lcrcl/base/RotSpeedType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,rotSpeedType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewSetRotSpeedTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/SetRotSpeedType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/SetRotSpeedType" << std::endl;
       }
       return clss;
   }
   
   static jclass SetRotSpeedTypeClass = NULL;
   static inline jclass getSetRotSpeedTypeClass() {
       if (SetRotSpeedTypeClass != NULL) {
           return SetRotSpeedTypeClass;
       }
       SetRotSpeedTypeClass = getNewSetRotSpeedTypeClass();
   }
   
   // get JNI handle for class crcl.base.ParallelGripperStatusType
   static inline jclass getParallelGripperStatusTypeClass();
   
   ParallelGripperStatusType::ParallelGripperStatusType(jobject _jthis, bool copy): GripperStatusType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   ParallelGripperStatusType::ParallelGripperStatusType(const ParallelGripperStatusType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   ParallelGripperStatusType::ParallelGripperStatusType() {
    JNIEnv *env =getEnv();
    static jclass cls = getParallelGripperStatusTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class ParallelGripperStatusType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new ParallelGripperStatusType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.ParallelGripperStatusType
   ParallelGripperStatusType::~ParallelGripperStatusType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::math::BigDecimal ParallelGripperStatusType::getSeparation() {

   if(jthis == NULL) {
       std::cerr << "Call of method getSeparation of crcl.base.ParallelGripperStatusType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ParallelGripperStatusType::getSeparation jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getSeparation", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ParallelGripperStatusType has no method named getSeparation with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void ParallelGripperStatusType::setSeparation(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setSeparation of crcl.base.ParallelGripperStatusType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ParallelGripperStatusType::setSeparation jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setSeparation", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ParallelGripperStatusType has no method named setSeparation with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewParallelGripperStatusTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/ParallelGripperStatusType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/ParallelGripperStatusType" << std::endl;
       }
       return clss;
   }
   
   static jclass ParallelGripperStatusTypeClass = NULL;
   static inline jclass getParallelGripperStatusTypeClass() {
       if (ParallelGripperStatusTypeClass != NULL) {
           return ParallelGripperStatusTypeClass;
       }
       ParallelGripperStatusTypeClass = getNewParallelGripperStatusTypeClass();
   }
   
   // get JNI handle for class crcl.base.LengthUnitEnumType
   static inline jclass getLengthUnitEnumTypeClass();
   
   LengthUnitEnumType::LengthUnitEnumType(jobject _jthis, bool copy): ::crclj::java::lang::Enum(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   LengthUnitEnumType::LengthUnitEnumType(const LengthUnitEnumType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }

   // Destructor for crcl.base.LengthUnitEnumType
   LengthUnitEnumType::~LengthUnitEnumType() {
   	// Place-holder for later extensibility.
   }

   LengthUnitEnumType LengthUnitEnumType::fromValue(jstring string_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getLengthUnitEnumTypeClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "fromValue", "(Ljava/lang/String;)Lcrcl/base/LengthUnitEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.LengthUnitEnumType has no method named fromValue with signature (Ljava/lang/String;)Lcrcl/base/LengthUnitEnumType;." << std::endl;
           LengthUnitEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,string_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    LengthUnitEnumType retObject(retVal,false);
    return retObject;
   }
   jstring LengthUnitEnumType::value() {

   if(jthis == NULL) {
       std::cerr << "Call of method value of crcl.base.LengthUnitEnumType with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," LengthUnitEnumType::value jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "value", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.LengthUnitEnumType has no method named value with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jobjectArray LengthUnitEnumType::values() {

   JNIEnv *env =getEnv();
   static jclass cls = getLengthUnitEnumTypeClass();
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "values", "()[Lcrcl/base/LengthUnitEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.LengthUnitEnumType has no method named values with signature ()[Lcrcl/base/LengthUnitEnumType;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallStaticObjectMethod( cls, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   LengthUnitEnumType LengthUnitEnumType::valueOf(jstring string_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getLengthUnitEnumTypeClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "valueOf", "(Ljava/lang/String;)Lcrcl/base/LengthUnitEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.LengthUnitEnumType has no method named valueOf with signature (Ljava/lang/String;)Lcrcl/base/LengthUnitEnumType;." << std::endl;
           LengthUnitEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,string_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    LengthUnitEnumType retObject(retVal,false);
    return retObject;
   }
   static jclass getNewLengthUnitEnumTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/LengthUnitEnumType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/LengthUnitEnumType" << std::endl;
       }
       return clss;
   }
   
   static jclass LengthUnitEnumTypeClass = NULL;
   static inline jclass getLengthUnitEnumTypeClass() {
       if (LengthUnitEnumTypeClass != NULL) {
           return LengthUnitEnumTypeClass;
       }
       LengthUnitEnumTypeClass = getNewLengthUnitEnumTypeClass();
   }
   
   // get JNI handle for class crcl.base.SetEndEffectorParametersType
   static inline jclass getSetEndEffectorParametersTypeClass();
   
   SetEndEffectorParametersType::SetEndEffectorParametersType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SetEndEffectorParametersType::SetEndEffectorParametersType(const SetEndEffectorParametersType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SetEndEffectorParametersType::SetEndEffectorParametersType() {
    JNIEnv *env =getEnv();
    static jclass cls = getSetEndEffectorParametersTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class SetEndEffectorParametersType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SetEndEffectorParametersType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.SetEndEffectorParametersType
   SetEndEffectorParametersType::~SetEndEffectorParametersType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::util::List SetEndEffectorParametersType::getParameterSetting() {

   if(jthis == NULL) {
       std::cerr << "Call of method getParameterSetting of crcl.base.SetEndEffectorParametersType with jthis == NULL." << std::endl;
       ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SetEndEffectorParametersType::getParameterSetting jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getParameterSetting", "()Ljava/util/List;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.SetEndEffectorParametersType has no method named getParameterSetting with signature ()Ljava/util/List;." << std::endl;
           ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::util::List retObject(retVal,false);
    return retObject;
   }
   static jclass getNewSetEndEffectorParametersTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/SetEndEffectorParametersType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/SetEndEffectorParametersType" << std::endl;
       }
       return clss;
   }
   
   static jclass SetEndEffectorParametersTypeClass = NULL;
   static inline jclass getSetEndEffectorParametersTypeClass() {
       if (SetEndEffectorParametersTypeClass != NULL) {
           return SetEndEffectorParametersTypeClass;
       }
       SetEndEffectorParametersTypeClass = getNewSetEndEffectorParametersTypeClass();
   }
   
   // get JNI handle for class crcl.base.ThreeFingerGripperStatusType
   static inline jclass getThreeFingerGripperStatusTypeClass();
   
   ThreeFingerGripperStatusType::ThreeFingerGripperStatusType(jobject _jthis, bool copy): GripperStatusType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   ThreeFingerGripperStatusType::ThreeFingerGripperStatusType(const ThreeFingerGripperStatusType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   ThreeFingerGripperStatusType::ThreeFingerGripperStatusType() {
    JNIEnv *env =getEnv();
    static jclass cls = getThreeFingerGripperStatusTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class ThreeFingerGripperStatusType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new ThreeFingerGripperStatusType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.ThreeFingerGripperStatusType
   ThreeFingerGripperStatusType::~ThreeFingerGripperStatusType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::math::BigDecimal ThreeFingerGripperStatusType::getFinger1Position() {

   if(jthis == NULL) {
       std::cerr << "Call of method getFinger1Position of crcl.base.ThreeFingerGripperStatusType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ThreeFingerGripperStatusType::getFinger1Position jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getFinger1Position", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ThreeFingerGripperStatusType has no method named getFinger1Position with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void ThreeFingerGripperStatusType::setFinger1Position(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setFinger1Position of crcl.base.ThreeFingerGripperStatusType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ThreeFingerGripperStatusType::setFinger1Position jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setFinger1Position", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ThreeFingerGripperStatusType has no method named setFinger1Position with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::math::BigDecimal ThreeFingerGripperStatusType::getFinger2Position() {

   if(jthis == NULL) {
       std::cerr << "Call of method getFinger2Position of crcl.base.ThreeFingerGripperStatusType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ThreeFingerGripperStatusType::getFinger2Position jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getFinger2Position", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ThreeFingerGripperStatusType has no method named getFinger2Position with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void ThreeFingerGripperStatusType::setFinger2Position(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setFinger2Position of crcl.base.ThreeFingerGripperStatusType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ThreeFingerGripperStatusType::setFinger2Position jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setFinger2Position", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ThreeFingerGripperStatusType has no method named setFinger2Position with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::math::BigDecimal ThreeFingerGripperStatusType::getFinger1Force() {

   if(jthis == NULL) {
       std::cerr << "Call of method getFinger1Force of crcl.base.ThreeFingerGripperStatusType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ThreeFingerGripperStatusType::getFinger1Force jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getFinger1Force", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ThreeFingerGripperStatusType has no method named getFinger1Force with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   ::crclj::java::math::BigDecimal ThreeFingerGripperStatusType::getFinger3Position() {

   if(jthis == NULL) {
       std::cerr << "Call of method getFinger3Position of crcl.base.ThreeFingerGripperStatusType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ThreeFingerGripperStatusType::getFinger3Position jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getFinger3Position", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ThreeFingerGripperStatusType has no method named getFinger3Position with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void ThreeFingerGripperStatusType::setFinger3Position(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setFinger3Position of crcl.base.ThreeFingerGripperStatusType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ThreeFingerGripperStatusType::setFinger3Position jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setFinger3Position", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ThreeFingerGripperStatusType has no method named setFinger3Position with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void ThreeFingerGripperStatusType::setFinger1Force(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setFinger1Force of crcl.base.ThreeFingerGripperStatusType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ThreeFingerGripperStatusType::setFinger1Force jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setFinger1Force", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ThreeFingerGripperStatusType has no method named setFinger1Force with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::math::BigDecimal ThreeFingerGripperStatusType::getFinger2Force() {

   if(jthis == NULL) {
       std::cerr << "Call of method getFinger2Force of crcl.base.ThreeFingerGripperStatusType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ThreeFingerGripperStatusType::getFinger2Force jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getFinger2Force", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ThreeFingerGripperStatusType has no method named getFinger2Force with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void ThreeFingerGripperStatusType::setFinger2Force(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setFinger2Force of crcl.base.ThreeFingerGripperStatusType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ThreeFingerGripperStatusType::setFinger2Force jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setFinger2Force", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ThreeFingerGripperStatusType has no method named setFinger2Force with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::math::BigDecimal ThreeFingerGripperStatusType::getFinger3Force() {

   if(jthis == NULL) {
       std::cerr << "Call of method getFinger3Force of crcl.base.ThreeFingerGripperStatusType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ThreeFingerGripperStatusType::getFinger3Force jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getFinger3Force", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ThreeFingerGripperStatusType has no method named getFinger3Force with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void ThreeFingerGripperStatusType::setFinger3Force(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setFinger3Force of crcl.base.ThreeFingerGripperStatusType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," ThreeFingerGripperStatusType::setFinger3Force jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setFinger3Force", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.ThreeFingerGripperStatusType has no method named setFinger3Force with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewThreeFingerGripperStatusTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/ThreeFingerGripperStatusType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/ThreeFingerGripperStatusType" << std::endl;
       }
       return clss;
   }
   
   static jclass ThreeFingerGripperStatusTypeClass = NULL;
   static inline jclass getThreeFingerGripperStatusTypeClass() {
       if (ThreeFingerGripperStatusTypeClass != NULL) {
           return ThreeFingerGripperStatusTypeClass;
       }
       ThreeFingerGripperStatusTypeClass = getNewThreeFingerGripperStatusTypeClass();
   }
  } // end namespace base

   namespace utils{
   
   // get JNI handle for class crcl.utils.PendantClientOuter
   static inline jclass getPendantClientOuterClass();
   
   PendantClientOuter::PendantClientOuter(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   PendantClientOuter::PendantClientOuter(const PendantClientOuter &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   PendantClientOuter::PendantClientOuter() {
   JNIEnv *env =getEnv();
   static jclass cls = getPendantClientOuterClass();
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
       if (NULL == mid) {
           std::cerr << "Class PendantClientOuter has no method constructor signature ()V" << std::endl;
       } else {
           jthis = env->NewObject(cls, mid );
           jobjectRefType ref = env->GetObjectRefType(jthis);
           if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PendantClientOuter jthis=",jthis);
           if(ref != JNIGlobalRefType) {
               jthis = env->NewGlobalRef(jthis);
           }
       }
   }
   releaseEnv(env);
   }


   // Destructor for crcl.utils.PendantClientOuter
   PendantClientOuter::~PendantClientOuter() {
   	// Place-holder for later extensibility.
   }

   static jclass getNewPendantClientOuterClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/PendantClientOuter");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/PendantClientOuter" << std::endl;
       }
       return clss;
   }
   
   static jclass PendantClientOuterClass = NULL;
   static inline jclass getPendantClientOuterClass() {
       if (PendantClientOuterClass != NULL) {
           return PendantClientOuterClass;
       }
       PendantClientOuterClass = getNewPendantClientOuterClass();
   }
   
   // get JNI handle for class crcl.utils.SideViewJPanel
   static inline jclass getSideViewJPanelClass();
   
   SideViewJPanel::SideViewJPanel(jobject _jthis, bool copy): ::crclj::javax::swing::JPanel(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SideViewJPanel::SideViewJPanel(const SideViewJPanel &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SideViewJPanel::SideViewJPanel() {
    JNIEnv *env =getEnv();
    static jclass cls = getSideViewJPanelClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class SideViewJPanel has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SideViewJPanel jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.SideViewJPanel
   SideViewJPanel::~SideViewJPanel() {
   	// Place-holder for later extensibility.
   }

   SimRobotEnum SideViewJPanel::getRobotType() {

   if(jthis == NULL) {
       std::cerr << "Call of method getRobotType of crcl.utils.SideViewJPanel with jthis == NULL." << std::endl;
       SimRobotEnum nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SideViewJPanel::getRobotType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getRobotType", "()Lcrcl/utils/SimRobotEnum;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SideViewJPanel has no method named getRobotType with signature ()Lcrcl/utils/SimRobotEnum;." << std::endl;
           SimRobotEnum nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    SimRobotEnum retObject(retVal,false);
    return retObject;
   }
   void SideViewJPanel::setRobotType(SimRobotEnum  &simRobotEnum_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setRobotType of crcl.utils.SideViewJPanel with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SideViewJPanel::setRobotType jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setRobotType", "(Lcrcl/utils/SimRobotEnum;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SideViewJPanel has no method named setRobotType with signature (Lcrcl/utils/SimRobotEnum;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,simRobotEnum_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   jdoubleArray SideViewJPanel::getJointvals() {

   if(jthis == NULL) {
       std::cerr << "Call of method getJointvals of crcl.utils.SideViewJPanel with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SideViewJPanel::getJointvals jthis=",jthis);
   jdoubleArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getJointvals", "()[D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SideViewJPanel has no method named getJointvals with signature ()[D." << std::endl;
           return NULL;
       } else {
           retVal= (jdoubleArray)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SideViewJPanel::setJointvals(jdoubleArray doubleArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setJointvals of crcl.utils.SideViewJPanel with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SideViewJPanel::setJointvals jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setJointvals", "([D)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SideViewJPanel has no method named setJointvals with signature ([D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,doubleArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SideViewJPanel::setSeglengths(jdoubleArray doubleArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setSeglengths of crcl.utils.SideViewJPanel with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SideViewJPanel::setSeglengths jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setSeglengths", "([D)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SideViewJPanel has no method named setSeglengths with signature ([D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,doubleArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   jdoubleArray SideViewJPanel::getSeglengths() {

   if(jthis == NULL) {
       std::cerr << "Call of method getSeglengths of crcl.utils.SideViewJPanel with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SideViewJPanel::getSeglengths jthis=",jthis);
   jdoubleArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getSeglengths", "()[D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SideViewJPanel has no method named getSeglengths with signature ()[D." << std::endl;
           return NULL;
       } else {
           retVal= (jdoubleArray)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewSideViewJPanelClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/SideViewJPanel");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/SideViewJPanel" << std::endl;
       }
       return clss;
   }
   
   static jclass SideViewJPanelClass = NULL;
   static inline jclass getSideViewJPanelClass() {
       if (SideViewJPanelClass != NULL) {
           return SideViewJPanelClass;
       }
       SideViewJPanelClass = getNewSideViewJPanelClass();
   }
   
   // get JNI handle for class crcl.utils.SimulatedKinematicsSimple
   static inline jclass getSimulatedKinematicsSimpleClass();
   
   SimulatedKinematicsSimple::SimulatedKinematicsSimple(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SimulatedKinematicsSimple::SimulatedKinematicsSimple(const SimulatedKinematicsSimple &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SimulatedKinematicsSimple::SimulatedKinematicsSimple() {
    JNIEnv *env =getEnv();
    static jclass cls = getSimulatedKinematicsSimpleClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class SimulatedKinematicsSimple has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SimulatedKinematicsSimple jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.SimulatedKinematicsSimple
   SimulatedKinematicsSimple::~SimulatedKinematicsSimple() {
   	// Place-holder for later extensibility.
   }

   jdouble SimulatedKinematicsSimple::getScale() {

   if(jthis == NULL) {
       std::cerr << "Call of method getScale of crcl.utils.SimulatedKinematicsSimple with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimulatedKinematicsSimple::getScale jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getScale", "()D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimulatedKinematicsSimple has no method named getScale with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimulatedKinematicsSimple::setScale(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setScale of crcl.utils.SimulatedKinematicsSimple with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimulatedKinematicsSimple::setScale jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setScale", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimulatedKinematicsSimple has no method named setScale with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimulatedKinematicsSimple::setSeglengths(jdoubleArray doubleArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setSeglengths of crcl.utils.SimulatedKinematicsSimple with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimulatedKinematicsSimple::setSeglengths jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setSeglengths", "([D)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimulatedKinematicsSimple has no method named setSeglengths with signature ([D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,doubleArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::crcl::base::PoseType SimulatedKinematicsSimple::jointsToPose(jdoubleArray doubleArray_0,::crclj::crcl::base::PoseType  &poseType_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method jointsToPose of crcl.utils.SimulatedKinematicsSimple with jthis == NULL." << std::endl;
       ::crclj::crcl::base::PoseType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimulatedKinematicsSimple::jointsToPose jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "jointsToPose", "([DLcrcl/base/PoseType;)Lcrcl/base/PoseType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimulatedKinematicsSimple has no method named jointsToPose with signature ([DLcrcl/base/PoseType;)Lcrcl/base/PoseType;." << std::endl;
           ::crclj::crcl::base::PoseType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,doubleArray_0,poseType_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PoseType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::PoseType SimulatedKinematicsSimple::jointsToPose(jdoubleArray doubleArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method jointsToPose of crcl.utils.SimulatedKinematicsSimple with jthis == NULL." << std::endl;
       ::crclj::crcl::base::PoseType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimulatedKinematicsSimple::jointsToPose jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "jointsToPose", "([D)Lcrcl/base/PoseType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimulatedKinematicsSimple has no method named jointsToPose with signature ([D)Lcrcl/base/PoseType;." << std::endl;
           ::crclj::crcl::base::PoseType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,doubleArray_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PoseType retObject(retVal,false);
    return retObject;
   }
   jdoubleArray SimulatedKinematicsSimple::getSeglengths() {

   if(jthis == NULL) {
       std::cerr << "Call of method getSeglengths of crcl.utils.SimulatedKinematicsSimple with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimulatedKinematicsSimple::getSeglengths jthis=",jthis);
   jdoubleArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getSeglengths", "()[D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimulatedKinematicsSimple has no method named getSeglengths with signature ()[D." << std::endl;
           return NULL;
       } else {
           retVal= (jdoubleArray)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jdoubleArray SimulatedKinematicsSimple::poseToJoints(jdoubleArray doubleArray_0,::crclj::crcl::base::PoseType  &poseType_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method poseToJoints of crcl.utils.SimulatedKinematicsSimple with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimulatedKinematicsSimple::poseToJoints jthis=",jthis);
   jdoubleArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "poseToJoints", "([DLcrcl/base/PoseType;)[D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimulatedKinematicsSimple has no method named poseToJoints with signature ([DLcrcl/base/PoseType;)[D." << std::endl;
           return NULL;
       } else {
           retVal= (jdoubleArray)  env->CallObjectMethod(jthis, mid ,doubleArray_0,poseType_1.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewSimulatedKinematicsSimpleClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/SimulatedKinematicsSimple");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/SimulatedKinematicsSimple" << std::endl;
       }
       return clss;
   }
   
   static jclass SimulatedKinematicsSimpleClass = NULL;
   static inline jclass getSimulatedKinematicsSimpleClass() {
       if (SimulatedKinematicsSimpleClass != NULL) {
           return SimulatedKinematicsSimpleClass;
       }
       SimulatedKinematicsSimpleClass = getNewSimulatedKinematicsSimpleClass();
   }
   
   // get JNI handle for class crcl.utils.XpathQueryJFrame
   static inline jclass getXpathQueryJFrameClass();
   
   XpathQueryJFrame::XpathQueryJFrame(jobject _jthis, bool copy): ::crclj::javax::swing::JFrame(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   XpathQueryJFrame::XpathQueryJFrame(const XpathQueryJFrame &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   XpathQueryJFrame::XpathQueryJFrame() {
    JNIEnv *env =getEnv();
    static jclass cls = getXpathQueryJFrameClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class XpathQueryJFrame has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new XpathQueryJFrame jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.XpathQueryJFrame
   XpathQueryJFrame::~XpathQueryJFrame() {
   	// Place-holder for later extensibility.
   }

   void XpathQueryJFrame::setQuery(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setQuery of crcl.utils.XpathQueryJFrame with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XpathQueryJFrame::setQuery jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setQuery", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.XpathQueryJFrame has no method named setQuery with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   void XpathQueryJFrame::setResult(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setResult of crcl.utils.XpathQueryJFrame with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XpathQueryJFrame::setResult jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setResult", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.XpathQueryJFrame has no method named setResult with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   void XpathQueryJFrame::Message(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method Message of crcl.utils.XpathQueryJFrame with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XpathQueryJFrame::Message jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "Message", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.XpathQueryJFrame has no method named Message with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   jstring XpathQueryJFrame::runQuery(jstring string_0,jstring string_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method runQuery of crcl.utils.XpathQueryJFrame with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XpathQueryJFrame::runQuery jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "runQuery", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.XpathQueryJFrame has no method named runQuery with signature (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid ,string_0,string_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void XpathQueryJFrame::main(jobjectArray stringArray_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getXpathQueryJFrameClass();
   
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "main", "([Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.XpathQueryJFrame has no method named main with signature ([Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallStaticVoidMethod( cls, mid ,stringArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void XpathQueryJFrame::main(int argc, const char **argv) {
           if(argc <1 || argv==NULL) {
                main(NULL);
           } else {
               JNIEnv *env =getEnv();
               jclass strClss = getStringClass();
               jobjectArray stringArray = env->NewObjectArray(argc,strClss,getEmptyString());
               for(int i = 0; i < argc; i++) {
                   jstring str = env->NewStringUTF(argv[i]);
                   env->SetObjectArrayElement(stringArray,i,str);
               }
                main(stringArray);
               for(int i = 0; i < argc; i++) {
                   jobject str = env->GetObjectArrayElement(stringArray,i);
                   jobjectRefType ref = env->GetObjectRefType(str);
                   if(ref == JNIGlobalRefType) {
                       env->DeleteGlobalRef(str);
                   }
               }
               jobjectRefType ref = env->GetObjectRefType(stringArray);
               if(ref == JNIGlobalRefType) {
                   env->DeleteGlobalRef(stringArray);
               }
               return ;
           }
   }
   jstring XpathQueryJFrame::getQuery() {

   if(jthis == NULL) {
       std::cerr << "Call of method getQuery of crcl.utils.XpathQueryJFrame with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XpathQueryJFrame::getQuery jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getQuery", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.XpathQueryJFrame has no method named getQuery with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring XpathQueryJFrame::getResult() {

   if(jthis == NULL) {
       std::cerr << "Call of method getResult of crcl.utils.XpathQueryJFrame with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XpathQueryJFrame::getResult jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getResult", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.XpathQueryJFrame has no method named getResult with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewXpathQueryJFrameClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/XpathQueryJFrame");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/XpathQueryJFrame" << std::endl;
       }
       return clss;
   }
   
   static jclass XpathQueryJFrameClass = NULL;
   static inline jclass getXpathQueryJFrameClass() {
       if (XpathQueryJFrameClass != NULL) {
           return XpathQueryJFrameClass;
       }
       XpathQueryJFrameClass = getNewXpathQueryJFrameClass();
   }
  } // end namespace utils

   namespace base{
   
   // get JNI handle for class crcl.base.InitCanonType
   static inline jclass getInitCanonTypeClass();
   
   InitCanonType::InitCanonType(jobject _jthis, bool copy): CRCLCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   InitCanonType::InitCanonType(const InitCanonType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   InitCanonType::InitCanonType() {
    JNIEnv *env =getEnv();
    static jclass cls = getInitCanonTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class InitCanonType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new InitCanonType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.InitCanonType
   InitCanonType::~InitCanonType() {
   	// Place-holder for later extensibility.
   }

   static jclass getNewInitCanonTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/InitCanonType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/InitCanonType" << std::endl;
       }
       return clss;
   }
   
   static jclass InitCanonTypeClass = NULL;
   static inline jclass getInitCanonTypeClass() {
       if (InitCanonTypeClass != NULL) {
           return InitCanonTypeClass;
       }
       InitCanonTypeClass = getNewInitCanonTypeClass();
   }
   
   // get JNI handle for class crcl.base.JointStatusesType
   static inline jclass getJointStatusesTypeClass();
   
   JointStatusesType::JointStatusesType(jobject _jthis, bool copy): DataThingType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   JointStatusesType::JointStatusesType(const JointStatusesType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   JointStatusesType::JointStatusesType() {
    JNIEnv *env =getEnv();
    static jclass cls = getJointStatusesTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class JointStatusesType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new JointStatusesType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.JointStatusesType
   JointStatusesType::~JointStatusesType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::util::List JointStatusesType::getJointStatus() {

   if(jthis == NULL) {
       std::cerr << "Call of method getJointStatus of crcl.base.JointStatusesType with jthis == NULL." << std::endl;
       ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JointStatusesType::getJointStatus jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getJointStatus", "()Ljava/util/List;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.JointStatusesType has no method named getJointStatus with signature ()Ljava/util/List;." << std::endl;
           ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::util::List retObject(retVal,false);
    return retObject;
   }
   static jclass getNewJointStatusesTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/JointStatusesType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/JointStatusesType" << std::endl;
       }
       return clss;
   }
   
   static jclass JointStatusesTypeClass = NULL;
   static inline jclass getJointStatusesTypeClass() {
       if (JointStatusesTypeClass != NULL) {
           return JointStatusesTypeClass;
       }
       JointStatusesTypeClass = getNewJointStatusesTypeClass();
   }
   
   // get JNI handle for class crcl.base.JointStatusType
   static inline jclass getJointStatusTypeClass();
   
   JointStatusType::JointStatusType(jobject _jthis, bool copy): DataThingType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   JointStatusType::JointStatusType(const JointStatusType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   JointStatusType::JointStatusType() {
    JNIEnv *env =getEnv();
    static jclass cls = getJointStatusTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class JointStatusType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new JointStatusType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.JointStatusType
   JointStatusType::~JointStatusType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::math::BigInteger JointStatusType::getJointNumber() {

   if(jthis == NULL) {
       std::cerr << "Call of method getJointNumber of crcl.base.JointStatusType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JointStatusType::getJointNumber jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getJointNumber", "()Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.JointStatusType has no method named getJointNumber with signature ()Ljava/math/BigInteger;." << std::endl;
           ::crclj::java::math::BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigInteger retObject(retVal,false);
    return retObject;
   }
   ::crclj::java::math::BigDecimal JointStatusType::getJointPosition() {

   if(jthis == NULL) {
       std::cerr << "Call of method getJointPosition of crcl.base.JointStatusType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JointStatusType::getJointPosition jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getJointPosition", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.JointStatusType has no method named getJointPosition with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   ::crclj::java::math::BigDecimal JointStatusType::getJointVelocity() {

   if(jthis == NULL) {
       std::cerr << "Call of method getJointVelocity of crcl.base.JointStatusType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JointStatusType::getJointVelocity jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getJointVelocity", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.JointStatusType has no method named getJointVelocity with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   ::crclj::java::math::BigDecimal JointStatusType::getJointTorqueOrForce() {

   if(jthis == NULL) {
       std::cerr << "Call of method getJointTorqueOrForce of crcl.base.JointStatusType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JointStatusType::getJointTorqueOrForce jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getJointTorqueOrForce", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.JointStatusType has no method named getJointTorqueOrForce with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void JointStatusType::setJointNumber(::crclj::java::math::BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setJointNumber of crcl.base.JointStatusType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JointStatusType::setJointNumber jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setJointNumber", "(Ljava/math/BigInteger;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.JointStatusType has no method named setJointNumber with signature (Ljava/math/BigInteger;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void JointStatusType::setJointPosition(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setJointPosition of crcl.base.JointStatusType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JointStatusType::setJointPosition jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setJointPosition", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.JointStatusType has no method named setJointPosition with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void JointStatusType::setJointTorqueOrForce(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setJointTorqueOrForce of crcl.base.JointStatusType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JointStatusType::setJointTorqueOrForce jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setJointTorqueOrForce", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.JointStatusType has no method named setJointTorqueOrForce with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void JointStatusType::setJointVelocity(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setJointVelocity of crcl.base.JointStatusType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JointStatusType::setJointVelocity jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setJointVelocity", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.JointStatusType has no method named setJointVelocity with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewJointStatusTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/JointStatusType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/JointStatusType" << std::endl;
       }
       return clss;
   }
   
   static jclass JointStatusTypeClass = NULL;
   static inline jclass getJointStatusTypeClass() {
       if (JointStatusTypeClass != NULL) {
           return JointStatusTypeClass;
       }
       JointStatusTypeClass = getNewJointStatusTypeClass();
   }
   
   // get JNI handle for class crcl.base.MoveThroughToType
   static inline jclass getMoveThroughToTypeClass();
   
   MoveThroughToType::MoveThroughToType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   MoveThroughToType::MoveThroughToType(const MoveThroughToType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   MoveThroughToType::MoveThroughToType() {
    JNIEnv *env =getEnv();
    static jclass cls = getMoveThroughToTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class MoveThroughToType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new MoveThroughToType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.MoveThroughToType
   MoveThroughToType::~MoveThroughToType() {
   	// Place-holder for later extensibility.
   }

   jboolean MoveThroughToType::isMoveStraight() {

   if(jthis == NULL) {
       std::cerr << "Call of method isMoveStraight of crcl.base.MoveThroughToType with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MoveThroughToType::isMoveStraight jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isMoveStraight", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MoveThroughToType has no method named isMoveStraight with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void MoveThroughToType::setMoveStraight(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setMoveStraight of crcl.base.MoveThroughToType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MoveThroughToType::setMoveStraight jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setMoveStraight", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MoveThroughToType has no method named setMoveStraight with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::util::List MoveThroughToType::getWaypoint() {

   if(jthis == NULL) {
       std::cerr << "Call of method getWaypoint of crcl.base.MoveThroughToType with jthis == NULL." << std::endl;
       ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MoveThroughToType::getWaypoint jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getWaypoint", "()Ljava/util/List;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MoveThroughToType has no method named getWaypoint with signature ()Ljava/util/List;." << std::endl;
           ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::util::List retObject(retVal,false);
    return retObject;
   }
   ::crclj::java::math::BigInteger MoveThroughToType::getNumPositions() {

   if(jthis == NULL) {
       std::cerr << "Call of method getNumPositions of crcl.base.MoveThroughToType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MoveThroughToType::getNumPositions jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getNumPositions", "()Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MoveThroughToType has no method named getNumPositions with signature ()Ljava/math/BigInteger;." << std::endl;
           ::crclj::java::math::BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigInteger retObject(retVal,false);
    return retObject;
   }
   void MoveThroughToType::setNumPositions(::crclj::java::math::BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setNumPositions of crcl.base.MoveThroughToType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," MoveThroughToType::setNumPositions jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setNumPositions", "(Ljava/math/BigInteger;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.MoveThroughToType has no method named setNumPositions with signature (Ljava/math/BigInteger;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewMoveThroughToTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/MoveThroughToType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/MoveThroughToType" << std::endl;
       }
       return clss;
   }
   
   static jclass MoveThroughToTypeClass = NULL;
   static inline jclass getMoveThroughToTypeClass() {
       if (MoveThroughToTypeClass != NULL) {
           return MoveThroughToTypeClass;
       }
       MoveThroughToTypeClass = getNewMoveThroughToTypeClass();
   }
   
   // get JNI handle for class crcl.base.StopConditionEnumType
   static inline jclass getStopConditionEnumTypeClass();
   
   StopConditionEnumType::StopConditionEnumType(jobject _jthis, bool copy): ::crclj::java::lang::Enum(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   StopConditionEnumType::StopConditionEnumType(const StopConditionEnumType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }

   // Destructor for crcl.base.StopConditionEnumType
   StopConditionEnumType::~StopConditionEnumType() {
   	// Place-holder for later extensibility.
   }

   StopConditionEnumType StopConditionEnumType::fromValue(jstring string_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getStopConditionEnumTypeClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "fromValue", "(Ljava/lang/String;)Lcrcl/base/StopConditionEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.StopConditionEnumType has no method named fromValue with signature (Ljava/lang/String;)Lcrcl/base/StopConditionEnumType;." << std::endl;
           StopConditionEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,string_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    StopConditionEnumType retObject(retVal,false);
    return retObject;
   }
   jstring StopConditionEnumType::value() {

   if(jthis == NULL) {
       std::cerr << "Call of method value of crcl.base.StopConditionEnumType with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," StopConditionEnumType::value jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "value", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.StopConditionEnumType has no method named value with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jobjectArray StopConditionEnumType::values() {

   JNIEnv *env =getEnv();
   static jclass cls = getStopConditionEnumTypeClass();
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "values", "()[Lcrcl/base/StopConditionEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.StopConditionEnumType has no method named values with signature ()[Lcrcl/base/StopConditionEnumType;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallStaticObjectMethod( cls, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   StopConditionEnumType StopConditionEnumType::valueOf(jstring string_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getStopConditionEnumTypeClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "valueOf", "(Ljava/lang/String;)Lcrcl/base/StopConditionEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.StopConditionEnumType has no method named valueOf with signature (Ljava/lang/String;)Lcrcl/base/StopConditionEnumType;." << std::endl;
           StopConditionEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,string_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    StopConditionEnumType retObject(retVal,false);
    return retObject;
   }
   static jclass getNewStopConditionEnumTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/StopConditionEnumType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/StopConditionEnumType" << std::endl;
       }
       return clss;
   }
   
   static jclass StopConditionEnumTypeClass = NULL;
   static inline jclass getStopConditionEnumTypeClass() {
       if (StopConditionEnumTypeClass != NULL) {
           return StopConditionEnumTypeClass;
       }
       StopConditionEnumTypeClass = getNewStopConditionEnumTypeClass();
   }
  } // end namespace base

   namespace utils{
   
   // get JNI handle for class crcl.utils.TestInstance
   static inline jclass getTestInstanceClass();
   
   TestInstance::TestInstance(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   TestInstance::TestInstance(const TestInstance &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   TestInstance::TestInstance() {
    JNIEnv *env =getEnv();
    static jclass cls = getTestInstanceClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class TestInstance has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new TestInstance jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.TestInstance
   TestInstance::~TestInstance() {
   	// Place-holder for later extensibility.
   }

   void TestInstance::main(jobjectArray stringArray_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getTestInstanceClass();
   
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "main", "([Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.TestInstance has no method named main with signature ([Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallStaticVoidMethod( cls, mid ,stringArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void TestInstance::main(int argc, const char **argv) {
           if(argc <1 || argv==NULL) {
                main(NULL);
           } else {
               JNIEnv *env =getEnv();
               jclass strClss = getStringClass();
               jobjectArray stringArray = env->NewObjectArray(argc,strClss,getEmptyString());
               for(int i = 0; i < argc; i++) {
                   jstring str = env->NewStringUTF(argv[i]);
                   env->SetObjectArrayElement(stringArray,i,str);
               }
                main(stringArray);
               for(int i = 0; i < argc; i++) {
                   jobject str = env->GetObjectArrayElement(stringArray,i);
                   jobjectRefType ref = env->GetObjectRefType(str);
                   if(ref == JNIGlobalRefType) {
                       env->DeleteGlobalRef(str);
                   }
               }
               jobjectRefType ref = env->GetObjectRefType(stringArray);
               if(ref == JNIGlobalRefType) {
                   env->DeleteGlobalRef(stringArray);
               }
               return ;
           }
   }
   static jclass getNewTestInstanceClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/TestInstance");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/TestInstance" << std::endl;
       }
       return clss;
   }
   
   static jclass TestInstanceClass = NULL;
   static inline jclass getTestInstanceClass() {
       if (TestInstanceClass != NULL) {
           return TestInstanceClass;
       }
       TestInstanceClass = getNewTestInstanceClass();
   }
   
   // get JNI handle for class crcl.utils.SimServer
   static inline jclass getSimServerClass();
   
   SimServer::SimServer(jobject _jthis, bool copy): ::crclj::javax::swing::JFrame(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   SimServer::SimServer(const SimServer &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   SimServer::SimServer() {
    JNIEnv *env =getEnv();
    static jclass cls = getSimServerClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class SimServer has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SimServer jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.SimServer
   SimServer::~SimServer() {
   	// Place-holder for later extensibility.
   }

   void SimServer::showMessage(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method showMessage of crcl.utils.SimServer with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::showMessage jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "showMessage", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named showMessage with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimServer::showMessage(::crclj::java::lang::Throwable  &throwable_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method showMessage of crcl.utils.SimServer with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::showMessage jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "showMessage", "(Ljava/lang/Throwable;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named showMessage with signature (Ljava/lang/Throwable;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,throwable_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void SimServer::showDebugMessage(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method showDebugMessage of crcl.utils.SimServer with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::showDebugMessage jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "showDebugMessage", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named showDebugMessage with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean SimServer::isEXISelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isEXISelected of crcl.utils.SimServer with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::isEXISelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isEXISelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named isEXISelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   ::crclj::crcl::base::CommandStateEnumType SimServer::getCommandState() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCommandState of crcl.utils.SimServer with jthis == NULL." << std::endl;
       ::crclj::crcl::base::CommandStateEnumType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::getCommandState jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCommandState", "()Lcrcl/base/CommandStateEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named getCommandState with signature ()Lcrcl/base/CommandStateEnumType;." << std::endl;
           ::crclj::crcl::base::CommandStateEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::CommandStateEnumType retObject(retVal,false);
    return retObject;
   }
   void SimServer::setCommandState(::crclj::crcl::base::CommandStateEnumType  &commandStateEnumType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCommandState of crcl.utils.SimServer with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::setCommandState jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCommandState", "(Lcrcl/base/CommandStateEnumType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named setCommandState with signature (Lcrcl/base/CommandStateEnumType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,commandStateEnumType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   jboolean SimServer::isToolChangerOpen() {

   if(jthis == NULL) {
       std::cerr << "Call of method isToolChangerOpen of crcl.utils.SimServer with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::isToolChangerOpen jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isToolChangerOpen", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named isToolChangerOpen with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServer::setToolChangerOpen(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setToolChangerOpen of crcl.utils.SimServer with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::setToolChangerOpen jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setToolChangerOpen", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named setToolChangerOpen with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean SimServer::checkStatusValid(::crclj::crcl::base::CRCLStatusType  &cRCLStatusType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method checkStatusValid of crcl.utils.SimServer with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::checkStatusValid jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "checkStatusValid", "(Lcrcl/base/CRCLStatusType;)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named checkStatusValid with signature (Lcrcl/base/CRCLStatusType;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,cRCLStatusType_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean SimServer::isSendStatusWithoutRequestSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isSendStatusWithoutRequestSelected of crcl.utils.SimServer with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::isSendStatusWithoutRequestSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isSendStatusWithoutRequestSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named isSendStatusWithoutRequestSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServer::updateConnectedClients(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method updateConnectedClients of crcl.utils.SimServer with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::updateConnectedClients jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updateConnectedClients", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named updateConnectedClients with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean SimServer::isValidateXMLSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isValidateXMLSelected of crcl.utils.SimServer with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::isValidateXMLSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isValidateXMLSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named isValidateXMLSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean SimServer::isAppendZeroSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isAppendZeroSelected of crcl.utils.SimServer with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::isAppendZeroSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isAppendZeroSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named isAppendZeroSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean SimServer::isRandomPacketSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isRandomPacketSelected of crcl.utils.SimServer with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::isRandomPacketSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isRandomPacketSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named isRandomPacketSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean SimServer::isReplaceStateSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isReplaceStateSelected of crcl.utils.SimServer with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::isReplaceStateSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isReplaceStateSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named isReplaceStateSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean SimServer::isEditingStatus() {

   if(jthis == NULL) {
       std::cerr << "Call of method isEditingStatus of crcl.utils.SimServer with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::isEditingStatus jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isEditingStatus", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named isEditingStatus with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServer::updateCycleCount(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method updateCycleCount of crcl.utils.SimServer with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::updateCycleCount jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updateCycleCount", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named updateCycleCount with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimServer::updatePanels(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method updatePanels of crcl.utils.SimServer with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::updatePanels jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updatePanels", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named updatePanels with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimServer::updateIsInitialized(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method updateIsInitialized of crcl.utils.SimServer with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::updateIsInitialized jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updateIsInitialized", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named updateIsInitialized with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimServer::updateCurrentCommandType(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method updateCurrentCommandType of crcl.utils.SimServer with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::updateCurrentCommandType jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updateCurrentCommandType", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named updateCurrentCommandType with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimServer::updateEndEffector(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method updateEndEffector of crcl.utils.SimServer with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::updateEndEffector jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updateEndEffector", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named updateEndEffector with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimServer::updateToolChangerIsOpen(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method updateToolChangerIsOpen of crcl.utils.SimServer with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::updateToolChangerIsOpen jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updateToolChangerIsOpen", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named updateToolChangerIsOpen with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean SimServer::isInitializedSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isInitializedSelected of crcl.utils.SimServer with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::isInitializedSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isInitializedSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named isInitializedSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServer::finishSetCurrentWaypoint(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method finishSetCurrentWaypoint of crcl.utils.SimServer with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::finishSetCurrentWaypoint jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "finishSetCurrentWaypoint", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named finishSetCurrentWaypoint with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimServer::updateLengthUnit(::crclj::crcl::base::LengthUnitEnumType  &lengthUnitEnumType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method updateLengthUnit of crcl.utils.SimServer with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::updateLengthUnit jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updateLengthUnit", "(Lcrcl/base/LengthUnitEnumType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named updateLengthUnit with signature (Lcrcl/base/LengthUnitEnumType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,lengthUnitEnumType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void SimServer::updateNumWaypoints(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method updateNumWaypoints of crcl.utils.SimServer with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::updateNumWaypoints jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "updateNumWaypoints", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named updateNumWaypoints with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean SimServer::isDebugMoveDoneSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isDebugMoveDoneSelected of crcl.utils.SimServer with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::isDebugMoveDoneSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isDebugMoveDoneSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named isDebugMoveDoneSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean SimServer::isDebugSendStatusSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isDebugSendStatusSelected of crcl.utils.SimServer with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::isDebugSendStatusSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isDebugSendStatusSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named isDebugSendStatusSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean SimServer::isDebugReadCommandSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isDebugReadCommandSelected of crcl.utils.SimServer with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::isDebugReadCommandSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isDebugReadCommandSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named isDebugReadCommandSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean SimServer::isReplaceXmlHeaderSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isReplaceXmlHeaderSelected of crcl.utils.SimServer with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::isReplaceXmlHeaderSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isReplaceXmlHeaderSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named isReplaceXmlHeaderSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean SimServer::checkPose(::crclj::crcl::base::PoseType  &poseType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method checkPose of crcl.utils.SimServer with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SimServer::checkPose jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "checkPose", "(Lcrcl/base/PoseType;)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named checkPose with signature (Lcrcl/base/PoseType;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,poseType_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void SimServer::main(jobjectArray stringArray_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getSimServerClass();
   
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "main", "([Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.SimServer has no method named main with signature ([Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallStaticVoidMethod( cls, mid ,stringArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void SimServer::main(int argc, const char **argv) {
           if(argc <1 || argv==NULL) {
                main(NULL);
           } else {
               JNIEnv *env =getEnv();
               jclass strClss = getStringClass();
               jobjectArray stringArray = env->NewObjectArray(argc,strClss,getEmptyString());
               for(int i = 0; i < argc; i++) {
                   jstring str = env->NewStringUTF(argv[i]);
                   env->SetObjectArrayElement(stringArray,i,str);
               }
                main(stringArray);
               for(int i = 0; i < argc; i++) {
                   jobject str = env->GetObjectArrayElement(stringArray,i);
                   jobjectRefType ref = env->GetObjectRefType(str);
                   if(ref == JNIGlobalRefType) {
                       env->DeleteGlobalRef(str);
                   }
               }
               jobjectRefType ref = env->GetObjectRefType(stringArray);
               if(ref == JNIGlobalRefType) {
                   env->DeleteGlobalRef(stringArray);
               }
               return ;
           }
   }
   static jclass getNewSimServerClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/SimServer");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/SimServer" << std::endl;
       }
       return clss;
   }
   
   static jclass SimServerClass = NULL;
   static inline jclass getSimServerClass() {
       if (SimServerClass != NULL) {
           return SimServerClass;
       }
       SimServerClass = getNewSimServerClass();
   }
   
   // get JNI handle for class crcl.utils.CmdLineSimServer
   static inline jclass getCmdLineSimServerClass();
   
   CmdLineSimServer::CmdLineSimServer(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   CmdLineSimServer::CmdLineSimServer(const CmdLineSimServer &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   CmdLineSimServer::CmdLineSimServer() {
    JNIEnv *env =getEnv();
    static jclass cls = getCmdLineSimServerClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class CmdLineSimServer has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new CmdLineSimServer jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.CmdLineSimServer
   CmdLineSimServer::~CmdLineSimServer() {
   	// Place-holder for later extensibility.
   }

   void CmdLineSimServer::main(jobjectArray stringArray_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCmdLineSimServerClass();
   
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "main", "([Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CmdLineSimServer has no method named main with signature ([Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallStaticVoidMethod( cls, mid ,stringArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void CmdLineSimServer::main(int argc, const char **argv) {
           if(argc <1 || argv==NULL) {
                main(NULL);
           } else {
               JNIEnv *env =getEnv();
               jclass strClss = getStringClass();
               jobjectArray stringArray = env->NewObjectArray(argc,strClss,getEmptyString());
               for(int i = 0; i < argc; i++) {
                   jstring str = env->NewStringUTF(argv[i]);
                   env->SetObjectArrayElement(stringArray,i,str);
               }
                main(stringArray);
               for(int i = 0; i < argc; i++) {
                   jobject str = env->GetObjectArrayElement(stringArray,i);
                   jobjectRefType ref = env->GetObjectRefType(str);
                   if(ref == JNIGlobalRefType) {
                       env->DeleteGlobalRef(str);
                   }
               }
               jobjectRefType ref = env->GetObjectRefType(stringArray);
               if(ref == JNIGlobalRefType) {
                   env->DeleteGlobalRef(stringArray);
               }
               return ;
           }
   }
   static jclass getNewCmdLineSimServerClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/CmdLineSimServer");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/CmdLineSimServer" << std::endl;
       }
       return clss;
   }
   
   static jclass CmdLineSimServerClass = NULL;
   static inline jclass getCmdLineSimServerClass() {
       if (CmdLineSimServerClass != NULL) {
           return CmdLineSimServerClass;
       }
       CmdLineSimServerClass = getNewCmdLineSimServerClass();
   }
  } // end namespace utils
 } // end namespace crcl

  namespace rcs{
   namespace posemath{
   
   // get JNI handle for class rcs.posemath.PmPose
   static inline jclass getPmPoseClass();
   
   PmPose::PmPose(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   PmPose::PmPose(const PmPose &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   PmPose::PmPose(jdouble double_0,jdouble double_1,jdouble double_2,jdouble double_3,jdouble double_4,jdouble double_5,jdouble double_6) {
    JNIEnv *env =getEnv();
    static jclass cls = getPmPoseClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(DDDDDDD)V");
        if (NULL == mid) {
            std::cerr << "Class PmPose has no method constructor signature (DDDDDDD)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,double_0,double_1,double_2,double_3,double_4,double_5,double_6);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PmPose jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PmPose::PmPose() {
    JNIEnv *env =getEnv();
    static jclass cls = getPmPoseClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class PmPose has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PmPose jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PmPose::PmPose(PmCartesian  &pmCartesian_0,PmQuaternion  &pmQuaternion_1) {
    JNIEnv *env =getEnv();
    static jclass cls = getPmPoseClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Lrcs/posemath/PmCartesian;Lrcs/posemath/PmQuaternion;)V");
        if (NULL == mid) {
            std::cerr << "Class PmPose has no method constructor signature (Lrcs/posemath/PmCartesian;Lrcs/posemath/PmQuaternion;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,pmCartesian_0.jthis,pmQuaternion_1.jthis);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PmPose jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PmPose::PmPose(PmCartesian  &pmCartesian_0,PmRpy  &pmRpy_1) {
    JNIEnv *env =getEnv();
    static jclass cls = getPmPoseClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Lrcs/posemath/PmCartesian;Lrcs/posemath/PmRpy;)V");
        if (NULL == mid) {
            std::cerr << "Class PmPose has no method constructor signature (Lrcs/posemath/PmCartesian;Lrcs/posemath/PmRpy;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,pmCartesian_0.jthis,pmRpy_1.jthis);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PmPose jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for rcs.posemath.PmPose
   PmPose::~PmPose() {
   	// Place-holder for later extensibility.
   }

   jfloatArray PmPose::toMatFloatArrayTranspose() {

   if(jthis == NULL) {
       std::cerr << "Call of method toMatFloatArrayTranspose of rcs.posemath.PmPose with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmPose::toMatFloatArrayTranspose jthis=",jthis);
   jfloatArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toMatFloatArrayTranspose", "()[F");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmPose has no method named toMatFloatArrayTranspose with signature ()[F." << std::endl;
           return NULL;
       } else {
           retVal= (jfloatArray)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PmPose::equals(PmPose  &pmPose_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method equals of rcs.posemath.PmPose with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmPose::equals jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "equals", "(Lrcs/posemath/PmPose;)Z");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmPose has no method named equals with signature (Lrcs/posemath/PmPose;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,pmPose_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring PmPose::toString() {

   if(jthis == NULL) {
       std::cerr << "Call of method toString of rcs.posemath.PmPose with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmPose::toString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toString", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmPose has no method named toString with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   PmPose PmPose::clone() {

   if(jthis == NULL) {
       std::cerr << "Call of method clone of rcs.posemath.PmPose with jthis == NULL." << std::endl;
       PmPose nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmPose::clone jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "clone", "()Lrcs/posemath/PmPose;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmPose has no method named clone with signature ()Lrcs/posemath/PmPose;." << std::endl;
           PmPose nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PmPose retObject(retVal,false);
    return retObject;
   }
   static jclass getNewPmPoseClass() {
       jclass clss = getEnv()->FindClass("rcs/posemath/PmPose");
       if (NULL == clss) {
           std::cerr << " Can't find class rcs/posemath/PmPose" << std::endl;
       }
       return clss;
   }
   
   static jclass PmPoseClass = NULL;
   static inline jclass getPmPoseClass() {
       if (PmPoseClass != NULL) {
           return PmPoseClass;
       }
       PmPoseClass = getNewPmPoseClass();
   }
  } // end namespace posemath
 } // end namespace rcs

  namespace crcl{
   namespace utils{
   
   // get JNI handle for class crcl.utils.AnnotatedPose
   static inline jclass getAnnotatedPoseClass();
   
   AnnotatedPose::AnnotatedPose(jobject _jthis, bool copy): ::crclj::rcs::posemath::PmPose(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   AnnotatedPose::AnnotatedPose(const AnnotatedPose &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   AnnotatedPose::AnnotatedPose(jlong long_0,::crclj::java::math::BigInteger  &bigInteger_1,jstring string_2,::crclj::rcs::posemath::PmCartesian  &pmCartesian_3,::crclj::rcs::posemath::PmQuaternion  &pmQuaternion_4,::crclj::crcl::base::CRCLStatusType  &cRCLStatusType_5) {
    JNIEnv *env =getEnv();
    static jclass cls = getAnnotatedPoseClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(JLjava/math/BigInteger;Ljava/lang/String;Lrcs/posemath/PmCartesian;Lrcs/posemath/PmQuaternion;Lcrcl/base/CRCLStatusType;)V");
        if (NULL == mid) {
            std::cerr << "Class AnnotatedPose has no method constructor signature (JLjava/math/BigInteger;Ljava/lang/String;Lrcs/posemath/PmCartesian;Lrcs/posemath/PmQuaternion;Lcrcl/base/CRCLStatusType;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,long_0,bigInteger_1.jthis,string_2,pmCartesian_3.jthis,pmQuaternion_4.jthis,cRCLStatusType_5.jthis);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new AnnotatedPose jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.AnnotatedPose
   AnnotatedPose::~AnnotatedPose() {
   	// Place-holder for later extensibility.
   }

   jlong AnnotatedPose::getTime() {

   if(jthis == NULL) {
       std::cerr << "Call of method getTime of crcl.utils.AnnotatedPose with jthis == NULL." << std::endl;
       return (jlong) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," AnnotatedPose::getTime jthis=",jthis);
   jlong retVal= (jlong) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getTime", "()J");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.AnnotatedPose has no method named getTime with signature ()J." << std::endl;
           return (jlong) -1;
       } else {
           retVal= (jlong)  env->CallLongMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   ::crclj::crcl::base::CRCLStatusType AnnotatedPose::getStatus() {

   if(jthis == NULL) {
       std::cerr << "Call of method getStatus of crcl.utils.AnnotatedPose with jthis == NULL." << std::endl;
       ::crclj::crcl::base::CRCLStatusType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," AnnotatedPose::getStatus jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getStatus", "()Lcrcl/base/CRCLStatusType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.AnnotatedPose has no method named getStatus with signature ()Lcrcl/base/CRCLStatusType;." << std::endl;
           ::crclj::crcl::base::CRCLStatusType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::CRCLStatusType retObject(retVal,false);
    return retObject;
   }
   ::crclj::java::math::BigInteger AnnotatedPose::getCmdId() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCmdId of crcl.utils.AnnotatedPose with jthis == NULL." << std::endl;
       ::crclj::java::math::BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," AnnotatedPose::getCmdId jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCmdId", "()Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.AnnotatedPose has no method named getCmdId with signature ()Ljava/math/BigInteger;." << std::endl;
           ::crclj::java::math::BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigInteger retObject(retVal,false);
    return retObject;
   }
   jstring AnnotatedPose::getCommandName() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCommandName of crcl.utils.AnnotatedPose with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," AnnotatedPose::getCommandName jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCommandName", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.AnnotatedPose has no method named getCommandName with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   ::crclj::rcs::posemath::PmCartesian AnnotatedPose::getTran() {

   if(jthis == NULL) {
       std::cerr << "Call of method getTran of crcl.utils.AnnotatedPose with jthis == NULL." << std::endl;
       ::crclj::rcs::posemath::PmCartesian nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," AnnotatedPose::getTran jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getTran", "()Lrcs/posemath/PmCartesian;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.AnnotatedPose has no method named getTran with signature ()Lrcs/posemath/PmCartesian;." << std::endl;
           ::crclj::rcs::posemath::PmCartesian nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::rcs::posemath::PmCartesian retObject(retVal,false);
    return retObject;
   }
   ::crclj::rcs::posemath::PmQuaternion AnnotatedPose::getRot() {

   if(jthis == NULL) {
       std::cerr << "Call of method getRot of crcl.utils.AnnotatedPose with jthis == NULL." << std::endl;
       ::crclj::rcs::posemath::PmQuaternion nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," AnnotatedPose::getRot jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getRot", "()Lrcs/posemath/PmQuaternion;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.AnnotatedPose has no method named getRot with signature ()Lrcs/posemath/PmQuaternion;." << std::endl;
           ::crclj::rcs::posemath::PmQuaternion nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::rcs::posemath::PmQuaternion retObject(retVal,false);
    return retObject;
   }
   static jclass getNewAnnotatedPoseClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/AnnotatedPose");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/AnnotatedPose" << std::endl;
       }
       return clss;
   }
   
   static jclass AnnotatedPoseClass = NULL;
   static inline jclass getAnnotatedPoseClass() {
       if (AnnotatedPoseClass != NULL) {
           return AnnotatedPoseClass;
       }
       AnnotatedPoseClass = getNewAnnotatedPoseClass();
   }
   
   // get JNI handle for class crcl.utils.CRCLSocket
   static inline jclass getCRCLSocketClass();
   
   CRCLSocket::CRCLSocket(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   CRCLSocket::CRCLSocket(const CRCLSocket &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   CRCLSocket::CRCLSocket(jstring string_0,jint int_1) {
    JNIEnv *env =getEnv();
    static jclass cls = getCRCLSocketClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/lang/String;I)V");
        if (NULL == mid) {
            std::cerr << "Class CRCLSocket has no method constructor signature (Ljava/lang/String;I)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,string_0,int_1);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new CRCLSocket jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.CRCLSocket
   CRCLSocket::~CRCLSocket() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::net::InetAddress CRCLSocket::getInetAddress() {

   if(jthis == NULL) {
       std::cerr << "Call of method getInetAddress of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       ::crclj::java::net::InetAddress nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::getInetAddress jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getInetAddress", "()Ljava/net/InetAddress;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named getInetAddress with signature ()Ljava/net/InetAddress;." << std::endl;
           ::crclj::java::net::InetAddress nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::net::InetAddress retObject(retVal,false);
    return retObject;
   }
   jboolean CRCLSocket::isConnected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isConnected of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::isConnected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isConnected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named isConnected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint CRCLSocket::getLocalPort() {

   if(jthis == NULL) {
       std::cerr << "Call of method getLocalPort of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::getLocalPort jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getLocalPort", "()I");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named getLocalPort with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   ::crclj::java::util::function::UnaryOperator CRCLSocket::getStatusStringInputFilter() {

   if(jthis == NULL) {
       std::cerr << "Call of method getStatusStringInputFilter of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       ::crclj::java::util::function::UnaryOperator nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::getStatusStringInputFilter jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getStatusStringInputFilter", "()Ljava/util/function/UnaryOperator;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named getStatusStringInputFilter with signature ()Ljava/util/function/UnaryOperator;." << std::endl;
           ::crclj::java::util::function::UnaryOperator nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::util::function::UnaryOperator retObject(retVal,false);
    return retObject;
   }
   void CRCLSocket::setStatusStringInputFilter(::crclj::java::util::function::UnaryOperator  &unaryOperator_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setStatusStringInputFilter of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::setStatusStringInputFilter jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setStatusStringInputFilter", "(Ljava/util/function/UnaryOperator;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named setStatusStringInputFilter with signature (Ljava/util/function/UnaryOperator;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,unaryOperator_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::util::function::UnaryOperator CRCLSocket::getStatusStringOutputFilter() {

   if(jthis == NULL) {
       std::cerr << "Call of method getStatusStringOutputFilter of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       ::crclj::java::util::function::UnaryOperator nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::getStatusStringOutputFilter jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getStatusStringOutputFilter", "()Ljava/util/function/UnaryOperator;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named getStatusStringOutputFilter with signature ()Ljava/util/function/UnaryOperator;." << std::endl;
           ::crclj::java::util::function::UnaryOperator nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::util::function::UnaryOperator retObject(retVal,false);
    return retObject;
   }
   void CRCLSocket::setStatusStringOutputFilter(::crclj::java::util::function::UnaryOperator  &unaryOperator_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setStatusStringOutputFilter of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::setStatusStringOutputFilter jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setStatusStringOutputFilter", "(Ljava/util/function/UnaryOperator;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named setStatusStringOutputFilter with signature (Ljava/util/function/UnaryOperator;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,unaryOperator_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   jboolean CRCLSocket::isJaxbFragment() {

   if(jthis == NULL) {
       std::cerr << "Call of method isJaxbFragment of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::isJaxbFragment jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isJaxbFragment", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named isJaxbFragment with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void CRCLSocket::setJaxbFragment(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setJaxbFragment of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::setJaxbFragment jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setJaxbFragment", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named setJaxbFragment with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jstring CRCLSocket::getLastStatusString() {

   if(jthis == NULL) {
       std::cerr << "Call of method getLastStatusString of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::getLastStatusString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getLastStatusString", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named getLastStatusString with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring CRCLSocket::getLastCommandString() {

   if(jthis == NULL) {
       std::cerr << "Call of method getLastCommandString of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::getLastCommandString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getLastCommandString", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named getLastCommandString with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   ::crclj::javax::xml::validation::Schema CRCLSocket::getProgramSchema() {

   if(jthis == NULL) {
       std::cerr << "Call of method getProgramSchema of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       ::crclj::javax::xml::validation::Schema nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::getProgramSchema jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getProgramSchema", "()Ljavax/xml/validation/Schema;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named getProgramSchema with signature ()Ljavax/xml/validation/Schema;." << std::endl;
           ::crclj::javax::xml::validation::Schema nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::javax::xml::validation::Schema retObject(retVal,false);
    return retObject;
   }
   void CRCLSocket::setProgramSchema(::crclj::javax::xml::validation::Schema  &schema_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setProgramSchema of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::setProgramSchema jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setProgramSchema", "(Ljavax/xml/validation/Schema;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named setProgramSchema with signature (Ljavax/xml/validation/Schema;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,schema_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::javax::xml::validation::Schema CRCLSocket::getCmdSchema() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCmdSchema of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       ::crclj::javax::xml::validation::Schema nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::getCmdSchema jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCmdSchema", "()Ljavax/xml/validation/Schema;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named getCmdSchema with signature ()Ljavax/xml/validation/Schema;." << std::endl;
           ::crclj::javax::xml::validation::Schema nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::javax::xml::validation::Schema retObject(retVal,false);
    return retObject;
   }
   void CRCLSocket::setCmdSchema(::crclj::javax::xml::validation::Schema  &schema_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCmdSchema of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::setCmdSchema jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCmdSchema", "(Ljavax/xml/validation/Schema;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named setCmdSchema with signature (Ljavax/xml/validation/Schema;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,schema_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::javax::xml::validation::Schema CRCLSocket::getStatSchema() {

   if(jthis == NULL) {
       std::cerr << "Call of method getStatSchema of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       ::crclj::javax::xml::validation::Schema nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::getStatSchema jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getStatSchema", "()Ljavax/xml/validation/Schema;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named getStatSchema with signature ()Ljavax/xml/validation/Schema;." << std::endl;
           ::crclj::javax::xml::validation::Schema nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::javax::xml::validation::Schema retObject(retVal,false);
    return retObject;
   }
   void CRCLSocket::setStatSchema(::crclj::javax::xml::validation::Schema  &schema_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setStatSchema of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::setStatSchema jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setStatSchema", "(Ljavax/xml/validation/Schema;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named setStatSchema with signature (Ljavax/xml/validation/Schema;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,schema_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   jstring CRCLSocket::getReadInProgressString() {

   if(jthis == NULL) {
       std::cerr << "Call of method getReadInProgressString of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::getReadInProgressString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getReadInProgressString", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named getReadInProgressString with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring CRCLSocket::readUntilEndTag(jstring string_0,::crclj::java::io::InputStream  &inputStream_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method readUntilEndTag of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::readUntilEndTag jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "readUntilEndTag", "(Ljava/lang/String;Ljava/io/InputStream;)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named readUntilEndTag with signature (Ljava/lang/String;Ljava/io/InputStream;)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid ,string_0,inputStream_1.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   ::crclj::crcl::base::CRCLCommandInstanceType CRCLSocket::stringToCommand(jstring string_0,jboolean boolean_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method stringToCommand of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       ::crclj::crcl::base::CRCLCommandInstanceType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::stringToCommand jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "stringToCommand", "(Ljava/lang/String;Z)Lcrcl/base/CRCLCommandInstanceType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named stringToCommand with signature (Ljava/lang/String;Z)Lcrcl/base/CRCLCommandInstanceType;." << std::endl;
           ::crclj::crcl::base::CRCLCommandInstanceType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,string_0,boolean_1 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::CRCLCommandInstanceType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::CRCLCommandInstanceType CRCLSocket::readCommandFromStream(::crclj::java::io::InputStream  &inputStream_0,jboolean boolean_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method readCommandFromStream of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       ::crclj::crcl::base::CRCLCommandInstanceType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::readCommandFromStream jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "readCommandFromStream", "(Ljava/io/InputStream;Z)Lcrcl/base/CRCLCommandInstanceType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named readCommandFromStream with signature (Ljava/io/InputStream;Z)Lcrcl/base/CRCLCommandInstanceType;." << std::endl;
           ::crclj::crcl::base::CRCLCommandInstanceType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,inputStream_0.jthis,boolean_1 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::CRCLCommandInstanceType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::CRCLProgramType CRCLSocket::stringToProgram(jstring string_0,jboolean boolean_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method stringToProgram of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       ::crclj::crcl::base::CRCLProgramType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::stringToProgram jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "stringToProgram", "(Ljava/lang/String;Z)Lcrcl/base/CRCLProgramType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named stringToProgram with signature (Ljava/lang/String;Z)Lcrcl/base/CRCLProgramType;." << std::endl;
           ::crclj::crcl::base::CRCLProgramType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,string_0,boolean_1 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::CRCLProgramType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::CRCLCommandInstanceType CRCLSocket::readCommand(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method readCommand of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       ::crclj::crcl::base::CRCLCommandInstanceType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::readCommand jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "readCommand", "(Z)Lcrcl/base/CRCLCommandInstanceType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named readCommand with signature (Z)Lcrcl/base/CRCLCommandInstanceType;." << std::endl;
           ::crclj::crcl::base::CRCLCommandInstanceType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::CRCLCommandInstanceType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::CRCLStatusType CRCLSocket::stringToStatus(jstring string_0,jboolean boolean_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method stringToStatus of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       ::crclj::crcl::base::CRCLStatusType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::stringToStatus jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "stringToStatus", "(Ljava/lang/String;Z)Lcrcl/base/CRCLStatusType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named stringToStatus with signature (Ljava/lang/String;Z)Lcrcl/base/CRCLStatusType;." << std::endl;
           ::crclj::crcl::base::CRCLStatusType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,string_0,boolean_1 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::CRCLStatusType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::CRCLStatusType CRCLSocket::readStatusFromStream(::crclj::java::io::InputStream  &inputStream_0,jboolean boolean_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method readStatusFromStream of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       ::crclj::crcl::base::CRCLStatusType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::readStatusFromStream jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "readStatusFromStream", "(Ljava/io/InputStream;Z)Lcrcl/base/CRCLStatusType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named readStatusFromStream with signature (Ljava/io/InputStream;Z)Lcrcl/base/CRCLStatusType;." << std::endl;
           ::crclj::crcl::base::CRCLStatusType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,inputStream_0.jthis,boolean_1 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::CRCLStatusType retObject(retVal,false);
    return retObject;
   }
   jboolean CRCLSocket::isEXIEnabled() {

   if(jthis == NULL) {
       std::cerr << "Call of method isEXIEnabled of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::isEXIEnabled jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isEXIEnabled", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named isEXIEnabled with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean CRCLSocket::isPrefixEXISizeEnabled() {

   if(jthis == NULL) {
       std::cerr << "Call of method isPrefixEXISizeEnabled of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::isPrefixEXISizeEnabled jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isPrefixEXISizeEnabled", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named isPrefixEXISizeEnabled with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void CRCLSocket::setPrefixEXISizeEnabled(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setPrefixEXISizeEnabled of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::setPrefixEXISizeEnabled jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setPrefixEXISizeEnabled", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named setPrefixEXISizeEnabled with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   void CRCLSocket::setEXIEnabled(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setEXIEnabled of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::setEXIEnabled jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setEXIEnabled", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named setEXIEnabled with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jbyteArray CRCLSocket::statusToEXI(::crclj::crcl::base::CRCLStatusType  &cRCLStatusType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method statusToEXI of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::statusToEXI jthis=",jthis);
   jbyteArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "statusToEXI", "(Lcrcl/base/CRCLStatusType;)[B");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named statusToEXI with signature (Lcrcl/base/CRCLStatusType;)[B." << std::endl;
           return NULL;
       } else {
           retVal= (jbyteArray)  env->CallObjectMethod(jthis, mid ,cRCLStatusType_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jbyteArray CRCLSocket::commandToEXI(::crclj::crcl::base::CRCLCommandInstanceType  &cRCLCommandInstanceType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method commandToEXI of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::commandToEXI jthis=",jthis);
   jbyteArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "commandToEXI", "(Lcrcl/base/CRCLCommandInstanceType;)[B");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named commandToEXI with signature (Lcrcl/base/CRCLCommandInstanceType;)[B." << std::endl;
           return NULL;
       } else {
           retVal= (jbyteArray)  env->CallObjectMethod(jthis, mid ,cRCLCommandInstanceType_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring CRCLSocket::statToDebugString(::crclj::crcl::base::CRCLStatusType  &cRCLStatusType_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLSocketClass();
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "statToDebugString", "(Lcrcl/base/CRCLStatusType;)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named statToDebugString with signature (Lcrcl/base/CRCLStatusType;)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallStaticObjectMethod( cls, mid ,cRCLStatusType_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void CRCLSocket::writeEXIStatusToStream(::crclj::java::io::OutputStream  &outputStream_0,::crclj::crcl::base::CRCLStatusType  &cRCLStatusType_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method writeEXIStatusToStream of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::writeEXIStatusToStream jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "writeEXIStatusToStream", "(Ljava/io/OutputStream;Lcrcl/base/CRCLStatusType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named writeEXIStatusToStream with signature (Ljava/io/OutputStream;Lcrcl/base/CRCLStatusType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,outputStream_0.jthis,cRCLStatusType_1.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void CRCLSocket::writeEXICommandToStream(::crclj::java::io::OutputStream  &outputStream_0,::crclj::crcl::base::CRCLCommandInstanceType  &cRCLCommandInstanceType_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method writeEXICommandToStream of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::writeEXICommandToStream jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "writeEXICommandToStream", "(Ljava/io/OutputStream;Lcrcl/base/CRCLCommandInstanceType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named writeEXICommandToStream with signature (Ljava/io/OutputStream;Lcrcl/base/CRCLCommandInstanceType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,outputStream_0.jthis,cRCLCommandInstanceType_1.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::crcl::base::CRCLStatusType CRCLSocket::exiToStatus(jbyteArray byteArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method exiToStatus of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       ::crclj::crcl::base::CRCLStatusType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::exiToStatus jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "exiToStatus", "([B)Lcrcl/base/CRCLStatusType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named exiToStatus with signature ([B)Lcrcl/base/CRCLStatusType;." << std::endl;
           ::crclj::crcl::base::CRCLStatusType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,byteArray_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::CRCLStatusType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::CRCLCommandInstanceType CRCLSocket::exiToCommand(jbyteArray byteArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method exiToCommand of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       ::crclj::crcl::base::CRCLCommandInstanceType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::exiToCommand jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "exiToCommand", "([B)Lcrcl/base/CRCLCommandInstanceType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named exiToCommand with signature ([B)Lcrcl/base/CRCLCommandInstanceType;." << std::endl;
           ::crclj::crcl::base::CRCLCommandInstanceType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,byteArray_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::CRCLCommandInstanceType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::CRCLStatusType CRCLSocket::readStatusFromEXIStream(::crclj::java::io::InputStream  &inputStream_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method readStatusFromEXIStream of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       ::crclj::crcl::base::CRCLStatusType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::readStatusFromEXIStream jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "readStatusFromEXIStream", "(Ljava/io/InputStream;)Lcrcl/base/CRCLStatusType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named readStatusFromEXIStream with signature (Ljava/io/InputStream;)Lcrcl/base/CRCLStatusType;." << std::endl;
           ::crclj::crcl::base::CRCLStatusType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,inputStream_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::CRCLStatusType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::CRCLStatusType CRCLSocket::readStatusFromSaxSource(::crclj::javax::xml::transform::sax::SAXSource  &sAXSource_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method readStatusFromSaxSource of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       ::crclj::crcl::base::CRCLStatusType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::readStatusFromSaxSource jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "readStatusFromSaxSource", "(Ljavax/xml/transform/sax/SAXSource;)Lcrcl/base/CRCLStatusType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named readStatusFromSaxSource with signature (Ljavax/xml/transform/sax/SAXSource;)Lcrcl/base/CRCLStatusType;." << std::endl;
           ::crclj::crcl::base::CRCLStatusType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,sAXSource_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::CRCLStatusType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::CRCLCommandInstanceType CRCLSocket::readCommandFromEXIStream(::crclj::java::io::InputStream  &inputStream_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method readCommandFromEXIStream of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       ::crclj::crcl::base::CRCLCommandInstanceType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::readCommandFromEXIStream jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "readCommandFromEXIStream", "(Ljava/io/InputStream;)Lcrcl/base/CRCLCommandInstanceType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named readCommandFromEXIStream with signature (Ljava/io/InputStream;)Lcrcl/base/CRCLCommandInstanceType;." << std::endl;
           ::crclj::crcl::base::CRCLCommandInstanceType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,inputStream_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::CRCLCommandInstanceType retObject(retVal,false);
    return retObject;
   }
   ::crclj::crcl::base::CRCLStatusType CRCLSocket::readStatus(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method readStatus of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       ::crclj::crcl::base::CRCLStatusType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::readStatus jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "readStatus", "(Z)Lcrcl/base/CRCLStatusType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named readStatus with signature (Z)Lcrcl/base/CRCLStatusType;." << std::endl;
           ::crclj::crcl::base::CRCLStatusType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::CRCLStatusType retObject(retVal,false);
    return retObject;
   }
   jstring CRCLSocket::commandToString(::crclj::crcl::base::CRCLCommandType  &cRCLCommandType_0,jboolean boolean_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method commandToString of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::commandToString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "commandToString", "(Lcrcl/base/CRCLCommandType;Z)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named commandToString with signature (Lcrcl/base/CRCLCommandType;Z)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid ,cRCLCommandType_0.jthis,boolean_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring CRCLSocket::commandToString(::crclj::crcl::base::CRCLCommandInstanceType  &cRCLCommandInstanceType_0,jboolean boolean_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method commandToString of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::commandToString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "commandToString", "(Lcrcl/base/CRCLCommandInstanceType;Z)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named commandToString with signature (Lcrcl/base/CRCLCommandInstanceType;Z)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid ,cRCLCommandInstanceType_0.jthis,boolean_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring CRCLSocket::programToString(::crclj::crcl::base::CRCLProgramType  &cRCLProgramType_0,jboolean boolean_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method programToString of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::programToString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "programToString", "(Lcrcl/base/CRCLProgramType;Z)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named programToString with signature (Lcrcl/base/CRCLProgramType;Z)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid ,cRCLProgramType_0.jthis,boolean_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring CRCLSocket::commandToPrettyString(::crclj::crcl::base::CRCLCommandInstanceType  &cRCLCommandInstanceType_0,jboolean boolean_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method commandToPrettyString of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::commandToPrettyString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "commandToPrettyString", "(Lcrcl/base/CRCLCommandInstanceType;Z)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named commandToPrettyString with signature (Lcrcl/base/CRCLCommandInstanceType;Z)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid ,cRCLCommandInstanceType_0.jthis,boolean_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring CRCLSocket::commandToPrettyDocString(::crclj::crcl::base::CRCLCommandInstanceType  &cRCLCommandInstanceType_0,jboolean boolean_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method commandToPrettyDocString of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::commandToPrettyDocString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "commandToPrettyDocString", "(Lcrcl/base/CRCLCommandInstanceType;Z)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named commandToPrettyDocString with signature (Lcrcl/base/CRCLCommandInstanceType;Z)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid ,cRCLCommandInstanceType_0.jthis,boolean_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring CRCLSocket::programToPrettyString(::crclj::crcl::base::CRCLProgramType  &cRCLProgramType_0,jboolean boolean_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method programToPrettyString of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::programToPrettyString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "programToPrettyString", "(Lcrcl/base/CRCLProgramType;Z)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named programToPrettyString with signature (Lcrcl/base/CRCLProgramType;Z)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid ,cRCLProgramType_0.jthis,boolean_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring CRCLSocket::programToPrettyDocString(::crclj::crcl::base::CRCLProgramType  &cRCLProgramType_0,jboolean boolean_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method programToPrettyDocString of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::programToPrettyDocString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "programToPrettyDocString", "(Lcrcl/base/CRCLProgramType;Z)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named programToPrettyDocString with signature (Lcrcl/base/CRCLProgramType;Z)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid ,cRCLProgramType_0.jthis,boolean_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void CRCLSocket::writeCommand(::crclj::crcl::base::CRCLCommandInstanceType  &cRCLCommandInstanceType_0,jboolean boolean_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method writeCommand of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::writeCommand jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "writeCommand", "(Lcrcl/base/CRCLCommandInstanceType;Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named writeCommand with signature (Lcrcl/base/CRCLCommandInstanceType;Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,cRCLCommandInstanceType_0.jthis,boolean_1 );
       }
   }
   releaseEnv(env);
   
   }
   void CRCLSocket::writeWithFill(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method writeWithFill of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::writeWithFill jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "writeWithFill", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named writeWithFill with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   void CRCLSocket::writeProgram(::crclj::crcl::base::CRCLProgramType  &cRCLProgramType_0,jboolean boolean_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method writeProgram of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::writeProgram jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "writeProgram", "(Lcrcl/base/CRCLProgramType;Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named writeProgram with signature (Lcrcl/base/CRCLProgramType;Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,cRCLProgramType_0.jthis,boolean_1 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean CRCLSocket::isReplaceHeader() {

   if(jthis == NULL) {
       std::cerr << "Call of method isReplaceHeader of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::isReplaceHeader jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isReplaceHeader", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named isReplaceHeader with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void CRCLSocket::setReplaceHeader(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setReplaceHeader of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::setReplaceHeader jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setReplaceHeader", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named setReplaceHeader with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   jstring CRCLSocket::statusToString(::crclj::crcl::base::CRCLStatusType  &cRCLStatusType_0,jboolean boolean_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method statusToString of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::statusToString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "statusToString", "(Lcrcl/base/CRCLStatusType;Z)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named statusToString with signature (Lcrcl/base/CRCLStatusType;Z)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid ,cRCLStatusType_0.jthis,boolean_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring CRCLSocket::statusToPrettyString(::crclj::crcl::base::CRCLStatusType  &cRCLStatusType_0,jboolean boolean_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method statusToPrettyString of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::statusToPrettyString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "statusToPrettyString", "(Lcrcl/base/CRCLStatusType;Z)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named statusToPrettyString with signature (Lcrcl/base/CRCLStatusType;Z)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid ,cRCLStatusType_0.jthis,boolean_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jobjectArray CRCLSocket::findSchemaFiles() {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLSocketClass();
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "findSchemaFiles", "()[Ljava/io/File;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named findSchemaFiles with signature ()[Ljava/io/File;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallStaticObjectMethod( cls, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jobjectArray CRCLSocket::reorderStatSchemaFiles(jobjectArray fileArray_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLSocketClass();
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "reorderStatSchemaFiles", "([Ljava/io/File;)[Ljava/io/File;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named reorderStatSchemaFiles with signature ([Ljava/io/File;)[Ljava/io/File;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallStaticObjectMethod( cls, mid ,fileArray_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   ::crclj::java::util::List CRCLSocket::reorderStatSchemaFiles(::crclj::java::util::List  &list_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLSocketClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "reorderStatSchemaFiles", "(Ljava/util/List;)Ljava/util/List;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named reorderStatSchemaFiles with signature (Ljava/util/List;)Ljava/util/List;." << std::endl;
           ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,list_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::util::List retObject(retVal,false);
    return retObject;
   }
   ::crclj::javax::xml::validation::Schema CRCLSocket::filesToSchema(jobjectArray fileArray_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLSocketClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "filesToSchema", "([Ljava/io/File;)Ljavax/xml/validation/Schema;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named filesToSchema with signature ([Ljava/io/File;)Ljavax/xml/validation/Schema;." << std::endl;
           ::crclj::javax::xml::validation::Schema nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,fileArray_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::javax::xml::validation::Schema retObject(retVal,false);
    return retObject;
   }
   jobjectArray CRCLSocket::readStatSchemaFiles(::crclj::java::io::File  &file_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLSocketClass();
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "readStatSchemaFiles", "(Ljava/io/File;)[Ljava/io/File;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named readStatSchemaFiles with signature (Ljava/io/File;)[Ljava/io/File;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallStaticObjectMethod( cls, mid ,file_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void CRCLSocket::saveProgramSchemaFiles(::crclj::java::io::File  &file_0,jobjectArray fileArray_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLSocketClass();
   
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "saveProgramSchemaFiles", "(Ljava/io/File;[Ljava/io/File;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named saveProgramSchemaFiles with signature (Ljava/io/File;[Ljava/io/File;)V." << std::endl;
           
       } else {
            env->CallStaticVoidMethod( cls, mid ,file_0.jthis,fileArray_1 );
       }
   }
   releaseEnv(env);
   
   }
   void CRCLSocket::saveStatSchemaFiles(::crclj::java::io::File  &file_0,jobjectArray fileArray_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLSocketClass();
   
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "saveStatSchemaFiles", "(Ljava/io/File;[Ljava/io/File;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named saveStatSchemaFiles with signature (Ljava/io/File;[Ljava/io/File;)V." << std::endl;
           
       } else {
            env->CallStaticVoidMethod( cls, mid ,file_0.jthis,fileArray_1 );
       }
   }
   releaseEnv(env);
   
   }
   jobjectArray CRCLSocket::reorderCommandSchemaFiles(jobjectArray fileArray_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLSocketClass();
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "reorderCommandSchemaFiles", "([Ljava/io/File;)[Ljava/io/File;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named reorderCommandSchemaFiles with signature ([Ljava/io/File;)[Ljava/io/File;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallStaticObjectMethod( cls, mid ,fileArray_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   ::crclj::java::util::List CRCLSocket::reorderCommandSchemaFiles(::crclj::java::util::List  &list_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLSocketClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "reorderCommandSchemaFiles", "(Ljava/util/List;)Ljava/util/List;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named reorderCommandSchemaFiles with signature (Ljava/util/List;)Ljava/util/List;." << std::endl;
           ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,list_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::util::List retObject(retVal,false);
    return retObject;
   }
   ::crclj::java::util::List CRCLSocket::reorderProgramSchemaFiles(::crclj::java::util::List  &list_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLSocketClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "reorderProgramSchemaFiles", "(Ljava/util/List;)Ljava/util/List;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named reorderProgramSchemaFiles with signature (Ljava/util/List;)Ljava/util/List;." << std::endl;
           ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,list_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::util::List retObject(retVal,false);
    return retObject;
   }
   jobjectArray CRCLSocket::reorderProgramSchemaFiles(jobjectArray fileArray_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLSocketClass();
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "reorderProgramSchemaFiles", "([Ljava/io/File;)[Ljava/io/File;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named reorderProgramSchemaFiles with signature ([Ljava/io/File;)[Ljava/io/File;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallStaticObjectMethod( cls, mid ,fileArray_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jobjectArray CRCLSocket::readCmdSchemaFiles(::crclj::java::io::File  &file_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLSocketClass();
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "readCmdSchemaFiles", "(Ljava/io/File;)[Ljava/io/File;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named readCmdSchemaFiles with signature (Ljava/io/File;)[Ljava/io/File;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallStaticObjectMethod( cls, mid ,file_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jobjectArray CRCLSocket::readProgramSchemaFiles(::crclj::java::io::File  &file_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLSocketClass();
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "readProgramSchemaFiles", "(Ljava/io/File;)[Ljava/io/File;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named readProgramSchemaFiles with signature (Ljava/io/File;)[Ljava/io/File;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallStaticObjectMethod( cls, mid ,file_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void CRCLSocket::saveCmdSchemaFiles(::crclj::java::io::File  &file_0,jobjectArray fileArray_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLSocketClass();
   
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "saveCmdSchemaFiles", "(Ljava/io/File;[Ljava/io/File;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named saveCmdSchemaFiles with signature (Ljava/io/File;[Ljava/io/File;)V." << std::endl;
           
       } else {
            env->CallStaticVoidMethod( cls, mid ,file_0.jthis,fileArray_1 );
       }
   }
   releaseEnv(env);
   
   }
   void CRCLSocket::writeStatus(::crclj::crcl::base::CRCLStatusType  &cRCLStatusType_0,jboolean boolean_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method writeStatus of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::writeStatus jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "writeStatus", "(Lcrcl/base/CRCLStatusType;Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named writeStatus with signature (Lcrcl/base/CRCLStatusType;Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,cRCLStatusType_0.jthis,boolean_1 );
       }
   }
   releaseEnv(env);
   
   }
   void CRCLSocket::close() {

   if(jthis == NULL) {
       std::cerr << "Call of method close of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::close jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "close", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named close with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jint CRCLSocket::available() {

   if(jthis == NULL) {
       std::cerr << "Call of method available of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::available jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "available", "()I");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named available with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint CRCLSocket::getPort() {

   if(jthis == NULL) {
       std::cerr << "Call of method getPort of crcl.utils.CRCLSocket with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," CRCLSocket::getPort jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getPort", "()I");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocket has no method named getPort with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewCRCLSocketClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/CRCLSocket");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/CRCLSocket" << std::endl;
       }
       return clss;
   }
   
   static jclass CRCLSocketClass = NULL;
   static inline jclass getCRCLSocketClass() {
       if (CRCLSocketClass != NULL) {
           return CRCLSocketClass;
       }
       CRCLSocketClass = getNewCRCLSocketClass();
   }
  } // end namespace utils

   namespace base{
   
   // get JNI handle for class crcl.base.VacuumGripperStatusType
   static inline jclass getVacuumGripperStatusTypeClass();
   
   VacuumGripperStatusType::VacuumGripperStatusType(jobject _jthis, bool copy): GripperStatusType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   VacuumGripperStatusType::VacuumGripperStatusType(const VacuumGripperStatusType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   VacuumGripperStatusType::VacuumGripperStatusType() {
    JNIEnv *env =getEnv();
    static jclass cls = getVacuumGripperStatusTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class VacuumGripperStatusType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new VacuumGripperStatusType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.VacuumGripperStatusType
   VacuumGripperStatusType::~VacuumGripperStatusType() {
   	// Place-holder for later extensibility.
   }

   jboolean VacuumGripperStatusType::isIsPowered() {

   if(jthis == NULL) {
       std::cerr << "Call of method isIsPowered of crcl.base.VacuumGripperStatusType with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," VacuumGripperStatusType::isIsPowered jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isIsPowered", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.VacuumGripperStatusType has no method named isIsPowered with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void VacuumGripperStatusType::setIsPowered(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setIsPowered of crcl.base.VacuumGripperStatusType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," VacuumGripperStatusType::setIsPowered jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setIsPowered", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.VacuumGripperStatusType has no method named setIsPowered with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewVacuumGripperStatusTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/VacuumGripperStatusType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/VacuumGripperStatusType" << std::endl;
       }
       return clss;
   }
   
   static jclass VacuumGripperStatusTypeClass = NULL;
   static inline jclass getVacuumGripperStatusTypeClass() {
       if (VacuumGripperStatusTypeClass != NULL) {
           return VacuumGripperStatusTypeClass;
       }
       VacuumGripperStatusTypeClass = getNewVacuumGripperStatusTypeClass();
   }
   
   // get JNI handle for class crcl.base.GetStatusType
   static inline jclass getGetStatusTypeClass();
   
   GetStatusType::GetStatusType(jobject _jthis, bool copy): MiddleCommandType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   GetStatusType::GetStatusType(const GetStatusType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   GetStatusType::GetStatusType() {
    JNIEnv *env =getEnv();
    static jclass cls = getGetStatusTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class GetStatusType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new GetStatusType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.GetStatusType
   GetStatusType::~GetStatusType() {
   	// Place-holder for later extensibility.
   }

   static jclass getNewGetStatusTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/GetStatusType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/GetStatusType" << std::endl;
       }
       return clss;
   }
   
   static jclass GetStatusTypeClass = NULL;
   static inline jclass getGetStatusTypeClass() {
       if (GetStatusTypeClass != NULL) {
           return GetStatusTypeClass;
       }
       GetStatusTypeClass = getNewGetStatusTypeClass();
   }
   
   // get JNI handle for class crcl.base.RotSpeedAbsoluteType
   static inline jclass getRotSpeedAbsoluteTypeClass();
   
   RotSpeedAbsoluteType::RotSpeedAbsoluteType(jobject _jthis, bool copy): RotSpeedType(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   RotSpeedAbsoluteType::RotSpeedAbsoluteType(const RotSpeedAbsoluteType &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   RotSpeedAbsoluteType::RotSpeedAbsoluteType() {
    JNIEnv *env =getEnv();
    static jclass cls = getRotSpeedAbsoluteTypeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class RotSpeedAbsoluteType has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new RotSpeedAbsoluteType jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.base.RotSpeedAbsoluteType
   RotSpeedAbsoluteType::~RotSpeedAbsoluteType() {
   	// Place-holder for later extensibility.
   }

   ::crclj::java::math::BigDecimal RotSpeedAbsoluteType::getSetting() {

   if(jthis == NULL) {
       std::cerr << "Call of method getSetting of crcl.base.RotSpeedAbsoluteType with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," RotSpeedAbsoluteType::getSetting jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getSetting", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.RotSpeedAbsoluteType has no method named getSetting with signature ()Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void RotSpeedAbsoluteType::setSetting(::crclj::java::math::BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setSetting of crcl.base.RotSpeedAbsoluteType with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," RotSpeedAbsoluteType::setSetting jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setSetting", "(Ljava/math/BigDecimal;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.base.RotSpeedAbsoluteType has no method named setSetting with signature (Ljava/math/BigDecimal;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewRotSpeedAbsoluteTypeClass() {
       jclass clss = getEnv()->FindClass("crcl/base/RotSpeedAbsoluteType");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/base/RotSpeedAbsoluteType" << std::endl;
       }
       return clss;
   }
   
   static jclass RotSpeedAbsoluteTypeClass = NULL;
   static inline jclass getRotSpeedAbsoluteTypeClass() {
       if (RotSpeedAbsoluteTypeClass != NULL) {
           return RotSpeedAbsoluteTypeClass;
       }
       RotSpeedAbsoluteTypeClass = getNewRotSpeedAbsoluteTypeClass();
   }
  } // end namespace base

   namespace utils{
   
   // get JNI handle for class crcl.utils.PendantClient
   static inline jclass getPendantClientClass();
   
   PendantClient::PendantClient(jobject _jthis, bool copy): ::crclj::javax::swing::JFrame(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   PendantClient::PendantClient(const PendantClient &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   PendantClient::PendantClient(jstring string_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getPendantClientClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        if (NULL == mid) {
            std::cerr << "Class PendantClient has no method constructor signature (Ljava/lang/String;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,string_0);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PendantClient jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PendantClient::PendantClient() {
    JNIEnv *env =getEnv();
    static jclass cls = getPendantClientClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class PendantClient has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PendantClient jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.PendantClient
   PendantClient::~PendantClient() {
   	// Place-holder for later extensibility.
   }

   jboolean PendantClient::isConnected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isConnected of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::isConnected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isConnected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named isConnected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PendantClient::finishConnect() {

   if(jthis == NULL) {
       std::cerr << "Call of method finishConnect of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::finishConnect jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "finishConnect", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named finishConnect with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClient::showMessage(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method showMessage of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::showMessage jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "showMessage", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named showMessage with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClient::showMessage(::crclj::java::lang::Throwable  &throwable_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method showMessage of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::showMessage jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "showMessage", "(Ljava/lang/Throwable;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named showMessage with signature (Ljava/lang/Throwable;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,throwable_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   jboolean PendantClient::showDebugMessage(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method showDebugMessage of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::showDebugMessage jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "showDebugMessage", "(Ljava/lang/String;)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named showDebugMessage with signature (Ljava/lang/String;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PendantClient::validateXmlSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method validateXmlSelected of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::validateXmlSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "validateXmlSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named validateXmlSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PendantClient::replaceStateSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method replaceStateSelected of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::replaceStateSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "replaceStateSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named replaceStateSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PendantClient::finishDisconnect() {

   if(jthis == NULL) {
       std::cerr << "Call of method finishDisconnect of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::finishDisconnect jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "finishDisconnect", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named finishDisconnect with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClient::finishSetStatus() {

   if(jthis == NULL) {
       std::cerr << "Call of method finishSetStatus of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::finishSetStatus jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "finishSetStatus", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named finishSetStatus with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClient::checkXmlQuery(CRCLSocket  &cRCLSocket_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method checkXmlQuery of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::checkXmlQuery jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "checkXmlQuery", "(Lcrcl/utils/CRCLSocket;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named checkXmlQuery with signature (Lcrcl/utils/CRCLSocket;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,cRCLSocket_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClient::stopPollTimer() {

   if(jthis == NULL) {
       std::cerr << "Call of method stopPollTimer of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::stopPollTimer jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "stopPollTimer", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named stopPollTimer with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClient::checkPollSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method checkPollSelected of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::checkPollSelected jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "checkPollSelected", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named checkPollSelected with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jboolean PendantClient::isDebugWaitForDoneSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isDebugWaitForDoneSelected of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::isDebugWaitForDoneSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isDebugWaitForDoneSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named isDebugWaitForDoneSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PendantClient::isDebugSendCommandSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isDebugSendCommandSelected of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::isDebugSendCommandSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isDebugSendCommandSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named isDebugSendCommandSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PendantClient::isDebugReadStatusSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isDebugReadStatusSelected of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::isDebugReadStatusSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isDebugReadStatusSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named isDebugReadStatusSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PendantClient::showCurrentProgramLine(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method showCurrentProgramLine of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::showCurrentProgramLine jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "showCurrentProgramLine", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named showCurrentProgramLine with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClient::finishOpenXmlProgramFile(::crclj::java::io::File  &file_0,::crclj::crcl::base::CRCLProgramType  &cRCLProgramType_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method finishOpenXmlProgramFile of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::finishOpenXmlProgramFile jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "finishOpenXmlProgramFile", "(Ljava/io/File;Lcrcl/base/CRCLProgramType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named finishOpenXmlProgramFile with signature (Ljava/io/File;Lcrcl/base/CRCLProgramType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,file_0.jthis,cRCLProgramType_1.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::crcl::base::CRCLProgramType PendantClient::editProgram(::crclj::crcl::base::CRCLProgramType  &cRCLProgramType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method editProgram of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       ::crclj::crcl::base::CRCLProgramType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::editProgram jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "editProgram", "(Lcrcl/base/CRCLProgramType;)Lcrcl/base/CRCLProgramType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named editProgram with signature (Lcrcl/base/CRCLProgramType;)Lcrcl/base/CRCLProgramType;." << std::endl;
           ::crclj::crcl::base::CRCLProgramType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,cRCLProgramType_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::CRCLProgramType retObject(retVal,false);
    return retObject;
   }
   void PendantClient::showLastProgramLineExecTimeMillisDists(jlong long_0,jdouble double_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method showLastProgramLineExecTimeMillisDists of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::showLastProgramLineExecTimeMillisDists jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "showLastProgramLineExecTimeMillisDists", "(JD)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named showLastProgramLineExecTimeMillisDists with signature (JD)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,long_0,double_1 );
       }
   }
   releaseEnv(env);
   
   }
   jboolean PendantClient::isRecordPoseSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isRecordPoseSelected of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::isRecordPoseSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isRecordPoseSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named isRecordPoseSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PendantClient::isEXISelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isEXISelected of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::isEXISelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isEXISelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named isEXISelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PendantClient::isUseReadStatusThreadSelected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isUseReadStatusThreadSelected of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::isUseReadStatusThreadSelected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isUseReadStatusThreadSelected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named isUseReadStatusThreadSelected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PendantClient::openXmlProgramFile(::crclj::java::io::File  &file_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method openXmlProgramFile of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::openXmlProgramFile jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "openXmlProgramFile", "(Ljava/io/File;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named openXmlProgramFile with signature (Ljava/io/File;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,file_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClient::saveXmlProgramFile(::crclj::java::io::File  &file_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method saveXmlProgramFile of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::saveXmlProgramFile jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "saveXmlProgramFile", "(Ljava/io/File;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named saveXmlProgramFile with signature (Ljava/io/File;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,file_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   jdouble PendantClient::getRpyJogIncrement() {

   if(jthis == NULL) {
       std::cerr << "Call of method getRpyJogIncrement of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::getRpyJogIncrement jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getRpyJogIncrement", "()D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named getRpyJogIncrement with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PendantClient::setRpyJogIncrement(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setRpyJogIncrement of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::setRpyJogIncrement jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setRpyJogIncrement", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named setRpyJogIncrement with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClient::showProgram(::crclj::crcl::base::CRCLProgramType  &cRCLProgramType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method showProgram of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::showProgram jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "showProgram", "(Lcrcl/base/CRCLProgramType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named showProgram with signature (Lcrcl/base/CRCLProgramType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,cRCLProgramType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClient::setStatus(::crclj::crcl::base::CRCLStatusType  &cRCLStatusType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setStatus of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::setStatus jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setStatus", "(Lcrcl/base/CRCLStatusType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named setStatus with signature (Lcrcl/base/CRCLStatusType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,cRCLStatusType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClient::main(jobjectArray stringArray_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getPendantClientClass();
   
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "main", "([Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named main with signature ([Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallStaticVoidMethod( cls, mid ,stringArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClient::main(int argc, const char **argv) {
           if(argc <1 || argv==NULL) {
                main(NULL);
           } else {
               JNIEnv *env =getEnv();
               jclass strClss = getStringClass();
               jobjectArray stringArray = env->NewObjectArray(argc,strClss,getEmptyString());
               for(int i = 0; i < argc; i++) {
                   jstring str = env->NewStringUTF(argv[i]);
                   env->SetObjectArrayElement(stringArray,i,str);
               }
                main(stringArray);
               for(int i = 0; i < argc; i++) {
                   jobject str = env->GetObjectArrayElement(stringArray,i);
                   jobjectRefType ref = env->GetObjectRefType(str);
                   if(ref == JNIGlobalRefType) {
                       env->DeleteGlobalRef(str);
                   }
               }
               jobjectRefType ref = env->GetObjectRefType(stringArray);
               if(ref == JNIGlobalRefType) {
                   env->DeleteGlobalRef(stringArray);
               }
               return ;
           }
   }
   void PendantClient::connect(jstring string_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method connect of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::connect jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "connect", "(Ljava/lang/String;I)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named connect with signature (Ljava/lang/String;I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0,int_1 );
       }
   }
   releaseEnv(env);
   
   }
   jstring PendantClient::getHost() {

   if(jthis == NULL) {
       std::cerr << "Call of method getHost of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::getHost jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getHost", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named getHost with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint PendantClient::getPort() {

   if(jthis == NULL) {
       std::cerr << "Call of method getPort of crcl.utils.PendantClient with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClient::getPort jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getPort", "()I");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClient has no method named getPort with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewPendantClientClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/PendantClient");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/PendantClient" << std::endl;
       }
       return clss;
   }
   
   static jclass PendantClientClass = NULL;
   static inline jclass getPendantClientClass() {
       if (PendantClientClass != NULL) {
           return PendantClientClass;
       }
       PendantClientClass = getNewPendantClientClass();
   }
   
   // get JNI handle for class crcl.utils.CmdLineClient
   static inline jclass getCmdLineClientClass();
   
   CmdLineClient::CmdLineClient(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   CmdLineClient::CmdLineClient(const CmdLineClient &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   CmdLineClient::CmdLineClient() {
    JNIEnv *env =getEnv();
    static jclass cls = getCmdLineClientClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class CmdLineClient has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new CmdLineClient jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.CmdLineClient
   CmdLineClient::~CmdLineClient() {
   	// Place-holder for later extensibility.
   }

   void CmdLineClient::main(jobjectArray stringArray_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCmdLineClientClass();
   
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "main", "([Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CmdLineClient has no method named main with signature ([Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallStaticVoidMethod( cls, mid ,stringArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void CmdLineClient::main(int argc, const char **argv) {
           if(argc <1 || argv==NULL) {
                main(NULL);
           } else {
               JNIEnv *env =getEnv();
               jclass strClss = getStringClass();
               jobjectArray stringArray = env->NewObjectArray(argc,strClss,getEmptyString());
               for(int i = 0; i < argc; i++) {
                   jstring str = env->NewStringUTF(argv[i]);
                   env->SetObjectArrayElement(stringArray,i,str);
               }
                main(stringArray);
               for(int i = 0; i < argc; i++) {
                   jobject str = env->GetObjectArrayElement(stringArray,i);
                   jobjectRefType ref = env->GetObjectRefType(str);
                   if(ref == JNIGlobalRefType) {
                       env->DeleteGlobalRef(str);
                   }
               }
               jobjectRefType ref = env->GetObjectRefType(stringArray);
               if(ref == JNIGlobalRefType) {
                   env->DeleteGlobalRef(stringArray);
               }
               return ;
           }
   }
   static jclass getNewCmdLineClientClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/CmdLineClient");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/CmdLineClient" << std::endl;
       }
       return clss;
   }
   
   static jclass CmdLineClientClass = NULL;
   static inline jclass getCmdLineClientClass() {
       if (CmdLineClientClass != NULL) {
           return CmdLineClientClass;
       }
       CmdLineClientClass = getNewCmdLineClientClass();
   }
   
   // get JNI handle for class crcl.utils.CRCLSocketExample
   static inline jclass getCRCLSocketExampleClass();
   
   CRCLSocketExample::CRCLSocketExample(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   CRCLSocketExample::CRCLSocketExample(const CRCLSocketExample &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   CRCLSocketExample::CRCLSocketExample() {
    JNIEnv *env =getEnv();
    static jclass cls = getCRCLSocketExampleClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class CRCLSocketExample has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new CRCLSocketExample jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.CRCLSocketExample
   CRCLSocketExample::~CRCLSocketExample() {
   	// Place-holder for later extensibility.
   }

   void CRCLSocketExample::main(jobjectArray stringArray_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getCRCLSocketExampleClass();
   
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "main", "([Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.CRCLSocketExample has no method named main with signature ([Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallStaticVoidMethod( cls, mid ,stringArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void CRCLSocketExample::main(int argc, const char **argv) {
           if(argc <1 || argv==NULL) {
                main(NULL);
           } else {
               JNIEnv *env =getEnv();
               jclass strClss = getStringClass();
               jobjectArray stringArray = env->NewObjectArray(argc,strClss,getEmptyString());
               for(int i = 0; i < argc; i++) {
                   jstring str = env->NewStringUTF(argv[i]);
                   env->SetObjectArrayElement(stringArray,i,str);
               }
                main(stringArray);
               for(int i = 0; i < argc; i++) {
                   jobject str = env->GetObjectArrayElement(stringArray,i);
                   jobjectRefType ref = env->GetObjectRefType(str);
                   if(ref == JNIGlobalRefType) {
                       env->DeleteGlobalRef(str);
                   }
               }
               jobjectRefType ref = env->GetObjectRefType(stringArray);
               if(ref == JNIGlobalRefType) {
                   env->DeleteGlobalRef(stringArray);
               }
               return ;
           }
   }
   static jclass getNewCRCLSocketExampleClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/CRCLSocketExample");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/CRCLSocketExample" << std::endl;
       }
       return clss;
   }
   
   static jclass CRCLSocketExampleClass = NULL;
   static inline jclass getCRCLSocketExampleClass() {
       if (CRCLSocketExampleClass != NULL) {
           return CRCLSocketExampleClass;
       }
       CRCLSocketExampleClass = getNewCRCLSocketExampleClass();
   }
   
   // get JNI handle for class crcl.utils.PendantClientInner
   static inline jclass getPendantClientInnerClass();
   
   PendantClientInner::PendantClientInner(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   PendantClientInner::PendantClientInner(const PendantClientInner &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   PendantClientInner::PendantClientInner(PendantClientOuter  &pendantClientOuter_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getPendantClientInnerClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Lcrcl/utils/PendantClientOuter;)V");
        if (NULL == mid) {
            std::cerr << "Class PendantClientInner has no method constructor signature (Lcrcl/utils/PendantClientOuter;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,pendantClientOuter_0.jthis);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PendantClientInner jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for crcl.utils.PendantClientInner
   PendantClientInner::~PendantClientInner() {
   	// Place-holder for later extensibility.
   }

   void PendantClientInner::abort() {

   if(jthis == NULL) {
       std::cerr << "Call of method abort of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::abort jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "abort", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named abort with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClientInner::disconnect() {

   if(jthis == NULL) {
       std::cerr << "Call of method disconnect of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::disconnect jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "disconnect", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named disconnect with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jboolean PendantClientInner::isConnected() {

   if(jthis == NULL) {
       std::cerr << "Call of method isConnected of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::isConnected jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isConnected", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named isConnected with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   ::crclj::crcl::base::CRCLStatusType PendantClientInner::getStatus() {

   if(jthis == NULL) {
       std::cerr << "Call of method getStatus of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       ::crclj::crcl::base::CRCLStatusType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::getStatus jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getStatus", "()Lcrcl/base/CRCLStatusType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getStatus with signature ()Lcrcl/base/CRCLStatusType;." << std::endl;
           ::crclj::crcl::base::CRCLStatusType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::CRCLStatusType retObject(retVal,false);
    return retObject;
   }
   ::crclj::java::math::BigInteger PendantClientInner::getCmdId() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCmdId of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       ::crclj::java::math::BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::getCmdId jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCmdId", "()Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getCmdId with signature ()Ljava/math/BigInteger;." << std::endl;
           ::crclj::java::math::BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigInteger retObject(retVal,false);
    return retObject;
   }
   void PendantClientInner::setProgramSchema(jobjectArray fileArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setProgramSchema of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::setProgramSchema jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setProgramSchema", "([Ljava/io/File;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named setProgramSchema with signature ([Ljava/io/File;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,fileArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClientInner::setCmdSchema(jobjectArray fileArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCmdSchema of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::setCmdSchema jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCmdSchema", "([Ljava/io/File;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named setCmdSchema with signature ([Ljava/io/File;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,fileArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClientInner::setStatSchema(jobjectArray fileArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setStatSchema of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::setStatSchema jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setStatSchema", "([Ljava/io/File;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named setStatSchema with signature ([Ljava/io/File;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,fileArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::util::Optional PendantClientInner::getJointStatus(::crclj::crcl::base::CRCLStatusType  &cRCLStatusType_0,::crclj::java::math::BigInteger  &bigInteger_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getPendantClientInnerClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "getJointStatus", "(Lcrcl/base/CRCLStatusType;Ljava/math/BigInteger;)Ljava/util/Optional;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getJointStatus with signature (Lcrcl/base/CRCLStatusType;Ljava/math/BigInteger;)Ljava/util/Optional;." << std::endl;
           ::crclj::java::util::Optional nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,cRCLStatusType_0.jthis,bigInteger_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::util::Optional retObject(retVal,false);
    return retObject;
   }
   void PendantClientInner::readStatus() {

   if(jthis == NULL) {
       std::cerr << "Call of method readStatus of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::readStatus jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "readStatus", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named readStatus with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::math::BigDecimal PendantClientInner::getJointPosition(::crclj::java::math::BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method getJointPosition of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::getJointPosition jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getJointPosition", "(Ljava/math/BigInteger;)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getJointPosition with signature (Ljava/math/BigInteger;)Ljava/math/BigDecimal;." << std::endl;
           ::crclj::java::math::BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::math::BigDecimal retObject(retVal,false);
    return retObject;
   }
   void PendantClientInner::closeTestProgramThread() {

   if(jthis == NULL) {
       std::cerr << "Call of method closeTestProgramThread of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::closeTestProgramThread jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "closeTestProgramThread", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named closeTestProgramThread with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jboolean PendantClientInner::requestStatus() {

   if(jthis == NULL) {
       std::cerr << "Call of method requestStatus of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::requestStatus jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "requestStatus", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named requestStatus with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PendantClientInner::checkProgramValid(::crclj::crcl::base::CRCLProgramType  &cRCLProgramType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method checkProgramValid of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::checkProgramValid jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "checkProgramValid", "(Lcrcl/base/CRCLProgramType;)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named checkProgramValid with signature (Lcrcl/base/CRCLProgramType;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,cRCLProgramType_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PendantClientInner::checkCommandValid(::crclj::crcl::base::CRCLCommandType  &cRCLCommandType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method checkCommandValid of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::checkCommandValid jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "checkCommandValid", "(Lcrcl/base/CRCLCommandType;)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named checkCommandValid with signature (Lcrcl/base/CRCLCommandType;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,cRCLCommandType_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jobjectArray PendantClientInner::getCmdSchemaFiles() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCmdSchemaFiles of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::getCmdSchemaFiles jthis=",jthis);
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCmdSchemaFiles", "()[Ljava/io/File;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getCmdSchemaFiles with signature ()[Ljava/io/File;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PendantClientInner::sendCommand(::crclj::crcl::base::CRCLCommandType  &cRCLCommandType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method sendCommand of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::sendCommand jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "sendCommand", "(Lcrcl/base/CRCLCommandType;)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named sendCommand with signature (Lcrcl/base/CRCLCommandType;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,cRCLCommandType_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PendantClientInner::stopMotion(::crclj::crcl::base::StopConditionEnumType  &stopConditionEnumType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method stopMotion of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::stopMotion jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "stopMotion", "(Lcrcl/base/StopConditionEnumType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named stopMotion with signature (Lcrcl/base/StopConditionEnumType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,stopConditionEnumType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   jboolean PendantClientInner::waitForDone(::crclj::java::math::BigInteger  &bigInteger_0,jlong long_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method waitForDone of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::waitForDone jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "waitForDone", "(Ljava/math/BigInteger;J)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named waitForDone with signature (Ljava/math/BigInteger;J)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,bigInteger_0.jthis,long_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jlong PendantClientInner::getWaitForDoneDelay() {

   if(jthis == NULL) {
       std::cerr << "Call of method getWaitForDoneDelay of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       return (jlong) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::getWaitForDoneDelay jthis=",jthis);
   jlong retVal= (jlong) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getWaitForDoneDelay", "()J");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getWaitForDoneDelay with signature ()J." << std::endl;
           return (jlong) -1;
       } else {
           retVal= (jlong)  env->CallLongMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PendantClientInner::setWaitForDoneDelay(jlong long_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setWaitForDoneDelay of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::setWaitForDoneDelay jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setWaitForDoneDelay", "(J)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named setWaitForDoneDelay with signature (J)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,long_0 );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::util::stream::Stream PendantClientInner::getJointValues(::crclj::crcl::base::CRCLStatusType  &cRCLStatusType_0,::crclj::java::util::Collection  &collection_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getPendantClientInnerClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "getJointValues", "(Lcrcl/base/CRCLStatusType;Ljava/util/Collection;)Ljava/util/stream/Stream;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getJointValues with signature (Lcrcl/base/CRCLStatusType;Ljava/util/Collection;)Ljava/util/stream/Stream;." << std::endl;
           ::crclj::java::util::stream::Stream nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,cRCLStatusType_0.jthis,collection_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::util::stream::Stream retObject(retVal,false);
    return retObject;
   }
   jstring PendantClientInner::getJointString(::crclj::crcl::base::CRCLStatusType  &cRCLStatusType_0,::crclj::java::util::function::Function  &function_1,::crclj::java::util::Collection  &collection_2) {

   JNIEnv *env =getEnv();
   static jclass cls = getPendantClientInnerClass();
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "getJointString", "(Lcrcl/base/CRCLStatusType;Ljava/util/function/Function;Ljava/util/Collection;)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getJointString with signature (Lcrcl/base/CRCLStatusType;Ljava/util/function/Function;Ljava/util/Collection;)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallStaticObjectMethod( cls, mid ,cRCLStatusType_0.jthis,function_1.jthis,collection_2.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PendantClientInner::waitForPause() {

   if(jthis == NULL) {
       std::cerr << "Call of method waitForPause of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::waitForPause jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "waitForPause", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named waitForPause with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jboolean PendantClientInner::runProgram(::crclj::crcl::base::CRCLProgramType  &cRCLProgramType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method runProgram of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::runProgram jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "runProgram", "(Lcrcl/base/CRCLProgramType;)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named runProgram with signature (Lcrcl/base/CRCLProgramType;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,cRCLProgramType_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PendantClientInner::runTest() {

   if(jthis == NULL) {
       std::cerr << "Call of method runTest of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::runTest jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "runTest", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named runTest with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PendantClientInner::setCmdId(::crclj::java::math::BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setCmdId of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::setCmdId jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setCmdId", "(Ljava/math/BigInteger;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named setCmdId with signature (Ljava/math/BigInteger;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClientInner::setJogInterval(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setJogInterval of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::setJogInterval jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setJogInterval", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named setJogInterval with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClientInner::openXmlProgramFile(::crclj::java::io::File  &file_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method openXmlProgramFile of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::openXmlProgramFile jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "openXmlProgramFile", "(Ljava/io/File;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named openXmlProgramFile with signature (Ljava/io/File;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,file_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClientInner::saveXmlProgramFile(::crclj::java::io::File  &file_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method saveXmlProgramFile of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::saveXmlProgramFile jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "saveXmlProgramFile", "(Ljava/io/File;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named saveXmlProgramFile with signature (Ljava/io/File;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,file_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   jdouble PendantClientInner::getJogIncrement() {

   if(jthis == NULL) {
       std::cerr << "Call of method getJogIncrement of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::getJogIncrement jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getJogIncrement", "()D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getJogIncrement with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PendantClientInner::setProgram(::crclj::crcl::base::CRCLProgramType  &cRCLProgramType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setProgram of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::setProgram jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setProgram", "(Lcrcl/base/CRCLProgramType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named setProgram with signature (Lcrcl/base/CRCLProgramType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,cRCLProgramType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   jboolean PendantClientInner::incAndSendCommand(::crclj::crcl::base::CRCLCommandType  &cRCLCommandType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method incAndSendCommand of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::incAndSendCommand jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "incAndSendCommand", "(Lcrcl/base/CRCLCommandType;)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named incAndSendCommand with signature (Lcrcl/base/CRCLCommandType;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,cRCLCommandType_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   CRCLSocket PendantClientInner::getCRCLSocket() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCRCLSocket of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       CRCLSocket nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::getCRCLSocket jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCRCLSocket", "()Lcrcl/utils/CRCLSocket;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getCRCLSocket with signature ()Lcrcl/utils/CRCLSocket;." << std::endl;
           CRCLSocket nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    CRCLSocket retObject(retVal,false);
    return retObject;
   }
   jint PendantClientInner::getJogInterval() {

   if(jthis == NULL) {
       std::cerr << "Call of method getJogInterval of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::getJogInterval jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getJogInterval", "()I");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getJogInterval with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jdouble PendantClientInner::getXyzJogIncrement() {

   if(jthis == NULL) {
       std::cerr << "Call of method getXyzJogIncrement of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::getXyzJogIncrement jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getXyzJogIncrement", "()D");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getXyzJogIncrement with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   CRCLSocket PendantClientInner::getTempCRCLSocket() {

   if(jthis == NULL) {
       std::cerr << "Call of method getTempCRCLSocket of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       CRCLSocket nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::getTempCRCLSocket jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getTempCRCLSocket", "()Lcrcl/utils/CRCLSocket;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getTempCRCLSocket with signature ()Lcrcl/utils/CRCLSocket;." << std::endl;
           CRCLSocket nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    CRCLSocket retObject(retVal,false);
    return retObject;
   }
   jobjectArray PendantClientInner::getProgramSchemaFiles() {

   if(jthis == NULL) {
       std::cerr << "Call of method getProgramSchemaFiles of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::getProgramSchemaFiles jthis=",jthis);
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getProgramSchemaFiles", "()[Ljava/io/File;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getProgramSchemaFiles with signature ()[Ljava/io/File;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   ::crclj::java::util::function::Predicate PendantClientInner::getCheckProgramValidPredicate() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCheckProgramValidPredicate of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       ::crclj::java::util::function::Predicate nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::getCheckProgramValidPredicate jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCheckProgramValidPredicate", "()Ljava/util/function/Predicate;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getCheckProgramValidPredicate with signature ()Ljava/util/function/Predicate;." << std::endl;
           ::crclj::java::util::function::Predicate nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::util::function::Predicate retObject(retVal,false);
    return retObject;
   }
   ::crclj::java::util::function::Predicate PendantClientInner::getCheckCommandValidPredicate() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCheckCommandValidPredicate of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       ::crclj::java::util::function::Predicate nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::getCheckCommandValidPredicate jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCheckCommandValidPredicate", "()Ljava/util/function/Predicate;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getCheckCommandValidPredicate with signature ()Ljava/util/function/Predicate;." << std::endl;
           ::crclj::java::util::function::Predicate nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::util::function::Predicate retObject(retVal,false);
    return retObject;
   }
   jint PendantClientInner::getPoll_ms() {

   if(jthis == NULL) {
       std::cerr << "Call of method getPoll_ms of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::getPoll_ms jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getPoll_ms", "()I");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getPoll_ms with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PendantClientInner::setPoll_ms(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setPoll_ms of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::setPoll_ms jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setPoll_ms", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named setPoll_ms with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClientInner::setJogIncrement(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setJogIncrement of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::setJogIncrement jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setJogIncrement", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named setJogIncrement with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClientInner::setXyzJogIncrement(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setXyzJogIncrement of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::setXyzJogIncrement jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setXyzJogIncrement", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named setXyzJogIncrement with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClientInner::startRunTestThread() {

   if(jthis == NULL) {
       std::cerr << "Call of method startRunTestThread of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::startRunTestThread jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "startRunTestThread", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named startRunTestThread with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClientInner::startRunProgramThread() {

   if(jthis == NULL) {
       std::cerr << "Call of method startRunProgramThread of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::startRunProgramThread jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "startRunProgramThread", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named startRunProgramThread with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jboolean PendantClientInner::isPaused() {

   if(jthis == NULL) {
       std::cerr << "Call of method isPaused of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::isPaused jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isPaused", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named isPaused with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PendantClientInner::isRunningProgram() {

   if(jthis == NULL) {
       std::cerr << "Call of method isRunningProgram of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::isRunningProgram jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isRunningProgram", "()Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named isRunningProgram with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PendantClientInner::unpause() {

   if(jthis == NULL) {
       std::cerr << "Call of method unpause of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::unpause jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "unpause", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named unpause with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::crcl::base::CRCLProgramType PendantClientInner::getProgram() {

   if(jthis == NULL) {
       std::cerr << "Call of method getProgram of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       ::crclj::crcl::base::CRCLProgramType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::getProgram jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getProgram", "()Lcrcl/base/CRCLProgramType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getProgram with signature ()Lcrcl/base/CRCLProgramType;." << std::endl;
           ::crclj::crcl::base::CRCLProgramType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::CRCLProgramType retObject(retVal,false);
    return retObject;
   }
   void PendantClientInner::savePoseListToCsvFile(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method savePoseListToCsvFile of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::savePoseListToCsvFile jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "savePoseListToCsvFile", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named savePoseListToCsvFile with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::java::util::List PendantClientInner::getPoseList() {

   if(jthis == NULL) {
       std::cerr << "Call of method getPoseList of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::getPoseList jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getPoseList", "()Ljava/util/List;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getPoseList with signature ()Ljava/util/List;." << std::endl;
           ::crclj::java::util::List nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::util::List retObject(retVal,false);
    return retObject;
   }
   void PendantClientInner::startStatusReaderThread() {

   if(jthis == NULL) {
       std::cerr << "Call of method startStatusReaderThread of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::startStatusReaderThread jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "startStatusReaderThread", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named startStatusReaderThread with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClientInner::stopStatusReaderThread() {

   if(jthis == NULL) {
       std::cerr << "Call of method stopStatusReaderThread of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::stopStatusReaderThread jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "stopStatusReaderThread", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named stopStatusReaderThread with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClientInner::pause() {

   if(jthis == NULL) {
       std::cerr << "Call of method pause of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::pause jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "pause", "()V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named pause with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jboolean PendantClientInner::isDone(::crclj::java::math::BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method isDone of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::isDone jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isDone", "(Ljava/math/BigInteger;)Z");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named isDone with signature (Ljava/math/BigInteger;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   XpathUtils PendantClientInner::getXpu() {

   if(jthis == NULL) {
       std::cerr << "Call of method getXpu of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       XpathUtils nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::getXpu jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getXpu", "()Lcrcl/utils/XpathUtils;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getXpu with signature ()Lcrcl/utils/XpathUtils;." << std::endl;
           XpathUtils nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    XpathUtils retObject(retVal,false);
    return retObject;
   }
   void PendantClientInner::setStatus(::crclj::crcl::base::CRCLStatusType  &cRCLStatusType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setStatus of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::setStatus jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setStatus", "(Lcrcl/base/CRCLStatusType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named setStatus with signature (Lcrcl/base/CRCLStatusType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,cRCLStatusType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::crcl::base::AngleUnitEnumType PendantClientInner::getAngleType() {

   if(jthis == NULL) {
       std::cerr << "Call of method getAngleType of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       ::crclj::crcl::base::AngleUnitEnumType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::getAngleType jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getAngleType", "()Lcrcl/base/AngleUnitEnumType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getAngleType with signature ()Lcrcl/base/AngleUnitEnumType;." << std::endl;
           ::crclj::crcl::base::AngleUnitEnumType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::AngleUnitEnumType retObject(retVal,false);
    return retObject;
   }
   void PendantClientInner::setAngleType(::crclj::crcl::base::AngleUnitEnumType  &angleUnitEnumType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setAngleType of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::setAngleType jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setAngleType", "(Lcrcl/base/AngleUnitEnumType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named setAngleType with signature (Lcrcl/base/AngleUnitEnumType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,angleUnitEnumType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::crcl::base::PoseToleranceType PendantClientInner::getExpectedEndPoseTolerance() {

   if(jthis == NULL) {
       std::cerr << "Call of method getExpectedEndPoseTolerance of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       ::crclj::crcl::base::PoseToleranceType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::getExpectedEndPoseTolerance jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getExpectedEndPoseTolerance", "()Lcrcl/base/PoseToleranceType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getExpectedEndPoseTolerance with signature ()Lcrcl/base/PoseToleranceType;." << std::endl;
           ::crclj::crcl::base::PoseToleranceType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PoseToleranceType retObject(retVal,false);
    return retObject;
   }
   void PendantClientInner::setExpectedEndPoseTolerance(::crclj::crcl::base::PoseToleranceType  &poseToleranceType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setExpectedEndPoseTolerance of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::setExpectedEndPoseTolerance jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setExpectedEndPoseTolerance", "(Lcrcl/base/PoseToleranceType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named setExpectedEndPoseTolerance with signature (Lcrcl/base/PoseToleranceType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,poseToleranceType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   ::crclj::crcl::base::PoseToleranceType PendantClientInner::getExpectedIntermediatePoseTolerance() {

   if(jthis == NULL) {
       std::cerr << "Call of method getExpectedIntermediatePoseTolerance of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       ::crclj::crcl::base::PoseToleranceType nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::getExpectedIntermediatePoseTolerance jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getExpectedIntermediatePoseTolerance", "()Lcrcl/base/PoseToleranceType;");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named getExpectedIntermediatePoseTolerance with signature ()Lcrcl/base/PoseToleranceType;." << std::endl;
           ::crclj::crcl::base::PoseToleranceType nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::crcl::base::PoseToleranceType retObject(retVal,false);
    return retObject;
   }
   void PendantClientInner::setExpectedIntermediatePoseTolerance(::crclj::crcl::base::PoseToleranceType  &poseToleranceType_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setExpectedIntermediatePoseTolerance of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::setExpectedIntermediatePoseTolerance jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setExpectedIntermediatePoseTolerance", "(Lcrcl/base/PoseToleranceType;)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named setExpectedIntermediatePoseTolerance with signature (Lcrcl/base/PoseToleranceType;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,poseToleranceType_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void PendantClientInner::connect(jstring string_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method connect of crcl.utils.PendantClientInner with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PendantClientInner::connect jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "connect", "(Ljava/lang/String;I)V");
       if (NULL == mid) {
           std::cerr << "Class crcl.utils.PendantClientInner has no method named connect with signature (Ljava/lang/String;I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0,int_1 );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewPendantClientInnerClass() {
       jclass clss = getEnv()->FindClass("crcl/utils/PendantClientInner");
       if (NULL == clss) {
           std::cerr << " Can't find class crcl/utils/PendantClientInner" << std::endl;
       }
       return clss;
   }
   
   static jclass PendantClientInnerClass = NULL;
   static inline jclass getPendantClientInnerClass() {
       if (PendantClientInnerClass != NULL) {
           return PendantClientInnerClass;
       }
       PendantClientInnerClass = getNewPendantClientInnerClass();
   }
  } // end namespace utils
 } // end namespace crcl

  namespace java{
   namespace lang{
   
   // get JNI handle for class java.lang.Number
   static inline jclass getNumberClass();
   
   Number::Number(jobject _jthis, bool copy): Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   Number::Number(const Number &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   Number::Number() {
    JNIEnv *env =getEnv();
    static jclass cls = getNumberClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class Number has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Number jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for java.lang.Number
   Number::~Number() {
   	// Place-holder for later extensibility.
   }

   jbyte Number::byteValue() {

   if(jthis == NULL) {
       std::cerr << "Call of method byteValue of java.lang.Number with jthis == NULL." << std::endl;
       return (jbyte) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Number::byteValue jthis=",jthis);
   jbyte retVal= (jbyte) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "byteValue", "()B");
       if (NULL == mid) {
           std::cerr << "Class java.lang.Number has no method named byteValue with signature ()B." << std::endl;
           return (jbyte) -1;
       } else {
           retVal= (jbyte)  env->CallByteMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jshort Number::shortValue() {

   if(jthis == NULL) {
       std::cerr << "Call of method shortValue of java.lang.Number with jthis == NULL." << std::endl;
       return (jshort) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Number::shortValue jthis=",jthis);
   jshort retVal=(jshort) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "shortValue", "()S");
       if (NULL == mid) {
           std::cerr << "Class java.lang.Number has no method named shortValue with signature ()S." << std::endl;
           return (jshort) -1;
       } else {
           retVal= (jshort)  env->CallShortMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewNumberClass() {
       jclass clss = getEnv()->FindClass("java/lang/Number");
       if (NULL == clss) {
           std::cerr << " Can't find class java/lang/Number" << std::endl;
       }
       return clss;
   }
   
   static jclass NumberClass = NULL;
   static inline jclass getNumberClass() {
       if (NumberClass != NULL) {
           return NumberClass;
       }
       NumberClass = getNewNumberClass();
   }
  } // end namespace lang

   namespace math{
   
   // get JNI handle for class java.math.BigDecimal
   static inline jclass getBigDecimalClass();
   
   BigDecimal::BigDecimal(jobject _jthis, bool copy): ::crclj::java::lang::Number(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   BigDecimal::BigDecimal(const BigDecimal &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   BigDecimal::BigDecimal(jdouble double_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getBigDecimalClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(D)V");
        if (NULL == mid) {
            std::cerr << "Class BigDecimal has no method constructor signature (D)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,double_0);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new BigDecimal jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   BigDecimal::BigDecimal(jcharArray charArray_0,jint int_1,jint int_2) {
    JNIEnv *env =getEnv();
    static jclass cls = getBigDecimalClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "([CII)V");
        if (NULL == mid) {
            std::cerr << "Class BigDecimal has no method constructor signature ([CII)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,charArray_0,int_1,int_2);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new BigDecimal jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   BigDecimal::BigDecimal(jcharArray charArray_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getBigDecimalClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "([C)V");
        if (NULL == mid) {
            std::cerr << "Class BigDecimal has no method constructor signature ([C)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,charArray_0);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new BigDecimal jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   BigDecimal::BigDecimal(jint int_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getBigDecimalClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(I)V");
        if (NULL == mid) {
            std::cerr << "Class BigDecimal has no method constructor signature (I)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,int_0);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new BigDecimal jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   BigDecimal::BigDecimal(jlong long_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getBigDecimalClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(J)V");
        if (NULL == mid) {
            std::cerr << "Class BigDecimal has no method constructor signature (J)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,long_0);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new BigDecimal jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   BigDecimal::BigDecimal(BigInteger  &bigInteger_0,jint int_1) {
    JNIEnv *env =getEnv();
    static jclass cls = getBigDecimalClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/math/BigInteger;I)V");
        if (NULL == mid) {
            std::cerr << "Class BigDecimal has no method constructor signature (Ljava/math/BigInteger;I)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,bigInteger_0.jthis,int_1);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new BigDecimal jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   BigDecimal::BigDecimal(BigInteger  &bigInteger_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getBigDecimalClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/math/BigInteger;)V");
        if (NULL == mid) {
            std::cerr << "Class BigDecimal has no method constructor signature (Ljava/math/BigInteger;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,bigInteger_0.jthis);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new BigDecimal jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   BigDecimal::BigDecimal(jstring string_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getBigDecimalClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        if (NULL == mid) {
            std::cerr << "Class BigDecimal has no method constructor signature (Ljava/lang/String;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,string_0);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new BigDecimal jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for java.math.BigDecimal
   BigDecimal::~BigDecimal() {
   	// Place-holder for later extensibility.
   }

   jint BigDecimal::precision() {

   if(jthis == NULL) {
       std::cerr << "Call of method precision of java.math.BigDecimal with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::precision jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "precision", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named precision with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   BigDecimal BigDecimal::divideToIntegralValue(BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method divideToIntegralValue of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::divideToIntegralValue jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "divideToIntegralValue", "(Ljava/math/BigDecimal;)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named divideToIntegralValue with signature (Ljava/math/BigDecimal;)Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   jobjectArray BigDecimal::divideAndRemainder(BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method divideAndRemainder of java.math.BigDecimal with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::divideAndRemainder jthis=",jthis);
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "divideAndRemainder", "(Ljava/math/BigDecimal;)[Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named divideAndRemainder with signature (Ljava/math/BigDecimal;)[Ljava/math/BigDecimal;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallObjectMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   BigDecimal BigDecimal::plus() {

   if(jthis == NULL) {
       std::cerr << "Call of method plus of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::plus jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "plus", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named plus with signature ()Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   BigInteger BigDecimal::unscaledValue() {

   if(jthis == NULL) {
       std::cerr << "Call of method unscaledValue of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::unscaledValue jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "unscaledValue", "()Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named unscaledValue with signature ()Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigDecimal BigDecimal::movePointLeft(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method movePointLeft of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::movePointLeft jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "movePointLeft", "(I)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named movePointLeft with signature (I)Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   BigDecimal BigDecimal::movePointRight(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method movePointRight of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::movePointRight jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "movePointRight", "(I)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named movePointRight with signature (I)Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   BigDecimal BigDecimal::scaleByPowerOfTen(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method scaleByPowerOfTen of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::scaleByPowerOfTen jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "scaleByPowerOfTen", "(I)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named scaleByPowerOfTen with signature (I)Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   BigDecimal BigDecimal::stripTrailingZeros() {

   if(jthis == NULL) {
       std::cerr << "Call of method stripTrailingZeros of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::stripTrailingZeros jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "stripTrailingZeros", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named stripTrailingZeros with signature ()Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   jstring BigDecimal::toEngineeringString() {

   if(jthis == NULL) {
       std::cerr << "Call of method toEngineeringString of java.math.BigDecimal with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::toEngineeringString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toEngineeringString", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named toEngineeringString with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring BigDecimal::toPlainString() {

   if(jthis == NULL) {
       std::cerr << "Call of method toPlainString of java.math.BigDecimal with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::toPlainString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toPlainString", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named toPlainString with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   BigInteger BigDecimal::toBigInteger() {

   if(jthis == NULL) {
       std::cerr << "Call of method toBigInteger of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::toBigInteger jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toBigInteger", "()Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named toBigInteger with signature ()Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigInteger BigDecimal::toBigIntegerExact() {

   if(jthis == NULL) {
       std::cerr << "Call of method toBigIntegerExact of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::toBigIntegerExact jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toBigIntegerExact", "()Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named toBigIntegerExact with signature ()Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   jlong BigDecimal::longValueExact() {

   if(jthis == NULL) {
       std::cerr << "Call of method longValueExact of java.math.BigDecimal with jthis == NULL." << std::endl;
       return (jlong) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::longValueExact jthis=",jthis);
   jlong retVal= (jlong) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "longValueExact", "()J");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named longValueExact with signature ()J." << std::endl;
           return (jlong) -1;
       } else {
           retVal= (jlong)  env->CallLongMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint BigDecimal::intValueExact() {

   if(jthis == NULL) {
       std::cerr << "Call of method intValueExact of java.math.BigDecimal with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::intValueExact jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "intValueExact", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named intValueExact with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jshort BigDecimal::shortValueExact() {

   if(jthis == NULL) {
       std::cerr << "Call of method shortValueExact of java.math.BigDecimal with jthis == NULL." << std::endl;
       return (jshort) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::shortValueExact jthis=",jthis);
   jshort retVal=(jshort) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "shortValueExact", "()S");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named shortValueExact with signature ()S." << std::endl;
           return (jshort) -1;
       } else {
           retVal= (jshort)  env->CallShortMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jbyte BigDecimal::byteValueExact() {

   if(jthis == NULL) {
       std::cerr << "Call of method byteValueExact of java.math.BigDecimal with jthis == NULL." << std::endl;
       return (jbyte) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::byteValueExact jthis=",jthis);
   jbyte retVal= (jbyte) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "byteValueExact", "()B");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named byteValueExact with signature ()B." << std::endl;
           return (jbyte) -1;
       } else {
           retVal= (jbyte)  env->CallByteMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   BigDecimal BigDecimal::subtract(BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method subtract of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::subtract jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "subtract", "(Ljava/math/BigDecimal;)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named subtract with signature (Ljava/math/BigDecimal;)Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   BigDecimal BigDecimal::multiply(BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method multiply of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::multiply jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "multiply", "(Ljava/math/BigDecimal;)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named multiply with signature (Ljava/math/BigDecimal;)Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   BigDecimal BigDecimal::setScale(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setScale of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::setScale jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setScale", "(I)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named setScale with signature (I)Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   BigDecimal BigDecimal::setScale(jint int_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method setScale of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::setScale jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setScale", "(II)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named setScale with signature (II)Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,int_0,int_1 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   BigDecimal BigDecimal::negate() {

   if(jthis == NULL) {
       std::cerr << "Call of method negate of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::negate jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "negate", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named negate with signature ()Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   BigDecimal BigDecimal::add(BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method add of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::add jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "add", "(Ljava/math/BigDecimal;)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named add with signature (Ljava/math/BigDecimal;)Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   jboolean BigDecimal::equals(::crclj::java::lang::Object  &object_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method equals of java.math.BigDecimal with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::equals jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named equals with signature (Ljava/lang/Object;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,object_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring BigDecimal::toString() {

   if(jthis == NULL) {
       std::cerr << "Call of method toString of java.math.BigDecimal with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::toString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toString", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named toString with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint BigDecimal::hashCode() {

   if(jthis == NULL) {
       std::cerr << "Call of method hashCode of java.math.BigDecimal with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::hashCode jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "hashCode", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named hashCode with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   BigDecimal BigDecimal::abs() {

   if(jthis == NULL) {
       std::cerr << "Call of method abs of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::abs jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "abs", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named abs with signature ()Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   BigDecimal BigDecimal::pow(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method pow of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::pow jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "pow", "(I)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named pow with signature (I)Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   BigDecimal BigDecimal::min(BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method min of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::min jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "min", "(Ljava/math/BigDecimal;)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named min with signature (Ljava/math/BigDecimal;)Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   BigDecimal BigDecimal::max(BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method max of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::max jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "max", "(Ljava/math/BigDecimal;)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named max with signature (Ljava/math/BigDecimal;)Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   jint BigDecimal::compareTo(BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method compareTo of java.math.BigDecimal with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::compareTo jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "compareTo", "(Ljava/math/BigDecimal;)I");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named compareTo with signature (Ljava/math/BigDecimal;)I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint BigDecimal::intValue() {

   if(jthis == NULL) {
       std::cerr << "Call of method intValue of java.math.BigDecimal with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::intValue jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "intValue", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named intValue with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jlong BigDecimal::longValue() {

   if(jthis == NULL) {
       std::cerr << "Call of method longValue of java.math.BigDecimal with jthis == NULL." << std::endl;
       return (jlong) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::longValue jthis=",jthis);
   jlong retVal= (jlong) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "longValue", "()J");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named longValue with signature ()J." << std::endl;
           return (jlong) -1;
       } else {
           retVal= (jlong)  env->CallLongMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jfloat BigDecimal::floatValue() {

   if(jthis == NULL) {
       std::cerr << "Call of method floatValue of java.math.BigDecimal with jthis == NULL." << std::endl;
       return (jfloat) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::floatValue jthis=",jthis);
   jfloat retVal= (jfloat) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "floatValue", "()F");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named floatValue with signature ()F." << std::endl;
           return (jfloat) -1.0;
       } else {
           retVal= (jfloat)  env->CallFloatMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jdouble BigDecimal::doubleValue() {

   if(jthis == NULL) {
       std::cerr << "Call of method doubleValue of java.math.BigDecimal with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::doubleValue jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "doubleValue", "()D");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named doubleValue with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   BigDecimal BigDecimal::valueOf(jlong long_0,jint int_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getBigDecimalClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "valueOf", "(JI)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named valueOf with signature (JI)Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,long_0,int_1 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   BigDecimal BigDecimal::valueOf(jlong long_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getBigDecimalClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "valueOf", "(J)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named valueOf with signature (J)Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,long_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   BigDecimal BigDecimal::valueOf(jdouble double_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getBigDecimalClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "valueOf", "(D)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named valueOf with signature (D)Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,double_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   jint BigDecimal::signum() {

   if(jthis == NULL) {
       std::cerr << "Call of method signum of java.math.BigDecimal with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::signum jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "signum", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named signum with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   BigDecimal BigDecimal::divide(BigDecimal  &bigDecimal_0,jint int_1,jint int_2) {

   if(jthis == NULL) {
       std::cerr << "Call of method divide of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::divide jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "divide", "(Ljava/math/BigDecimal;II)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named divide with signature (Ljava/math/BigDecimal;II)Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigDecimal_0.jthis,int_1,int_2 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   BigDecimal BigDecimal::divide(BigDecimal  &bigDecimal_0,jint int_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method divide of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::divide jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "divide", "(Ljava/math/BigDecimal;I)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named divide with signature (Ljava/math/BigDecimal;I)Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigDecimal_0.jthis,int_1 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   BigDecimal BigDecimal::divide(BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method divide of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::divide jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "divide", "(Ljava/math/BigDecimal;)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named divide with signature (Ljava/math/BigDecimal;)Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   BigDecimal BigDecimal::remainder(BigDecimal  &bigDecimal_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method remainder of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::remainder jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "remainder", "(Ljava/math/BigDecimal;)Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named remainder with signature (Ljava/math/BigDecimal;)Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigDecimal_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   BigDecimal BigDecimal::ulp() {

   if(jthis == NULL) {
       std::cerr << "Call of method ulp of java.math.BigDecimal with jthis == NULL." << std::endl;
       BigDecimal nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::ulp jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "ulp", "()Ljava/math/BigDecimal;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named ulp with signature ()Ljava/math/BigDecimal;." << std::endl;
           BigDecimal nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigDecimal retObject(retVal,false);
    return retObject;
   }
   jint BigDecimal::scale() {

   if(jthis == NULL) {
       std::cerr << "Call of method scale of java.math.BigDecimal with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigDecimal::scale jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "scale", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigDecimal has no method named scale with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewBigDecimalClass() {
       jclass clss = getEnv()->FindClass("java/math/BigDecimal");
       if (NULL == clss) {
           std::cerr << " Can't find class java/math/BigDecimal" << std::endl;
       }
       return clss;
   }
   
   static jclass BigDecimalClass = NULL;
   static inline jclass getBigDecimalClass() {
       if (BigDecimalClass != NULL) {
           return BigDecimalClass;
       }
       BigDecimalClass = getNewBigDecimalClass();
   }
  } // end namespace math

   namespace util{
   
   // get JNI handle for class java.util.List
   static inline jclass getListClass();
   
   List::List(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   List::List(const List &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   List::List() {
   JNIEnv *env =getEnv();
   static jclass cls = getListClass();
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
       if (NULL == mid) {
           std::cerr << "Class List has no method constructor signature ()V" << std::endl;
       } else {
           jthis = env->NewObject(cls, mid );
           jobjectRefType ref = env->GetObjectRefType(jthis);
           if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new List jthis=",jthis);
           if(ref != JNIGlobalRefType) {
               jthis = env->NewGlobalRef(jthis);
           }
       }
   }
   releaseEnv(env);
   }


   // Destructor for java.util.List
   List::~List() {
   	// Place-holder for later extensibility.
   }

   void List::replaceAll(function::UnaryOperator  &unaryOperator_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method replaceAll of java.util.List with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," List::replaceAll jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "replaceAll", "(Ljava/util/function/UnaryOperator;)V");
       if (NULL == mid) {
           std::cerr << "Class java.util.List has no method named replaceAll with signature (Ljava/util/function/UnaryOperator;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,unaryOperator_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewListClass() {
       jclass clss = getEnv()->FindClass("java/util/List");
       if (NULL == clss) {
           std::cerr << " Can't find class java/util/List" << std::endl;
       }
       return clss;
   }
   
   static jclass ListClass = NULL;
   static inline jclass getListClass() {
       if (ListClass != NULL) {
           return ListClass;
       }
       ListClass = getNewListClass();
   }
  } // end namespace util

   namespace lang{
   
   // get JNI handle for class java.lang.Throwable
   static inline jclass getThrowableClass();
   
   Throwable::Throwable(jobject _jthis, bool copy): Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   Throwable::Throwable(const Throwable &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   Throwable::Throwable(Throwable  &throwable_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getThrowableClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/lang/Throwable;)V");
        if (NULL == mid) {
            std::cerr << "Class Throwable has no method constructor signature (Ljava/lang/Throwable;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,throwable_0.jthis);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Throwable jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   Throwable::Throwable(jstring string_0,Throwable  &throwable_1) {
    JNIEnv *env =getEnv();
    static jclass cls = getThrowableClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/lang/String;Ljava/lang/Throwable;)V");
        if (NULL == mid) {
            std::cerr << "Class Throwable has no method constructor signature (Ljava/lang/String;Ljava/lang/Throwable;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,string_0,throwable_1.jthis);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Throwable jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   Throwable::Throwable(jstring string_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getThrowableClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        if (NULL == mid) {
            std::cerr << "Class Throwable has no method constructor signature (Ljava/lang/String;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,string_0);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Throwable jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   Throwable::Throwable() {
    JNIEnv *env =getEnv();
    static jclass cls = getThrowableClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class Throwable has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Throwable jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for java.lang.Throwable
   Throwable::~Throwable() {
   	// Place-holder for later extensibility.
   }

   void Throwable::printStackTrace() {

   if(jthis == NULL) {
       std::cerr << "Call of method printStackTrace of java.lang.Throwable with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Throwable::printStackTrace jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "printStackTrace", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.lang.Throwable has no method named printStackTrace with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void Throwable::printStackTrace(::crclj::java::io::PrintStream  &printStream_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method printStackTrace of java.lang.Throwable with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Throwable::printStackTrace jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "printStackTrace", "(Ljava/io/PrintStream;)V");
       if (NULL == mid) {
           std::cerr << "Class java.lang.Throwable has no method named printStackTrace with signature (Ljava/io/PrintStream;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,printStream_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   Throwable Throwable::fillInStackTrace() {

   if(jthis == NULL) {
       std::cerr << "Call of method fillInStackTrace of java.lang.Throwable with jthis == NULL." << std::endl;
       Throwable nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Throwable::fillInStackTrace jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "fillInStackTrace", "()Ljava/lang/Throwable;");
       if (NULL == mid) {
           std::cerr << "Class java.lang.Throwable has no method named fillInStackTrace with signature ()Ljava/lang/Throwable;." << std::endl;
           Throwable nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Throwable retObject(retVal,false);
    return retObject;
   }
   Throwable Throwable::getCause() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCause of java.lang.Throwable with jthis == NULL." << std::endl;
       Throwable nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Throwable::getCause jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCause", "()Ljava/lang/Throwable;");
       if (NULL == mid) {
           std::cerr << "Class java.lang.Throwable has no method named getCause with signature ()Ljava/lang/Throwable;." << std::endl;
           Throwable nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Throwable retObject(retVal,false);
    return retObject;
   }
   Throwable Throwable::initCause(Throwable  &throwable_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method initCause of java.lang.Throwable with jthis == NULL." << std::endl;
       Throwable nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Throwable::initCause jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "initCause", "(Ljava/lang/Throwable;)Ljava/lang/Throwable;");
       if (NULL == mid) {
           std::cerr << "Class java.lang.Throwable has no method named initCause with signature (Ljava/lang/Throwable;)Ljava/lang/Throwable;." << std::endl;
           Throwable nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,throwable_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Throwable retObject(retVal,false);
    return retObject;
   }
   jstring Throwable::toString() {

   if(jthis == NULL) {
       std::cerr << "Call of method toString of java.lang.Throwable with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Throwable::toString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toString", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.lang.Throwable has no method named toString with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring Throwable::getMessage() {

   if(jthis == NULL) {
       std::cerr << "Call of method getMessage of java.lang.Throwable with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Throwable::getMessage jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getMessage", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.lang.Throwable has no method named getMessage with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring Throwable::getLocalizedMessage() {

   if(jthis == NULL) {
       std::cerr << "Call of method getLocalizedMessage of java.lang.Throwable with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Throwable::getLocalizedMessage jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getLocalizedMessage", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.lang.Throwable has no method named getLocalizedMessage with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void Throwable::addSuppressed(Throwable  &throwable_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method addSuppressed of java.lang.Throwable with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Throwable::addSuppressed jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "addSuppressed", "(Ljava/lang/Throwable;)V");
       if (NULL == mid) {
           std::cerr << "Class java.lang.Throwable has no method named addSuppressed with signature (Ljava/lang/Throwable;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,throwable_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   jobjectArray Throwable::getSuppressed() {

   if(jthis == NULL) {
       std::cerr << "Call of method getSuppressed of java.lang.Throwable with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Throwable::getSuppressed jthis=",jthis);
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getSuppressed", "()[Ljava/lang/Throwable;");
       if (NULL == mid) {
           std::cerr << "Class java.lang.Throwable has no method named getSuppressed with signature ()[Ljava/lang/Throwable;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewThrowableClass() {
       jclass clss = getEnv()->FindClass("java/lang/Throwable");
       if (NULL == clss) {
           std::cerr << " Can't find class java/lang/Throwable" << std::endl;
       }
       return clss;
   }
   
   static jclass ThrowableClass = NULL;
   static inline jclass getThrowableClass() {
       if (ThrowableClass != NULL) {
           return ThrowableClass;
       }
       ThrowableClass = getNewThrowableClass();
   }
  } // end namespace lang

   namespace io{
   
   // get JNI handle for class java.io.File
   static inline jclass getFileClass();
   
   File::File(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   File::File(const File &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   File::File(jstring string_0,jstring string_1) {
    JNIEnv *env =getEnv();
    static jclass cls = getFileClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/lang/String;Ljava/lang/String;)V");
        if (NULL == mid) {
            std::cerr << "Class File has no method constructor signature (Ljava/lang/String;Ljava/lang/String;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,string_0,string_1);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new File jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   File::File(jstring string_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getFileClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        if (NULL == mid) {
            std::cerr << "Class File has no method constructor signature (Ljava/lang/String;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,string_0);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new File jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   File::File(File  &file_0,jstring string_1) {
    JNIEnv *env =getEnv();
    static jclass cls = getFileClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/io/File;Ljava/lang/String;)V");
        if (NULL == mid) {
            std::cerr << "Class File has no method constructor signature (Ljava/io/File;Ljava/lang/String;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,file_0.jthis,string_1);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new File jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for java.io.File
   File::~File() {
   	// Place-holder for later extensibility.
   }

   jboolean File::equals(::crclj::java::lang::Object  &object_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method equals of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::equals jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named equals with signature (Ljava/lang/Object;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,object_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring File::toString() {

   if(jthis == NULL) {
       std::cerr << "Call of method toString of java.io.File with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::toString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toString", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named toString with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint File::hashCode() {

   if(jthis == NULL) {
       std::cerr << "Call of method hashCode of java.io.File with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::hashCode jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "hashCode", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named hashCode with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint File::compareTo(File  &file_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method compareTo of java.io.File with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::compareTo jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "compareTo", "(Ljava/io/File;)I");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named compareTo with signature (Ljava/io/File;)I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid ,file_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring File::getName() {

   if(jthis == NULL) {
       std::cerr << "Call of method getName of java.io.File with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::getName jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getName", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named getName with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jlong File::length() {

   if(jthis == NULL) {
       std::cerr << "Call of method length of java.io.File with jthis == NULL." << std::endl;
       return (jlong) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::length jthis=",jthis);
   jlong retVal= (jlong) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "length", "()J");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named length with signature ()J." << std::endl;
           return (jlong) -1;
       } else {
           retVal= (jlong)  env->CallLongMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring File::getParent() {

   if(jthis == NULL) {
       std::cerr << "Call of method getParent of java.io.File with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::getParent jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getParent", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named getParent with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean File::isAbsolute() {

   if(jthis == NULL) {
       std::cerr << "Call of method isAbsolute of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::isAbsolute jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isAbsolute", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named isAbsolute with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring File::getCanonicalPath() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCanonicalPath of java.io.File with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::getCanonicalPath jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCanonicalPath", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named getCanonicalPath with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean File::deleteMethod() {

   if(jthis == NULL) {
       std::cerr << "Call of method deleteMethod of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::deleteMethod jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "deleteMethod", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named deleteMethod with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean File::setReadOnly() {

   if(jthis == NULL) {
       std::cerr << "Call of method setReadOnly of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::setReadOnly jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setReadOnly", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named setReadOnly with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jobjectArray File::list() {

   if(jthis == NULL) {
       std::cerr << "Call of method list of java.io.File with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::list jthis=",jthis);
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "list", "()[Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named list with signature ()[Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   File File::getParentFile() {

   if(jthis == NULL) {
       std::cerr << "Call of method getParentFile of java.io.File with jthis == NULL." << std::endl;
       File nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::getParentFile jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getParentFile", "()Ljava/io/File;");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named getParentFile with signature ()Ljava/io/File;." << std::endl;
           File nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    File retObject(retVal,false);
    return retObject;
   }
   jstring File::getPath() {

   if(jthis == NULL) {
       std::cerr << "Call of method getPath of java.io.File with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::getPath jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getPath", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named getPath with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring File::getAbsolutePath() {

   if(jthis == NULL) {
       std::cerr << "Call of method getAbsolutePath of java.io.File with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::getAbsolutePath jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getAbsolutePath", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named getAbsolutePath with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   File File::getAbsoluteFile() {

   if(jthis == NULL) {
       std::cerr << "Call of method getAbsoluteFile of java.io.File with jthis == NULL." << std::endl;
       File nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::getAbsoluteFile jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getAbsoluteFile", "()Ljava/io/File;");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named getAbsoluteFile with signature ()Ljava/io/File;." << std::endl;
           File nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    File retObject(retVal,false);
    return retObject;
   }
   File File::getCanonicalFile() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCanonicalFile of java.io.File with jthis == NULL." << std::endl;
       File nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::getCanonicalFile jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCanonicalFile", "()Ljava/io/File;");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named getCanonicalFile with signature ()Ljava/io/File;." << std::endl;
           File nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    File retObject(retVal,false);
    return retObject;
   }
   jboolean File::canRead() {

   if(jthis == NULL) {
       std::cerr << "Call of method canRead of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::canRead jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "canRead", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named canRead with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean File::canWrite() {

   if(jthis == NULL) {
       std::cerr << "Call of method canWrite of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::canWrite jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "canWrite", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named canWrite with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean File::exists() {

   if(jthis == NULL) {
       std::cerr << "Call of method exists of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::exists jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "exists", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named exists with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean File::isDirectory() {

   if(jthis == NULL) {
       std::cerr << "Call of method isDirectory of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::isDirectory jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isDirectory", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named isDirectory with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean File::isFile() {

   if(jthis == NULL) {
       std::cerr << "Call of method isFile of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::isFile jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isFile", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named isFile with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean File::isHidden() {

   if(jthis == NULL) {
       std::cerr << "Call of method isHidden of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::isHidden jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isHidden", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named isHidden with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jlong File::lastModified() {

   if(jthis == NULL) {
       std::cerr << "Call of method lastModified of java.io.File with jthis == NULL." << std::endl;
       return (jlong) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::lastModified jthis=",jthis);
   jlong retVal= (jlong) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "lastModified", "()J");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named lastModified with signature ()J." << std::endl;
           return (jlong) -1;
       } else {
           retVal= (jlong)  env->CallLongMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean File::createNewFile() {

   if(jthis == NULL) {
       std::cerr << "Call of method createNewFile of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::createNewFile jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "createNewFile", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named createNewFile with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void File::deleteOnExit() {

   if(jthis == NULL) {
       std::cerr << "Call of method deleteOnExit of java.io.File with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::deleteOnExit jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "deleteOnExit", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named deleteOnExit with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jobjectArray File::listFiles() {

   if(jthis == NULL) {
       std::cerr << "Call of method listFiles of java.io.File with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::listFiles jthis=",jthis);
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "listFiles", "()[Ljava/io/File;");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named listFiles with signature ()[Ljava/io/File;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean File::mkdir() {

   if(jthis == NULL) {
       std::cerr << "Call of method mkdir of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::mkdir jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "mkdir", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named mkdir with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean File::mkdirs() {

   if(jthis == NULL) {
       std::cerr << "Call of method mkdirs of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::mkdirs jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "mkdirs", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named mkdirs with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean File::renameTo(File  &file_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method renameTo of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::renameTo jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "renameTo", "(Ljava/io/File;)Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named renameTo with signature (Ljava/io/File;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,file_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean File::setLastModified(jlong long_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setLastModified of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::setLastModified jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setLastModified", "(J)Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named setLastModified with signature (J)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,long_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean File::setWritable(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setWritable of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::setWritable jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setWritable", "(Z)Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named setWritable with signature (Z)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean File::setWritable(jboolean boolean_0,jboolean boolean_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method setWritable of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::setWritable jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setWritable", "(ZZ)Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named setWritable with signature (ZZ)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,boolean_0,boolean_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean File::setReadable(jboolean boolean_0,jboolean boolean_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method setReadable of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::setReadable jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setReadable", "(ZZ)Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named setReadable with signature (ZZ)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,boolean_0,boolean_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean File::setReadable(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setReadable of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::setReadable jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setReadable", "(Z)Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named setReadable with signature (Z)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean File::setExecutable(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setExecutable of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::setExecutable jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setExecutable", "(Z)Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named setExecutable with signature (Z)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean File::setExecutable(jboolean boolean_0,jboolean boolean_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method setExecutable of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::setExecutable jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setExecutable", "(ZZ)Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named setExecutable with signature (ZZ)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,boolean_0,boolean_1 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean File::canExecute() {

   if(jthis == NULL) {
       std::cerr << "Call of method canExecute of java.io.File with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::canExecute jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "canExecute", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named canExecute with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jobjectArray File::listRoots() {

   JNIEnv *env =getEnv();
   static jclass cls = getFileClass();
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "listRoots", "()[Ljava/io/File;");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named listRoots with signature ()[Ljava/io/File;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallStaticObjectMethod( cls, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jlong File::getTotalSpace() {

   if(jthis == NULL) {
       std::cerr << "Call of method getTotalSpace of java.io.File with jthis == NULL." << std::endl;
       return (jlong) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::getTotalSpace jthis=",jthis);
   jlong retVal= (jlong) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getTotalSpace", "()J");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named getTotalSpace with signature ()J." << std::endl;
           return (jlong) -1;
       } else {
           retVal= (jlong)  env->CallLongMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jlong File::getFreeSpace() {

   if(jthis == NULL) {
       std::cerr << "Call of method getFreeSpace of java.io.File with jthis == NULL." << std::endl;
       return (jlong) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::getFreeSpace jthis=",jthis);
   jlong retVal= (jlong) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getFreeSpace", "()J");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named getFreeSpace with signature ()J." << std::endl;
           return (jlong) -1;
       } else {
           retVal= (jlong)  env->CallLongMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jlong File::getUsableSpace() {

   if(jthis == NULL) {
       std::cerr << "Call of method getUsableSpace of java.io.File with jthis == NULL." << std::endl;
       return (jlong) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," File::getUsableSpace jthis=",jthis);
   jlong retVal= (jlong) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getUsableSpace", "()J");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named getUsableSpace with signature ()J." << std::endl;
           return (jlong) -1;
       } else {
           retVal= (jlong)  env->CallLongMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   File File::createTempFile(jstring string_0,jstring string_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getFileClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "createTempFile", "(Ljava/lang/String;Ljava/lang/String;)Ljava/io/File;");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named createTempFile with signature (Ljava/lang/String;Ljava/lang/String;)Ljava/io/File;." << std::endl;
           File nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,string_0,string_1 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    File retObject(retVal,false);
    return retObject;
   }
   File File::createTempFile(jstring string_0,jstring string_1,File  &file_2) {

   JNIEnv *env =getEnv();
   static jclass cls = getFileClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "createTempFile", "(Ljava/lang/String;Ljava/lang/String;Ljava/io/File;)Ljava/io/File;");
       if (NULL == mid) {
           std::cerr << "Class java.io.File has no method named createTempFile with signature (Ljava/lang/String;Ljava/lang/String;Ljava/io/File;)Ljava/io/File;." << std::endl;
           File nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,string_0,string_1,file_2.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    File retObject(retVal,false);
    return retObject;
   }
   static jclass getNewFileClass() {
       jclass clss = getEnv()->FindClass("java/io/File");
       if (NULL == clss) {
           std::cerr << " Can't find class java/io/File" << std::endl;
       }
       return clss;
   }
   
   static jclass FileClass = NULL;
   static inline jclass getFileClass() {
       if (FileClass != NULL) {
           return FileClass;
       }
       FileClass = getNewFileClass();
   }
  } // end namespace io
 } // end namespace java

  namespace javax{
   namespace xml{
    namespace bind{
    
    // get JNI handle for class javax.xml.bind.JAXBElement
    static inline jclass getJAXBElementClass();
    
    JAXBElement::JAXBElement(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
            // Place holder for future extensibility
    }
    
    JAXBElement::JAXBElement(const JAXBElement &objref) {
        jobject _jthis = objref.jthis;
        if (_jthis != NULL) {
            jthis = getEnv()->NewGlobalRef(_jthis);
        }
    }

    // Destructor for javax.xml.bind.JAXBElement
    JAXBElement::~JAXBElement() {
    	// Place-holder for later extensibility.
    }

    jboolean JAXBElement::isNil() {

    if(jthis == NULL) {
        std::cerr << "Call of method isNil of javax.xml.bind.JAXBElement with jthis == NULL." << std::endl;
        return false;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JAXBElement::isNil jthis=",jthis);
    jboolean retVal=false;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "isNil", "()Z");
        if (NULL == mid) {
            std::cerr << "Class javax.xml.bind.JAXBElement has no method named isNil with signature ()Z." << std::endl;
            return false;
        } else {
            retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
        }
    }
    releaseEnv(env);
    return retVal;
    }
    void JAXBElement::setNil(jboolean boolean_0) {

    if(jthis == NULL) {
        std::cerr << "Call of method setNil of javax.xml.bind.JAXBElement with jthis == NULL." << std::endl;
        
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JAXBElement::setNil jthis=",jthis);
    
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "setNil", "(Z)V");
        if (NULL == mid) {
            std::cerr << "Class javax.xml.bind.JAXBElement has no method named setNil with signature (Z)V." << std::endl;
            
        } else {
             env->CallVoidMethod(jthis, mid ,boolean_0 );
        }
    }
    releaseEnv(env);
    
    }
    jboolean JAXBElement::isGlobalScope() {

    if(jthis == NULL) {
        std::cerr << "Call of method isGlobalScope of javax.xml.bind.JAXBElement with jthis == NULL." << std::endl;
        return false;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JAXBElement::isGlobalScope jthis=",jthis);
    jboolean retVal=false;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "isGlobalScope", "()Z");
        if (NULL == mid) {
            std::cerr << "Class javax.xml.bind.JAXBElement has no method named isGlobalScope with signature ()Z." << std::endl;
            return false;
        } else {
            retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
        }
    }
    releaseEnv(env);
    return retVal;
    }
    jboolean JAXBElement::isTypeSubstituted() {

    if(jthis == NULL) {
        std::cerr << "Call of method isTypeSubstituted of javax.xml.bind.JAXBElement with jthis == NULL." << std::endl;
        return false;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JAXBElement::isTypeSubstituted jthis=",jthis);
    jboolean retVal=false;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "isTypeSubstituted", "()Z");
        if (NULL == mid) {
            std::cerr << "Class javax.xml.bind.JAXBElement has no method named isTypeSubstituted with signature ()Z." << std::endl;
            return false;
        } else {
            retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
        }
    }
    releaseEnv(env);
    return retVal;
    }
    ::crclj::java::lang::Object JAXBElement::getValue() {

    if(jthis == NULL) {
        std::cerr << "Call of method getValue of javax.xml.bind.JAXBElement with jthis == NULL." << std::endl;
        ::crclj::java::lang::Object nullObject((jobject)NULL,false); return nullObject;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JAXBElement::getValue jthis=",jthis);
    jobject retVal=NULL;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "getValue", "()Ljava/lang/Object;");
        if (NULL == mid) {
            std::cerr << "Class javax.xml.bind.JAXBElement has no method named getValue with signature ()Ljava/lang/Object;." << std::endl;
            ::crclj::java::lang::Object nullObject((jobject)NULL,false); return nullObject;
        } else {
            retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
        }
    }
    releaseEnv(env);
         
     jobjectRefType ref = env->GetObjectRefType(retVal);
     std::cout << "ref=" << ref << std::endl;
     std::cout << "retVal=" << retVal << std::endl;
     ::crclj::java::lang::Object retObject(retVal,false);
     return retObject;
    }
    void JAXBElement::setValue(::crclj::java::lang::Object  &object_0) {

    if(jthis == NULL) {
        std::cerr << "Call of method setValue of javax.xml.bind.JAXBElement with jthis == NULL." << std::endl;
        
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," JAXBElement::setValue jthis=",jthis);
    
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "setValue", "(Ljava/lang/Object;)V");
        if (NULL == mid) {
            std::cerr << "Class javax.xml.bind.JAXBElement has no method named setValue with signature (Ljava/lang/Object;)V." << std::endl;
            
        } else {
             env->CallVoidMethod(jthis, mid ,object_0.jthis );
        }
    }
    releaseEnv(env);
    
    }
    static jclass getNewJAXBElementClass() {
        jclass clss = getEnv()->FindClass("javax/xml/bind/JAXBElement");
        if (NULL == clss) {
            std::cerr << " Can't find class javax/xml/bind/JAXBElement" << std::endl;
        }
        return clss;
    }
    
    static jclass JAXBElementClass = NULL;
    static inline jclass getJAXBElementClass() {
        if (JAXBElementClass != NULL) {
            return JAXBElementClass;
        }
        JAXBElementClass = getNewJAXBElementClass();
    }
   } // end namespace bind
  } // end namespace xml
 } // end namespace javax

  namespace org{
   namespace apache{
    namespace commons{
     namespace math3{
      namespace geometry{
       namespace euclidean{
        namespace threed{
        
        // get JNI handle for class org.apache.commons.math3.geometry.euclidean.threed.Vector3D
        static inline jclass getVector3DClass();
        
        Vector3D::Vector3D(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
                // Place holder for future extensibility
        }
        
        Vector3D::Vector3D(const Vector3D &objref) {
            jobject _jthis = objref.jthis;
            if (_jthis != NULL) {
                jthis = getEnv()->NewGlobalRef(_jthis);
            }
        }
        Vector3D::Vector3D(jdouble double_0,Vector3D  &vector3D_1) {
         JNIEnv *env =getEnv();
         static jclass cls = getVector3DClass();
         if (cls != NULL) {
             static jmethodID mid = env->GetMethodID(cls, "<init>", "(DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V");
             if (NULL == mid) {
                 std::cerr << "Class Vector3D has no method constructor signature (DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V" << std::endl;
             } else {
                 jthis = env->NewObject(cls, mid ,double_0,vector3D_1.jthis);
                 jobjectRefType ref = env->GetObjectRefType(jthis);
                 if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Vector3D jthis=",jthis);
                 if(ref != JNIGlobalRefType) {
                     jthis = env->NewGlobalRef(jthis);
                 }
             }
         }
         releaseEnv(env);
        }

        Vector3D::Vector3D(jdouble double_0,jdouble double_1) {
         JNIEnv *env =getEnv();
         static jclass cls = getVector3DClass();
         if (cls != NULL) {
             static jmethodID mid = env->GetMethodID(cls, "<init>", "(DD)V");
             if (NULL == mid) {
                 std::cerr << "Class Vector3D has no method constructor signature (DD)V" << std::endl;
             } else {
                 jthis = env->NewObject(cls, mid ,double_0,double_1);
                 jobjectRefType ref = env->GetObjectRefType(jthis);
                 if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Vector3D jthis=",jthis);
                 if(ref != JNIGlobalRefType) {
                     jthis = env->NewGlobalRef(jthis);
                 }
             }
         }
         releaseEnv(env);
        }

        Vector3D::Vector3D(jdoubleArray doubleArray_0) {
         JNIEnv *env =getEnv();
         static jclass cls = getVector3DClass();
         if (cls != NULL) {
             static jmethodID mid = env->GetMethodID(cls, "<init>", "([D)V");
             if (NULL == mid) {
                 std::cerr << "Class Vector3D has no method constructor signature ([D)V" << std::endl;
             } else {
                 jthis = env->NewObject(cls, mid ,doubleArray_0);
                 jobjectRefType ref = env->GetObjectRefType(jthis);
                 if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Vector3D jthis=",jthis);
                 if(ref != JNIGlobalRefType) {
                     jthis = env->NewGlobalRef(jthis);
                 }
             }
         }
         releaseEnv(env);
        }

        Vector3D::Vector3D(jdouble double_0,jdouble double_1,jdouble double_2) {
         JNIEnv *env =getEnv();
         static jclass cls = getVector3DClass();
         if (cls != NULL) {
             static jmethodID mid = env->GetMethodID(cls, "<init>", "(DDD)V");
             if (NULL == mid) {
                 std::cerr << "Class Vector3D has no method constructor signature (DDD)V" << std::endl;
             } else {
                 jthis = env->NewObject(cls, mid ,double_0,double_1,double_2);
                 jobjectRefType ref = env->GetObjectRefType(jthis);
                 if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Vector3D jthis=",jthis);
                 if(ref != JNIGlobalRefType) {
                     jthis = env->NewGlobalRef(jthis);
                 }
             }
         }
         releaseEnv(env);
        }

        Vector3D::Vector3D(jdouble double_0,Vector3D  &vector3D_1,jdouble double_2,Vector3D  &vector3D_3) {
         JNIEnv *env =getEnv();
         static jclass cls = getVector3DClass();
         if (cls != NULL) {
             static jmethodID mid = env->GetMethodID(cls, "<init>", "(DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V");
             if (NULL == mid) {
                 std::cerr << "Class Vector3D has no method constructor signature (DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V" << std::endl;
             } else {
                 jthis = env->NewObject(cls, mid ,double_0,vector3D_1.jthis,double_2,vector3D_3.jthis);
                 jobjectRefType ref = env->GetObjectRefType(jthis);
                 if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Vector3D jthis=",jthis);
                 if(ref != JNIGlobalRefType) {
                     jthis = env->NewGlobalRef(jthis);
                 }
             }
         }
         releaseEnv(env);
        }

        Vector3D::Vector3D(jdouble double_0,Vector3D  &vector3D_1,jdouble double_2,Vector3D  &vector3D_3,jdouble double_4,Vector3D  &vector3D_5) {
         JNIEnv *env =getEnv();
         static jclass cls = getVector3DClass();
         if (cls != NULL) {
             static jmethodID mid = env->GetMethodID(cls, "<init>", "(DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V");
             if (NULL == mid) {
                 std::cerr << "Class Vector3D has no method constructor signature (DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V" << std::endl;
             } else {
                 jthis = env->NewObject(cls, mid ,double_0,vector3D_1.jthis,double_2,vector3D_3.jthis,double_4,vector3D_5.jthis);
                 jobjectRefType ref = env->GetObjectRefType(jthis);
                 if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Vector3D jthis=",jthis);
                 if(ref != JNIGlobalRefType) {
                     jthis = env->NewGlobalRef(jthis);
                 }
             }
         }
         releaseEnv(env);
        }

        Vector3D::Vector3D(jdouble double_0,Vector3D  &vector3D_1,jdouble double_2,Vector3D  &vector3D_3,jdouble double_4,Vector3D  &vector3D_5,jdouble double_6,Vector3D  &vector3D_7) {
         JNIEnv *env =getEnv();
         static jclass cls = getVector3DClass();
         if (cls != NULL) {
             static jmethodID mid = env->GetMethodID(cls, "<init>", "(DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V");
             if (NULL == mid) {
                 std::cerr << "Class Vector3D has no method constructor signature (DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V" << std::endl;
             } else {
                 jthis = env->NewObject(cls, mid ,double_0,vector3D_1.jthis,double_2,vector3D_3.jthis,double_4,vector3D_5.jthis,double_6,vector3D_7.jthis);
                 jobjectRefType ref = env->GetObjectRefType(jthis);
                 if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Vector3D jthis=",jthis);
                 if(ref != JNIGlobalRefType) {
                     jthis = env->NewGlobalRef(jthis);
                 }
             }
         }
         releaseEnv(env);
        }


        // Destructor for org.apache.commons.math3.geometry.euclidean.threed.Vector3D
        Vector3D::~Vector3D() {
        	// Place-holder for later extensibility.
        }

        jdouble Vector3D::getAlpha() {

        if(jthis == NULL) {
            std::cerr << "Call of method getAlpha of org.apache.commons.math3.geometry.euclidean.threed.Vector3D with jthis == NULL." << std::endl;
            return (jdouble) -1.0;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Vector3D::getAlpha jthis=",jthis);
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "getAlpha", "()D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named getAlpha with signature ()D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jdouble Vector3D::getX() {

        if(jthis == NULL) {
            std::cerr << "Call of method getX of org.apache.commons.math3.geometry.euclidean.threed.Vector3D with jthis == NULL." << std::endl;
            return (jdouble) -1.0;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Vector3D::getX jthis=",jthis);
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "getX", "()D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named getX with signature ()D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jdouble Vector3D::getY() {

        if(jthis == NULL) {
            std::cerr << "Call of method getY of org.apache.commons.math3.geometry.euclidean.threed.Vector3D with jthis == NULL." << std::endl;
            return (jdouble) -1.0;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Vector3D::getY jthis=",jthis);
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "getY", "()D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named getY with signature ()D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jdouble Vector3D::distanceSq(Vector3D  &vector3D_0,Vector3D  &vector3D_1) {

        JNIEnv *env =getEnv();
        static jclass cls = getVector3DClass();
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetStaticMethodID(cls, "distanceSq", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named distanceSq with signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallStaticDoubleMethod( cls, mid ,vector3D_0.jthis,vector3D_1.jthis );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jdouble Vector3D::distance(Vector3D  &vector3D_0,Vector3D  &vector3D_1) {

        JNIEnv *env =getEnv();
        static jclass cls = getVector3DClass();
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetStaticMethodID(cls, "distance", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named distance with signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallStaticDoubleMethod( cls, mid ,vector3D_0.jthis,vector3D_1.jthis );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jdouble Vector3D::angle(Vector3D  &vector3D_0,Vector3D  &vector3D_1) {

        JNIEnv *env =getEnv();
        static jclass cls = getVector3DClass();
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetStaticMethodID(cls, "angle", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named angle with signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallStaticDoubleMethod( cls, mid ,vector3D_0.jthis,vector3D_1.jthis );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jdouble Vector3D::getZ() {

        if(jthis == NULL) {
            std::cerr << "Call of method getZ of org.apache.commons.math3.geometry.euclidean.threed.Vector3D with jthis == NULL." << std::endl;
            return (jdouble) -1.0;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Vector3D::getZ jthis=",jthis);
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "getZ", "()D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named getZ with signature ()D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        Vector3D Vector3D::negate() {

        if(jthis == NULL) {
            std::cerr << "Call of method negate of org.apache.commons.math3.geometry.euclidean.threed.Vector3D with jthis == NULL." << std::endl;
            Vector3D nullObject((jobject)NULL,false); return nullObject;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Vector3D::negate jthis=",jthis);
        jobject retVal=NULL;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "negate", "()Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named negate with signature ()Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;." << std::endl;
                Vector3D nullObject((jobject)NULL,false); return nullObject;
            } else {
                retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
                 
         jobjectRefType ref = env->GetObjectRefType(retVal);
         std::cout << "ref=" << ref << std::endl;
         std::cout << "retVal=" << retVal << std::endl;
         Vector3D retObject(retVal,false);
         return retObject;
        }
        Vector3D Vector3D::getZero() {

        if(jthis == NULL) {
            std::cerr << "Call of method getZero of org.apache.commons.math3.geometry.euclidean.threed.Vector3D with jthis == NULL." << std::endl;
            Vector3D nullObject((jobject)NULL,false); return nullObject;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Vector3D::getZero jthis=",jthis);
        jobject retVal=NULL;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "getZero", "()Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named getZero with signature ()Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;." << std::endl;
                Vector3D nullObject((jobject)NULL,false); return nullObject;
            } else {
                retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
                 
         jobjectRefType ref = env->GetObjectRefType(retVal);
         std::cout << "ref=" << ref << std::endl;
         std::cout << "retVal=" << retVal << std::endl;
         Vector3D retObject(retVal,false);
         return retObject;
        }
        Vector3D Vector3D::scalarMultiply(jdouble double_0) {

        if(jthis == NULL) {
            std::cerr << "Call of method scalarMultiply of org.apache.commons.math3.geometry.euclidean.threed.Vector3D with jthis == NULL." << std::endl;
            Vector3D nullObject((jobject)NULL,false); return nullObject;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Vector3D::scalarMultiply jthis=",jthis);
        jobject retVal=NULL;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "scalarMultiply", "(D)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named scalarMultiply with signature (D)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;." << std::endl;
                Vector3D nullObject((jobject)NULL,false); return nullObject;
            } else {
                retVal= (jobject)  env->CallObjectMethod(jthis, mid ,double_0 );
            }
        }
        releaseEnv(env);
                 
         jobjectRefType ref = env->GetObjectRefType(retVal);
         std::cout << "ref=" << ref << std::endl;
         std::cout << "retVal=" << retVal << std::endl;
         Vector3D retObject(retVal,false);
         return retObject;
        }
        jdouble Vector3D::dotProduct(Vector3D  &vector3D_0,Vector3D  &vector3D_1) {

        JNIEnv *env =getEnv();
        static jclass cls = getVector3DClass();
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetStaticMethodID(cls, "dotProduct", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named dotProduct with signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallStaticDoubleMethod( cls, mid ,vector3D_0.jthis,vector3D_1.jthis );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jdouble Vector3D::distance1(Vector3D  &vector3D_0,Vector3D  &vector3D_1) {

        JNIEnv *env =getEnv();
        static jclass cls = getVector3DClass();
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetStaticMethodID(cls, "distance1", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named distance1 with signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallStaticDoubleMethod( cls, mid ,vector3D_0.jthis,vector3D_1.jthis );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jdouble Vector3D::distanceInf(Vector3D  &vector3D_0,Vector3D  &vector3D_1) {

        JNIEnv *env =getEnv();
        static jclass cls = getVector3DClass();
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetStaticMethodID(cls, "distanceInf", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named distanceInf with signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallStaticDoubleMethod( cls, mid ,vector3D_0.jthis,vector3D_1.jthis );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jdouble Vector3D::getNorm() {

        if(jthis == NULL) {
            std::cerr << "Call of method getNorm of org.apache.commons.math3.geometry.euclidean.threed.Vector3D with jthis == NULL." << std::endl;
            return (jdouble) -1.0;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Vector3D::getNorm jthis=",jthis);
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "getNorm", "()D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named getNorm with signature ()D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jdouble Vector3D::getNorm1() {

        if(jthis == NULL) {
            std::cerr << "Call of method getNorm1 of org.apache.commons.math3.geometry.euclidean.threed.Vector3D with jthis == NULL." << std::endl;
            return (jdouble) -1.0;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Vector3D::getNorm1 jthis=",jthis);
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "getNorm1", "()D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named getNorm1 with signature ()D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jdouble Vector3D::getNormSq() {

        if(jthis == NULL) {
            std::cerr << "Call of method getNormSq of org.apache.commons.math3.geometry.euclidean.threed.Vector3D with jthis == NULL." << std::endl;
            return (jdouble) -1.0;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Vector3D::getNormSq jthis=",jthis);
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "getNormSq", "()D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named getNormSq with signature ()D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jdouble Vector3D::getNormInf() {

        if(jthis == NULL) {
            std::cerr << "Call of method getNormInf of org.apache.commons.math3.geometry.euclidean.threed.Vector3D with jthis == NULL." << std::endl;
            return (jdouble) -1.0;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Vector3D::getNormInf jthis=",jthis);
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "getNormInf", "()D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named getNormInf with signature ()D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jdouble Vector3D::getDelta() {

        if(jthis == NULL) {
            std::cerr << "Call of method getDelta of org.apache.commons.math3.geometry.euclidean.threed.Vector3D with jthis == NULL." << std::endl;
            return (jdouble) -1.0;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Vector3D::getDelta jthis=",jthis);
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "getDelta", "()D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named getDelta with signature ()D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        Vector3D Vector3D::orthogonal() {

        if(jthis == NULL) {
            std::cerr << "Call of method orthogonal of org.apache.commons.math3.geometry.euclidean.threed.Vector3D with jthis == NULL." << std::endl;
            Vector3D nullObject((jobject)NULL,false); return nullObject;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Vector3D::orthogonal jthis=",jthis);
        jobject retVal=NULL;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "orthogonal", "()Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named orthogonal with signature ()Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;." << std::endl;
                Vector3D nullObject((jobject)NULL,false); return nullObject;
            } else {
                retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
                 
         jobjectRefType ref = env->GetObjectRefType(retVal);
         std::cout << "ref=" << ref << std::endl;
         std::cout << "retVal=" << retVal << std::endl;
         Vector3D retObject(retVal,false);
         return retObject;
        }
        Vector3D Vector3D::crossProduct(Vector3D  &vector3D_0,Vector3D  &vector3D_1) {

        JNIEnv *env =getEnv();
        static jclass cls = getVector3DClass();
        jobject retVal=NULL;
        if (cls != NULL) {
            static jmethodID mid = env->GetStaticMethodID(cls, "crossProduct", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named crossProduct with signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;." << std::endl;
                Vector3D nullObject((jobject)NULL,false); return nullObject;
            } else {
                retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,vector3D_0.jthis,vector3D_1.jthis );
            }
        }
        releaseEnv(env);
                 
         jobjectRefType ref = env->GetObjectRefType(retVal);
         std::cout << "ref=" << ref << std::endl;
         std::cout << "retVal=" << retVal << std::endl;
         Vector3D retObject(retVal,false);
         return retObject;
        }
        jboolean Vector3D::equals(::crclj::java::lang::Object  &object_0) {

        if(jthis == NULL) {
            std::cerr << "Call of method equals of org.apache.commons.math3.geometry.euclidean.threed.Vector3D with jthis == NULL." << std::endl;
            return false;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Vector3D::equals jthis=",jthis);
        jboolean retVal=false;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named equals with signature (Ljava/lang/Object;)Z." << std::endl;
                return false;
            } else {
                retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,object_0.jthis );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jstring Vector3D::toString() {

        if(jthis == NULL) {
            std::cerr << "Call of method toString of org.apache.commons.math3.geometry.euclidean.threed.Vector3D with jthis == NULL." << std::endl;
            return NULL;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Vector3D::toString jthis=",jthis);
        jstring retVal=NULL;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "toString", "()Ljava/lang/String;");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named toString with signature ()Ljava/lang/String;." << std::endl;
                return NULL;
            } else {
                retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jint Vector3D::hashCode() {

        if(jthis == NULL) {
            std::cerr << "Call of method hashCode of org.apache.commons.math3.geometry.euclidean.threed.Vector3D with jthis == NULL." << std::endl;
            return (jint) -1;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Vector3D::hashCode jthis=",jthis);
        jint retVal= (jint) -1;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "hashCode", "()I");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named hashCode with signature ()I." << std::endl;
                return (jint) -1;
            } else {
                retVal= (jint)  env->CallIntMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jdoubleArray Vector3D::toArray() {

        if(jthis == NULL) {
            std::cerr << "Call of method toArray of org.apache.commons.math3.geometry.euclidean.threed.Vector3D with jthis == NULL." << std::endl;
            return NULL;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Vector3D::toArray jthis=",jthis);
        jdoubleArray retVal=NULL;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "toArray", "()[D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named toArray with signature ()[D." << std::endl;
                return NULL;
            } else {
                retVal= (jdoubleArray)  env->CallObjectMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jboolean Vector3D::isNaN() {

        if(jthis == NULL) {
            std::cerr << "Call of method isNaN of org.apache.commons.math3.geometry.euclidean.threed.Vector3D with jthis == NULL." << std::endl;
            return false;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Vector3D::isNaN jthis=",jthis);
        jboolean retVal=false;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "isNaN", "()Z");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named isNaN with signature ()Z." << std::endl;
                return false;
            } else {
                retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        Vector3D Vector3D::normalize() {

        if(jthis == NULL) {
            std::cerr << "Call of method normalize of org.apache.commons.math3.geometry.euclidean.threed.Vector3D with jthis == NULL." << std::endl;
            Vector3D nullObject((jobject)NULL,false); return nullObject;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Vector3D::normalize jthis=",jthis);
        jobject retVal=NULL;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "normalize", "()Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named normalize with signature ()Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;." << std::endl;
                Vector3D nullObject((jobject)NULL,false); return nullObject;
            } else {
                retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
                 
         jobjectRefType ref = env->GetObjectRefType(retVal);
         std::cout << "ref=" << ref << std::endl;
         std::cout << "retVal=" << retVal << std::endl;
         Vector3D retObject(retVal,false);
         return retObject;
        }
        jboolean Vector3D::isInfinite() {

        if(jthis == NULL) {
            std::cerr << "Call of method isInfinite of org.apache.commons.math3.geometry.euclidean.threed.Vector3D with jthis == NULL." << std::endl;
            return false;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Vector3D::isInfinite jthis=",jthis);
        jboolean retVal=false;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "isInfinite", "()Z");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Vector3D has no method named isInfinite with signature ()Z." << std::endl;
                return false;
            } else {
                retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        static jclass getNewVector3DClass() {
            jclass clss = getEnv()->FindClass("org/apache/commons/math3/geometry/euclidean/threed/Vector3D");
            if (NULL == clss) {
                std::cerr << " Can't find class org/apache/commons/math3/geometry/euclidean/threed/Vector3D" << std::endl;
            }
            return clss;
        }
        
        static jclass Vector3DClass = NULL;
        static inline jclass getVector3DClass() {
            if (Vector3DClass != NULL) {
                return Vector3DClass;
            }
            Vector3DClass = getNewVector3DClass();
        }
        
        // get JNI handle for class org.apache.commons.math3.geometry.euclidean.threed.Rotation
        static inline jclass getRotationClass();
        
        Rotation::Rotation(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
                // Place holder for future extensibility
        }
        
        Rotation::Rotation(const Rotation &objref) {
            jobject _jthis = objref.jthis;
            if (_jthis != NULL) {
                jthis = getEnv()->NewGlobalRef(_jthis);
            }
        }
        Rotation::Rotation(Vector3D  &vector3D_0,jdouble double_1) {
         JNIEnv *env =getEnv();
         static jclass cls = getRotationClass();
         if (cls != NULL) {
             static jmethodID mid = env->GetMethodID(cls, "<init>", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;D)V");
             if (NULL == mid) {
                 std::cerr << "Class Rotation has no method constructor signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;D)V" << std::endl;
             } else {
                 jthis = env->NewObject(cls, mid ,vector3D_0.jthis,double_1);
                 jobjectRefType ref = env->GetObjectRefType(jthis);
                 if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Rotation jthis=",jthis);
                 if(ref != JNIGlobalRefType) {
                     jthis = env->NewGlobalRef(jthis);
                 }
             }
         }
         releaseEnv(env);
        }

        Rotation::Rotation(Vector3D  &vector3D_0,Vector3D  &vector3D_1,Vector3D  &vector3D_2,Vector3D  &vector3D_3) {
         JNIEnv *env =getEnv();
         static jclass cls = getRotationClass();
         if (cls != NULL) {
             static jmethodID mid = env->GetMethodID(cls, "<init>", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V");
             if (NULL == mid) {
                 std::cerr << "Class Rotation has no method constructor signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V" << std::endl;
             } else {
                 jthis = env->NewObject(cls, mid ,vector3D_0.jthis,vector3D_1.jthis,vector3D_2.jthis,vector3D_3.jthis);
                 jobjectRefType ref = env->GetObjectRefType(jthis);
                 if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Rotation jthis=",jthis);
                 if(ref != JNIGlobalRefType) {
                     jthis = env->NewGlobalRef(jthis);
                 }
             }
         }
         releaseEnv(env);
        }

        Rotation::Rotation(jdouble double_0,jdouble double_1,jdouble double_2,jdouble double_3,jboolean boolean_4) {
         JNIEnv *env =getEnv();
         static jclass cls = getRotationClass();
         if (cls != NULL) {
             static jmethodID mid = env->GetMethodID(cls, "<init>", "(DDDDZ)V");
             if (NULL == mid) {
                 std::cerr << "Class Rotation has no method constructor signature (DDDDZ)V" << std::endl;
             } else {
                 jthis = env->NewObject(cls, mid ,double_0,double_1,double_2,double_3,boolean_4);
                 jobjectRefType ref = env->GetObjectRefType(jthis);
                 if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Rotation jthis=",jthis);
                 if(ref != JNIGlobalRefType) {
                     jthis = env->NewGlobalRef(jthis);
                 }
             }
         }
         releaseEnv(env);
        }

        Rotation::Rotation(Vector3D  &vector3D_0,Vector3D  &vector3D_1) {
         JNIEnv *env =getEnv();
         static jclass cls = getRotationClass();
         if (cls != NULL) {
             static jmethodID mid = env->GetMethodID(cls, "<init>", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V");
             if (NULL == mid) {
                 std::cerr << "Class Rotation has no method constructor signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V" << std::endl;
             } else {
                 jthis = env->NewObject(cls, mid ,vector3D_0.jthis,vector3D_1.jthis);
                 jobjectRefType ref = env->GetObjectRefType(jthis);
                 if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Rotation jthis=",jthis);
                 if(ref != JNIGlobalRefType) {
                     jthis = env->NewGlobalRef(jthis);
                 }
             }
         }
         releaseEnv(env);
        }


        // Destructor for org.apache.commons.math3.geometry.euclidean.threed.Rotation
        Rotation::~Rotation() {
        	// Place-holder for later extensibility.
        }

        Vector3D Rotation::getAxis() {

        if(jthis == NULL) {
            std::cerr << "Call of method getAxis of org.apache.commons.math3.geometry.euclidean.threed.Rotation with jthis == NULL." << std::endl;
            Vector3D nullObject((jobject)NULL,false); return nullObject;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Rotation::getAxis jthis=",jthis);
        jobject retVal=NULL;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "getAxis", "()Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Rotation has no method named getAxis with signature ()Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;." << std::endl;
                Vector3D nullObject((jobject)NULL,false); return nullObject;
            } else {
                retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
                 
         jobjectRefType ref = env->GetObjectRefType(retVal);
         std::cout << "ref=" << ref << std::endl;
         std::cout << "retVal=" << retVal << std::endl;
         Vector3D retObject(retVal,false);
         return retObject;
        }
        jdouble Rotation::distance(Rotation  &rotation_0,Rotation  &rotation_1) {

        JNIEnv *env =getEnv();
        static jclass cls = getRotationClass();
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetStaticMethodID(cls, "distance", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Rotation;Lorg/apache/commons/math3/geometry/euclidean/threed/Rotation;)D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Rotation has no method named distance with signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Rotation;Lorg/apache/commons/math3/geometry/euclidean/threed/Rotation;)D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallStaticDoubleMethod( cls, mid ,rotation_0.jthis,rotation_1.jthis );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jdouble Rotation::getAngle() {

        if(jthis == NULL) {
            std::cerr << "Call of method getAngle of org.apache.commons.math3.geometry.euclidean.threed.Rotation with jthis == NULL." << std::endl;
            return (jdouble) -1.0;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Rotation::getAngle jthis=",jthis);
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "getAngle", "()D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Rotation has no method named getAngle with signature ()D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        Rotation Rotation::revert() {

        if(jthis == NULL) {
            std::cerr << "Call of method revert of org.apache.commons.math3.geometry.euclidean.threed.Rotation with jthis == NULL." << std::endl;
            Rotation nullObject((jobject)NULL,false); return nullObject;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Rotation::revert jthis=",jthis);
        jobject retVal=NULL;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "revert", "()Lorg/apache/commons/math3/geometry/euclidean/threed/Rotation;");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Rotation has no method named revert with signature ()Lorg/apache/commons/math3/geometry/euclidean/threed/Rotation;." << std::endl;
                Rotation nullObject((jobject)NULL,false); return nullObject;
            } else {
                retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
                 
         jobjectRefType ref = env->GetObjectRefType(retVal);
         std::cout << "ref=" << ref << std::endl;
         std::cout << "retVal=" << retVal << std::endl;
         Rotation retObject(retVal,false);
         return retObject;
        }
        jdouble Rotation::getQ0() {

        if(jthis == NULL) {
            std::cerr << "Call of method getQ0 of org.apache.commons.math3.geometry.euclidean.threed.Rotation with jthis == NULL." << std::endl;
            return (jdouble) -1.0;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Rotation::getQ0 jthis=",jthis);
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "getQ0", "()D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Rotation has no method named getQ0 with signature ()D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jdouble Rotation::getQ1() {

        if(jthis == NULL) {
            std::cerr << "Call of method getQ1 of org.apache.commons.math3.geometry.euclidean.threed.Rotation with jthis == NULL." << std::endl;
            return (jdouble) -1.0;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Rotation::getQ1 jthis=",jthis);
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "getQ1", "()D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Rotation has no method named getQ1 with signature ()D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jdouble Rotation::getQ2() {

        if(jthis == NULL) {
            std::cerr << "Call of method getQ2 of org.apache.commons.math3.geometry.euclidean.threed.Rotation with jthis == NULL." << std::endl;
            return (jdouble) -1.0;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Rotation::getQ2 jthis=",jthis);
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "getQ2", "()D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Rotation has no method named getQ2 with signature ()D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        jdouble Rotation::getQ3() {

        if(jthis == NULL) {
            std::cerr << "Call of method getQ3 of org.apache.commons.math3.geometry.euclidean.threed.Rotation with jthis == NULL." << std::endl;
            return (jdouble) -1.0;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Rotation::getQ3 jthis=",jthis);
        jdouble retVal= (jdouble) -1.0;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "getQ3", "()D");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Rotation has no method named getQ3 with signature ()D." << std::endl;
                return (jdouble) -1.0;
            } else {
                retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
            }
        }
        releaseEnv(env);
        return retVal;
        }
        void Rotation::applyTo(jdoubleArray doubleArray_0,jdoubleArray doubleArray_1) {

        if(jthis == NULL) {
            std::cerr << "Call of method applyTo of org.apache.commons.math3.geometry.euclidean.threed.Rotation with jthis == NULL." << std::endl;
            
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Rotation::applyTo jthis=",jthis);
        
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "applyTo", "([D[D)V");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Rotation has no method named applyTo with signature ([D[D)V." << std::endl;
                
            } else {
                 env->CallVoidMethod(jthis, mid ,doubleArray_0,doubleArray_1 );
            }
        }
        releaseEnv(env);
        
        }
        Rotation Rotation::applyTo(Rotation  &rotation_0) {

        if(jthis == NULL) {
            std::cerr << "Call of method applyTo of org.apache.commons.math3.geometry.euclidean.threed.Rotation with jthis == NULL." << std::endl;
            Rotation nullObject((jobject)NULL,false); return nullObject;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Rotation::applyTo jthis=",jthis);
        jobject retVal=NULL;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "applyTo", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Rotation;)Lorg/apache/commons/math3/geometry/euclidean/threed/Rotation;");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Rotation has no method named applyTo with signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Rotation;)Lorg/apache/commons/math3/geometry/euclidean/threed/Rotation;." << std::endl;
                Rotation nullObject((jobject)NULL,false); return nullObject;
            } else {
                retVal= (jobject)  env->CallObjectMethod(jthis, mid ,rotation_0.jthis );
            }
        }
        releaseEnv(env);
                 
         jobjectRefType ref = env->GetObjectRefType(retVal);
         std::cout << "ref=" << ref << std::endl;
         std::cout << "retVal=" << retVal << std::endl;
         Rotation retObject(retVal,false);
         return retObject;
        }
        Vector3D Rotation::applyTo(Vector3D  &vector3D_0) {

        if(jthis == NULL) {
            std::cerr << "Call of method applyTo of org.apache.commons.math3.geometry.euclidean.threed.Rotation with jthis == NULL." << std::endl;
            Vector3D nullObject((jobject)NULL,false); return nullObject;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Rotation::applyTo jthis=",jthis);
        jobject retVal=NULL;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "applyTo", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Rotation has no method named applyTo with signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;." << std::endl;
                Vector3D nullObject((jobject)NULL,false); return nullObject;
            } else {
                retVal= (jobject)  env->CallObjectMethod(jthis, mid ,vector3D_0.jthis );
            }
        }
        releaseEnv(env);
                 
         jobjectRefType ref = env->GetObjectRefType(retVal);
         std::cout << "ref=" << ref << std::endl;
         std::cout << "retVal=" << retVal << std::endl;
         Vector3D retObject(retVal,false);
         return retObject;
        }
        void Rotation::applyInverseTo(jdoubleArray doubleArray_0,jdoubleArray doubleArray_1) {

        if(jthis == NULL) {
            std::cerr << "Call of method applyInverseTo of org.apache.commons.math3.geometry.euclidean.threed.Rotation with jthis == NULL." << std::endl;
            
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Rotation::applyInverseTo jthis=",jthis);
        
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "applyInverseTo", "([D[D)V");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Rotation has no method named applyInverseTo with signature ([D[D)V." << std::endl;
                
            } else {
                 env->CallVoidMethod(jthis, mid ,doubleArray_0,doubleArray_1 );
            }
        }
        releaseEnv(env);
        
        }
        Vector3D Rotation::applyInverseTo(Vector3D  &vector3D_0) {

        if(jthis == NULL) {
            std::cerr << "Call of method applyInverseTo of org.apache.commons.math3.geometry.euclidean.threed.Rotation with jthis == NULL." << std::endl;
            Vector3D nullObject((jobject)NULL,false); return nullObject;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Rotation::applyInverseTo jthis=",jthis);
        jobject retVal=NULL;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "applyInverseTo", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Rotation has no method named applyInverseTo with signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;." << std::endl;
                Vector3D nullObject((jobject)NULL,false); return nullObject;
            } else {
                retVal= (jobject)  env->CallObjectMethod(jthis, mid ,vector3D_0.jthis );
            }
        }
        releaseEnv(env);
                 
         jobjectRefType ref = env->GetObjectRefType(retVal);
         std::cout << "ref=" << ref << std::endl;
         std::cout << "retVal=" << retVal << std::endl;
         Vector3D retObject(retVal,false);
         return retObject;
        }
        Rotation Rotation::applyInverseTo(Rotation  &rotation_0) {

        if(jthis == NULL) {
            std::cerr << "Call of method applyInverseTo of org.apache.commons.math3.geometry.euclidean.threed.Rotation with jthis == NULL." << std::endl;
            Rotation nullObject((jobject)NULL,false); return nullObject;
        }
        JNIEnv *env =getEnv();
        jclass cls = env->GetObjectClass(jthis);
        if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Rotation::applyInverseTo jthis=",jthis);
        jobject retVal=NULL;
        if (cls != NULL) {
            static jmethodID mid = env->GetMethodID(cls, "applyInverseTo", "(Lorg/apache/commons/math3/geometry/euclidean/threed/Rotation;)Lorg/apache/commons/math3/geometry/euclidean/threed/Rotation;");
            if (NULL == mid) {
                std::cerr << "Class org.apache.commons.math3.geometry.euclidean.threed.Rotation has no method named applyInverseTo with signature (Lorg/apache/commons/math3/geometry/euclidean/threed/Rotation;)Lorg/apache/commons/math3/geometry/euclidean/threed/Rotation;." << std::endl;
                Rotation nullObject((jobject)NULL,false); return nullObject;
            } else {
                retVal= (jobject)  env->CallObjectMethod(jthis, mid ,rotation_0.jthis );
            }
        }
        releaseEnv(env);
                 
         jobjectRefType ref = env->GetObjectRefType(retVal);
         std::cout << "ref=" << ref << std::endl;
         std::cout << "retVal=" << retVal << std::endl;
         Rotation retObject(retVal,false);
         return retObject;
        }
        static jclass getNewRotationClass() {
            jclass clss = getEnv()->FindClass("org/apache/commons/math3/geometry/euclidean/threed/Rotation");
            if (NULL == clss) {
                std::cerr << " Can't find class org/apache/commons/math3/geometry/euclidean/threed/Rotation" << std::endl;
            }
            return clss;
        }
        
        static jclass RotationClass = NULL;
        static inline jclass getRotationClass() {
            if (RotationClass != NULL) {
                return RotationClass;
            }
            RotationClass = getNewRotationClass();
        }
       } // end namespace threed
      } // end namespace euclidean
     } // end namespace geometry
    } // end namespace math3
   } // end namespace commons
  } // end namespace apache
 } // end namespace org

  namespace java{
   namespace awt{
    namespace geom{
    
    // get JNI handle for class java.awt.geom.Point2D
    static inline jclass getPoint2DClass();
    
    Point2D::Point2D(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
            // Place holder for future extensibility
    }
    
    Point2D::Point2D(const Point2D &objref) {
        jobject _jthis = objref.jthis;
        if (_jthis != NULL) {
            jthis = getEnv()->NewGlobalRef(_jthis);
        }
    }

    // Destructor for java.awt.geom.Point2D
    Point2D::~Point2D() {
    	// Place-holder for later extensibility.
    }

    void Point2D::setLocation(Point2D  &point2D_0) {

    if(jthis == NULL) {
        std::cerr << "Call of method setLocation of java.awt.geom.Point2D with jthis == NULL." << std::endl;
        
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Point2D::setLocation jthis=",jthis);
    
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "setLocation", "(Ljava/awt/geom/Point2D;)V");
        if (NULL == mid) {
            std::cerr << "Class java.awt.geom.Point2D has no method named setLocation with signature (Ljava/awt/geom/Point2D;)V." << std::endl;
            
        } else {
             env->CallVoidMethod(jthis, mid ,point2D_0.jthis );
        }
    }
    releaseEnv(env);
    
    }
    jdouble Point2D::distanceSq(jdouble double_0,jdouble double_1,jdouble double_2,jdouble double_3) {

    JNIEnv *env =getEnv();
    static jclass cls = getPoint2DClass();
    jdouble retVal= (jdouble) -1.0;
    if (cls != NULL) {
        static jmethodID mid = env->GetStaticMethodID(cls, "distanceSq", "(DDDD)D");
        if (NULL == mid) {
            std::cerr << "Class java.awt.geom.Point2D has no method named distanceSq with signature (DDDD)D." << std::endl;
            return (jdouble) -1.0;
        } else {
            retVal= (jdouble)  env->CallStaticDoubleMethod( cls, mid ,double_0,double_1,double_2,double_3 );
        }
    }
    releaseEnv(env);
    return retVal;
    }
    jdouble Point2D::distanceSq(Point2D  &point2D_0) {

    if(jthis == NULL) {
        std::cerr << "Call of method distanceSq of java.awt.geom.Point2D with jthis == NULL." << std::endl;
        return (jdouble) -1.0;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Point2D::distanceSq jthis=",jthis);
    jdouble retVal= (jdouble) -1.0;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "distanceSq", "(Ljava/awt/geom/Point2D;)D");
        if (NULL == mid) {
            std::cerr << "Class java.awt.geom.Point2D has no method named distanceSq with signature (Ljava/awt/geom/Point2D;)D." << std::endl;
            return (jdouble) -1.0;
        } else {
            retVal= (jdouble)  env->CallDoubleMethod(jthis, mid ,point2D_0.jthis );
        }
    }
    releaseEnv(env);
    return retVal;
    }
    jdouble Point2D::distanceSq(jdouble double_0,jdouble double_1) {

    if(jthis == NULL) {
        std::cerr << "Call of method distanceSq of java.awt.geom.Point2D with jthis == NULL." << std::endl;
        return (jdouble) -1.0;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Point2D::distanceSq jthis=",jthis);
    jdouble retVal= (jdouble) -1.0;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "distanceSq", "(DD)D");
        if (NULL == mid) {
            std::cerr << "Class java.awt.geom.Point2D has no method named distanceSq with signature (DD)D." << std::endl;
            return (jdouble) -1.0;
        } else {
            retVal= (jdouble)  env->CallDoubleMethod(jthis, mid ,double_0,double_1 );
        }
    }
    releaseEnv(env);
    return retVal;
    }
    jdouble Point2D::distance(jdouble double_0,jdouble double_1) {

    if(jthis == NULL) {
        std::cerr << "Call of method distance of java.awt.geom.Point2D with jthis == NULL." << std::endl;
        return (jdouble) -1.0;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Point2D::distance jthis=",jthis);
    jdouble retVal= (jdouble) -1.0;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "distance", "(DD)D");
        if (NULL == mid) {
            std::cerr << "Class java.awt.geom.Point2D has no method named distance with signature (DD)D." << std::endl;
            return (jdouble) -1.0;
        } else {
            retVal= (jdouble)  env->CallDoubleMethod(jthis, mid ,double_0,double_1 );
        }
    }
    releaseEnv(env);
    return retVal;
    }
    jdouble Point2D::distance(jdouble double_0,jdouble double_1,jdouble double_2,jdouble double_3) {

    JNIEnv *env =getEnv();
    static jclass cls = getPoint2DClass();
    jdouble retVal= (jdouble) -1.0;
    if (cls != NULL) {
        static jmethodID mid = env->GetStaticMethodID(cls, "distance", "(DDDD)D");
        if (NULL == mid) {
            std::cerr << "Class java.awt.geom.Point2D has no method named distance with signature (DDDD)D." << std::endl;
            return (jdouble) -1.0;
        } else {
            retVal= (jdouble)  env->CallStaticDoubleMethod( cls, mid ,double_0,double_1,double_2,double_3 );
        }
    }
    releaseEnv(env);
    return retVal;
    }
    jdouble Point2D::distance(Point2D  &point2D_0) {

    if(jthis == NULL) {
        std::cerr << "Call of method distance of java.awt.geom.Point2D with jthis == NULL." << std::endl;
        return (jdouble) -1.0;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Point2D::distance jthis=",jthis);
    jdouble retVal= (jdouble) -1.0;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "distance", "(Ljava/awt/geom/Point2D;)D");
        if (NULL == mid) {
            std::cerr << "Class java.awt.geom.Point2D has no method named distance with signature (Ljava/awt/geom/Point2D;)D." << std::endl;
            return (jdouble) -1.0;
        } else {
            retVal= (jdouble)  env->CallDoubleMethod(jthis, mid ,point2D_0.jthis );
        }
    }
    releaseEnv(env);
    return retVal;
    }
    jboolean Point2D::equals(::crclj::java::lang::Object  &object_0) {

    if(jthis == NULL) {
        std::cerr << "Call of method equals of java.awt.geom.Point2D with jthis == NULL." << std::endl;
        return false;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Point2D::equals jthis=",jthis);
    jboolean retVal=false;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
        if (NULL == mid) {
            std::cerr << "Class java.awt.geom.Point2D has no method named equals with signature (Ljava/lang/Object;)Z." << std::endl;
            return false;
        } else {
            retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,object_0.jthis );
        }
    }
    releaseEnv(env);
    return retVal;
    }
    jint Point2D::hashCode() {

    if(jthis == NULL) {
        std::cerr << "Call of method hashCode of java.awt.geom.Point2D with jthis == NULL." << std::endl;
        return (jint) -1;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Point2D::hashCode jthis=",jthis);
    jint retVal= (jint) -1;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "hashCode", "()I");
        if (NULL == mid) {
            std::cerr << "Class java.awt.geom.Point2D has no method named hashCode with signature ()I." << std::endl;
            return (jint) -1;
        } else {
            retVal= (jint)  env->CallIntMethod(jthis, mid  );
        }
    }
    releaseEnv(env);
    return retVal;
    }
    ::crclj::java::lang::Object Point2D::clone() {

    if(jthis == NULL) {
        std::cerr << "Call of method clone of java.awt.geom.Point2D with jthis == NULL." << std::endl;
        ::crclj::java::lang::Object nullObject((jobject)NULL,false); return nullObject;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Point2D::clone jthis=",jthis);
    jobject retVal=NULL;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "clone", "()Ljava/lang/Object;");
        if (NULL == mid) {
            std::cerr << "Class java.awt.geom.Point2D has no method named clone with signature ()Ljava/lang/Object;." << std::endl;
            ::crclj::java::lang::Object nullObject((jobject)NULL,false); return nullObject;
        } else {
            retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
        }
    }
    releaseEnv(env);
         
     jobjectRefType ref = env->GetObjectRefType(retVal);
     std::cout << "ref=" << ref << std::endl;
     std::cout << "retVal=" << retVal << std::endl;
     ::crclj::java::lang::Object retObject(retVal,false);
     return retObject;
    }
    static jclass getNewPoint2DClass() {
        jclass clss = getEnv()->FindClass("java/awt/geom/Point2D");
        if (NULL == clss) {
            std::cerr << " Can't find class java/awt/geom/Point2D" << std::endl;
        }
        return clss;
    }
    
    static jclass Point2DClass = NULL;
    static inline jclass getPoint2DClass() {
        if (Point2DClass != NULL) {
            return Point2DClass;
        }
        Point2DClass = getNewPoint2DClass();
    }
    
    // get JNI handle for class java.awt.geom.Point2D.Double
    static inline jclass getPoint2DDoubleClass();
    
    Point2DDouble::Point2DDouble(jobject _jthis, bool copy): Point2D(_jthis,copy) {
            // Place holder for future extensibility
    }
    
    Point2DDouble::Point2DDouble(const Point2DDouble &objref) {
        jobject _jthis = objref.jthis;
        if (_jthis != NULL) {
            jthis = getEnv()->NewGlobalRef(_jthis);
        }
    }
    Point2DDouble::Point2DDouble() {
     JNIEnv *env =getEnv();
     static jclass cls = getPoint2DDoubleClass();
     if (cls != NULL) {
         static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
         if (NULL == mid) {
             std::cerr << "Class Point2DDouble has no method constructor signature ()V" << std::endl;
         } else {
             jthis = env->NewObject(cls, mid );
             jobjectRefType ref = env->GetObjectRefType(jthis);
             if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Point2DDouble jthis=",jthis);
             if(ref != JNIGlobalRefType) {
                 jthis = env->NewGlobalRef(jthis);
             }
         }
     }
     releaseEnv(env);
    }

    Point2DDouble::Point2DDouble(jdouble double_0,jdouble double_1) {
     JNIEnv *env =getEnv();
     static jclass cls = getPoint2DDoubleClass();
     if (cls != NULL) {
         static jmethodID mid = env->GetMethodID(cls, "<init>", "(DD)V");
         if (NULL == mid) {
             std::cerr << "Class Point2DDouble has no method constructor signature (DD)V" << std::endl;
         } else {
             jthis = env->NewObject(cls, mid ,double_0,double_1);
             jobjectRefType ref = env->GetObjectRefType(jthis);
             if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Point2DDouble jthis=",jthis);
             if(ref != JNIGlobalRefType) {
                 jthis = env->NewGlobalRef(jthis);
             }
         }
     }
     releaseEnv(env);
    }


    // Destructor for java.awt.geom.Point2D.Double
    Point2DDouble::~Point2DDouble() {
    	// Place-holder for later extensibility.
    }

    void Point2DDouble::setLocation(jdouble double_0,jdouble double_1) {

    if(jthis == NULL) {
        std::cerr << "Call of method setLocation of java.awt.geom.Point2D.Double with jthis == NULL." << std::endl;
        
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Point2DDouble::setLocation jthis=",jthis);
    
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "setLocation", "(DD)V");
        if (NULL == mid) {
            std::cerr << "Class java.awt.geom.Point2D.Double has no method named setLocation with signature (DD)V." << std::endl;
            
        } else {
             env->CallVoidMethod(jthis, mid ,double_0,double_1 );
        }
    }
    releaseEnv(env);
    
    }
    jdouble Point2DDouble::getX() {

    if(jthis == NULL) {
        std::cerr << "Call of method getX of java.awt.geom.Point2D.Double with jthis == NULL." << std::endl;
        return (jdouble) -1.0;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Point2DDouble::getX jthis=",jthis);
    jdouble retVal= (jdouble) -1.0;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "getX", "()D");
        if (NULL == mid) {
            std::cerr << "Class java.awt.geom.Point2D.Double has no method named getX with signature ()D." << std::endl;
            return (jdouble) -1.0;
        } else {
            retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
        }
    }
    releaseEnv(env);
    return retVal;
    }
    jdouble Point2DDouble::getY() {

    if(jthis == NULL) {
        std::cerr << "Call of method getY of java.awt.geom.Point2D.Double with jthis == NULL." << std::endl;
        return (jdouble) -1.0;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Point2DDouble::getY jthis=",jthis);
    jdouble retVal= (jdouble) -1.0;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "getY", "()D");
        if (NULL == mid) {
            std::cerr << "Class java.awt.geom.Point2D.Double has no method named getY with signature ()D." << std::endl;
            return (jdouble) -1.0;
        } else {
            retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
        }
    }
    releaseEnv(env);
    return retVal;
    }
    jstring Point2DDouble::toString() {

    if(jthis == NULL) {
        std::cerr << "Call of method toString of java.awt.geom.Point2D.Double with jthis == NULL." << std::endl;
        return NULL;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Point2DDouble::toString jthis=",jthis);
    jstring retVal=NULL;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "toString", "()Ljava/lang/String;");
        if (NULL == mid) {
            std::cerr << "Class java.awt.geom.Point2D.Double has no method named toString with signature ()Ljava/lang/String;." << std::endl;
            return NULL;
        } else {
            retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
        }
    }
    releaseEnv(env);
    return retVal;
    }
    static jclass getNewPoint2DDoubleClass() {
        jclass clss = getEnv()->FindClass("java/awt/geom/Point2D/Double");
        if (NULL == clss) {
            std::cerr << " Can't find class java/awt/geom/Point2D/Double" << std::endl;
        }
        return clss;
    }
    
    static jclass Point2DDoubleClass = NULL;
    static inline jclass getPoint2DDoubleClass() {
        if (Point2DDoubleClass != NULL) {
            return Point2DDoubleClass;
        }
        Point2DDoubleClass = getNewPoint2DDoubleClass();
    }
   } // end namespace geom
  } // end namespace awt
 } // end namespace java

  namespace rcs{
   namespace posemath{
   
   // get JNI handle for class rcs.posemath.PmCartesian
   static inline jclass getPmCartesianClass();
   
   PmCartesian::PmCartesian(jobject _jthis, bool copy): ::crclj::java::awt::geom::Point2DDouble(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   PmCartesian::PmCartesian(const PmCartesian &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   PmCartesian::PmCartesian(jdouble double_0,jdouble double_1,jdouble double_2) {
    JNIEnv *env =getEnv();
    static jclass cls = getPmCartesianClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(DDD)V");
        if (NULL == mid) {
            std::cerr << "Class PmCartesian has no method constructor signature (DDD)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,double_0,double_1,double_2);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PmCartesian jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PmCartesian::PmCartesian() {
    JNIEnv *env =getEnv();
    static jclass cls = getPmCartesianClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class PmCartesian has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PmCartesian jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for rcs.posemath.PmCartesian
   PmCartesian::~PmCartesian() {
   	// Place-holder for later extensibility.
   }

   jdouble PmCartesian::getX() {

   if(jthis == NULL) {
       std::cerr << "Call of method getX of rcs.posemath.PmCartesian with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmCartesian::getX jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getX", "()D");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmCartesian has no method named getX with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jdouble PmCartesian::getY() {

   if(jthis == NULL) {
       std::cerr << "Call of method getY of rcs.posemath.PmCartesian with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmCartesian::getY jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getY", "()D");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmCartesian has no method named getY with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jdouble PmCartesian::mag() {

   if(jthis == NULL) {
       std::cerr << "Call of method mag of rcs.posemath.PmCartesian with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmCartesian::mag jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "mag", "()D");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmCartesian has no method named mag with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jdouble PmCartesian::distFrom(PmCartesian  &pmCartesian_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method distFrom of rcs.posemath.PmCartesian with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmCartesian::distFrom jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "distFrom", "(Lrcs/posemath/PmCartesian;)D");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmCartesian has no method named distFrom with signature (Lrcs/posemath/PmCartesian;)D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid ,pmCartesian_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   PmCartesian PmCartesian::subtract(PmCartesian  &pmCartesian_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method subtract of rcs.posemath.PmCartesian with jthis == NULL." << std::endl;
       PmCartesian nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmCartesian::subtract jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "subtract", "(Lrcs/posemath/PmCartesian;)Lrcs/posemath/PmCartesian;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmCartesian has no method named subtract with signature (Lrcs/posemath/PmCartesian;)Lrcs/posemath/PmCartesian;." << std::endl;
           PmCartesian nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,pmCartesian_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PmCartesian retObject(retVal,false);
    return retObject;
   }
   void PmCartesian::setX(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setX of rcs.posemath.PmCartesian with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmCartesian::setX jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setX", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmCartesian has no method named setX with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PmCartesian::setY(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setY of rcs.posemath.PmCartesian with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmCartesian::setY jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setY", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmCartesian has no method named setY with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   jdouble PmCartesian::getZ() {

   if(jthis == NULL) {
       std::cerr << "Call of method getZ of rcs.posemath.PmCartesian with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmCartesian::getZ jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getZ", "()D");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmCartesian has no method named getZ with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PmCartesian::setZ(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setZ of rcs.posemath.PmCartesian with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmCartesian::setZ jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setZ", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmCartesian has no method named setZ with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   PmCartesian PmCartesian::multiply(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method multiply of rcs.posemath.PmCartesian with jthis == NULL." << std::endl;
       PmCartesian nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmCartesian::multiply jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "multiply", "(D)Lrcs/posemath/PmCartesian;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmCartesian has no method named multiply with signature (D)Lrcs/posemath/PmCartesian;." << std::endl;
           PmCartesian nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PmCartesian retObject(retVal,false);
    return retObject;
   }
   PmCartesian PmCartesian::add(PmCartesian  &pmCartesian_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method add of rcs.posemath.PmCartesian with jthis == NULL." << std::endl;
       PmCartesian nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmCartesian::add jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "add", "(Lrcs/posemath/PmCartesian;)Lrcs/posemath/PmCartesian;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmCartesian has no method named add with signature (Lrcs/posemath/PmCartesian;)Lrcs/posemath/PmCartesian;." << std::endl;
           PmCartesian nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,pmCartesian_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PmCartesian retObject(retVal,false);
    return retObject;
   }
   jboolean PmCartesian::equals(PmCartesian  &pmCartesian_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method equals of rcs.posemath.PmCartesian with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmCartesian::equals jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "equals", "(Lrcs/posemath/PmCartesian;)Z");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmCartesian has no method named equals with signature (Lrcs/posemath/PmCartesian;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,pmCartesian_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring PmCartesian::toString() {

   if(jthis == NULL) {
       std::cerr << "Call of method toString of rcs.posemath.PmCartesian with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmCartesian::toString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toString", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmCartesian has no method named toString with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   PmCartesian PmCartesian::clone() {

   if(jthis == NULL) {
       std::cerr << "Call of method clone of rcs.posemath.PmCartesian with jthis == NULL." << std::endl;
       PmCartesian nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmCartesian::clone jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "clone", "()Lrcs/posemath/PmCartesian;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmCartesian has no method named clone with signature ()Lrcs/posemath/PmCartesian;." << std::endl;
           PmCartesian nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PmCartesian retObject(retVal,false);
    return retObject;
   }
   PmCartesian PmCartesian::valueOf(jstring string_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getPmCartesianClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "valueOf", "(Ljava/lang/String;)Lrcs/posemath/PmCartesian;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmCartesian has no method named valueOf with signature (Ljava/lang/String;)Lrcs/posemath/PmCartesian;." << std::endl;
           PmCartesian nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,string_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PmCartesian retObject(retVal,false);
    return retObject;
   }
   static jclass getNewPmCartesianClass() {
       jclass clss = getEnv()->FindClass("rcs/posemath/PmCartesian");
       if (NULL == clss) {
           std::cerr << " Can't find class rcs/posemath/PmCartesian" << std::endl;
       }
       return clss;
   }
   
   static jclass PmCartesianClass = NULL;
   static inline jclass getPmCartesianClass() {
       if (PmCartesianClass != NULL) {
           return PmCartesianClass;
       }
       PmCartesianClass = getNewPmCartesianClass();
   }
   
   // get JNI handle for class rcs.posemath.PmRotationVector
   static inline jclass getPmRotationVectorClass();
   
   PmRotationVector::PmRotationVector(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   PmRotationVector::PmRotationVector(const PmRotationVector &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   PmRotationVector::PmRotationVector(jdouble double_0,jdouble double_1,jdouble double_2,jdouble double_3) {
    JNIEnv *env =getEnv();
    static jclass cls = getPmRotationVectorClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(DDDD)V");
        if (NULL == mid) {
            std::cerr << "Class PmRotationVector has no method constructor signature (DDDD)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,double_0,double_1,double_2,double_3);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PmRotationVector jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PmRotationVector::PmRotationVector() {
    JNIEnv *env =getEnv();
    static jclass cls = getPmRotationVectorClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class PmRotationVector has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PmRotationVector jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for rcs.posemath.PmRotationVector
   PmRotationVector::~PmRotationVector() {
   	// Place-holder for later extensibility.
   }

   PmRotationVector PmRotationVector::inv() {

   if(jthis == NULL) {
       std::cerr << "Call of method inv of rcs.posemath.PmRotationVector with jthis == NULL." << std::endl;
       PmRotationVector nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmRotationVector::inv jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "inv", "()Lrcs/posemath/PmRotationVector;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmRotationVector has no method named inv with signature ()Lrcs/posemath/PmRotationVector;." << std::endl;
           PmRotationVector nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PmRotationVector retObject(retVal,false);
    return retObject;
   }
   PmRotationVector PmRotationVector::multiply(PmRotationVector  &pmRotationVector_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method multiply of rcs.posemath.PmRotationVector with jthis == NULL." << std::endl;
       PmRotationVector nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmRotationVector::multiply jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "multiply", "(Lrcs/posemath/PmRotationVector;)Lrcs/posemath/PmRotationVector;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmRotationVector has no method named multiply with signature (Lrcs/posemath/PmRotationVector;)Lrcs/posemath/PmRotationVector;." << std::endl;
           PmRotationVector nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,pmRotationVector_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PmRotationVector retObject(retVal,false);
    return retObject;
   }
   PmRotationVector PmRotationVector::multiply(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method multiply of rcs.posemath.PmRotationVector with jthis == NULL." << std::endl;
       PmRotationVector nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmRotationVector::multiply jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "multiply", "(D)Lrcs/posemath/PmRotationVector;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmRotationVector has no method named multiply with signature (D)Lrcs/posemath/PmRotationVector;." << std::endl;
           PmRotationVector nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PmRotationVector retObject(retVal,false);
    return retObject;
   }
   PmRotationVector PmRotationVector::clone() {

   if(jthis == NULL) {
       std::cerr << "Call of method clone of rcs.posemath.PmRotationVector with jthis == NULL." << std::endl;
       PmRotationVector nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmRotationVector::clone jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "clone", "()Lrcs/posemath/PmRotationVector;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmRotationVector has no method named clone with signature ()Lrcs/posemath/PmRotationVector;." << std::endl;
           PmRotationVector nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PmRotationVector retObject(retVal,false);
    return retObject;
   }
   static jclass getNewPmRotationVectorClass() {
       jclass clss = getEnv()->FindClass("rcs/posemath/PmRotationVector");
       if (NULL == clss) {
           std::cerr << " Can't find class rcs/posemath/PmRotationVector" << std::endl;
       }
       return clss;
   }
   
   static jclass PmRotationVectorClass = NULL;
   static inline jclass getPmRotationVectorClass() {
       if (PmRotationVectorClass != NULL) {
           return PmRotationVectorClass;
       }
       PmRotationVectorClass = getNewPmRotationVectorClass();
   }
   
   // get JNI handle for class rcs.posemath.PmRotationMatrix
   static inline jclass getPmRotationMatrixClass();
   
   PmRotationMatrix::PmRotationMatrix(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   PmRotationMatrix::PmRotationMatrix(const PmRotationMatrix &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   PmRotationMatrix::PmRotationMatrix() {
    JNIEnv *env =getEnv();
    static jclass cls = getPmRotationMatrixClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class PmRotationMatrix has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PmRotationMatrix jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PmRotationMatrix::PmRotationMatrix(PmCartesian  &pmCartesian_0,PmCartesian  &pmCartesian_1,PmCartesian  &pmCartesian_2) {
    JNIEnv *env =getEnv();
    static jclass cls = getPmRotationMatrixClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Lrcs/posemath/PmCartesian;Lrcs/posemath/PmCartesian;Lrcs/posemath/PmCartesian;)V");
        if (NULL == mid) {
            std::cerr << "Class PmRotationMatrix has no method constructor signature (Lrcs/posemath/PmCartesian;Lrcs/posemath/PmCartesian;Lrcs/posemath/PmCartesian;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,pmCartesian_0.jthis,pmCartesian_1.jthis,pmCartesian_2.jthis);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PmRotationMatrix jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PmRotationMatrix::PmRotationMatrix(jdouble double_0,jdouble double_1,jdouble double_2,jdouble double_3,jdouble double_4,jdouble double_5,jdouble double_6,jdouble double_7,jdouble double_8) {
    JNIEnv *env =getEnv();
    static jclass cls = getPmRotationMatrixClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(DDDDDDDDD)V");
        if (NULL == mid) {
            std::cerr << "Class PmRotationMatrix has no method constructor signature (DDDDDDDDD)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,double_0,double_1,double_2,double_3,double_4,double_5,double_6,double_7,double_8);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PmRotationMatrix jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for rcs.posemath.PmRotationMatrix
   PmRotationMatrix::~PmRotationMatrix() {
   	// Place-holder for later extensibility.
   }

   PmRotationMatrix PmRotationMatrix::inv() {

   if(jthis == NULL) {
       std::cerr << "Call of method inv of rcs.posemath.PmRotationMatrix with jthis == NULL." << std::endl;
       PmRotationMatrix nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmRotationMatrix::inv jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "inv", "()Lrcs/posemath/PmRotationMatrix;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmRotationMatrix has no method named inv with signature ()Lrcs/posemath/PmRotationMatrix;." << std::endl;
           PmRotationMatrix nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PmRotationMatrix retObject(retVal,false);
    return retObject;
   }
   PmRotationMatrix PmRotationMatrix::multiply(PmRotationMatrix  &pmRotationMatrix_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method multiply of rcs.posemath.PmRotationMatrix with jthis == NULL." << std::endl;
       PmRotationMatrix nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmRotationMatrix::multiply jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "multiply", "(Lrcs/posemath/PmRotationMatrix;)Lrcs/posemath/PmRotationMatrix;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmRotationMatrix has no method named multiply with signature (Lrcs/posemath/PmRotationMatrix;)Lrcs/posemath/PmRotationMatrix;." << std::endl;
           PmRotationMatrix nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,pmRotationMatrix_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PmRotationMatrix retObject(retVal,false);
    return retObject;
   }
   PmCartesian PmRotationMatrix::multiply(PmCartesian  &pmCartesian_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method multiply of rcs.posemath.PmRotationMatrix with jthis == NULL." << std::endl;
       PmCartesian nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmRotationMatrix::multiply jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "multiply", "(Lrcs/posemath/PmCartesian;)Lrcs/posemath/PmCartesian;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmRotationMatrix has no method named multiply with signature (Lrcs/posemath/PmCartesian;)Lrcs/posemath/PmCartesian;." << std::endl;
           PmCartesian nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,pmCartesian_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PmCartesian retObject(retVal,false);
    return retObject;
   }
   jstring PmRotationMatrix::toString() {

   if(jthis == NULL) {
       std::cerr << "Call of method toString of rcs.posemath.PmRotationMatrix with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmRotationMatrix::toString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toString", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmRotationMatrix has no method named toString with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewPmRotationMatrixClass() {
       jclass clss = getEnv()->FindClass("rcs/posemath/PmRotationMatrix");
       if (NULL == clss) {
           std::cerr << " Can't find class rcs/posemath/PmRotationMatrix" << std::endl;
       }
       return clss;
   }
   
   static jclass PmRotationMatrixClass = NULL;
   static inline jclass getPmRotationMatrixClass() {
       if (PmRotationMatrixClass != NULL) {
           return PmRotationMatrixClass;
       }
       PmRotationMatrixClass = getNewPmRotationMatrixClass();
   }
   
   // get JNI handle for class rcs.posemath.PmRpy
   static inline jclass getPmRpyClass();
   
   PmRpy::PmRpy(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   PmRpy::PmRpy(const PmRpy &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   PmRpy::PmRpy(jdouble double_0,jdouble double_1,jdouble double_2) {
    JNIEnv *env =getEnv();
    static jclass cls = getPmRpyClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(DDD)V");
        if (NULL == mid) {
            std::cerr << "Class PmRpy has no method constructor signature (DDD)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,double_0,double_1,double_2);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PmRpy jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PmRpy::PmRpy() {
    JNIEnv *env =getEnv();
    static jclass cls = getPmRpyClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class PmRpy has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PmRpy jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PmRpy::PmRpy(PmQuaternion  &pmQuaternion_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getPmRpyClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Lrcs/posemath/PmQuaternion;)V");
        if (NULL == mid) {
            std::cerr << "Class PmRpy has no method constructor signature (Lrcs/posemath/PmQuaternion;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,pmQuaternion_0.jthis);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PmRpy jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for rcs.posemath.PmRpy
   PmRpy::~PmRpy() {
   	// Place-holder for later extensibility.
   }

   jdouble PmRpy::getY() {

   if(jthis == NULL) {
       std::cerr << "Call of method getY of rcs.posemath.PmRpy with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmRpy::getY jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getY", "()D");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmRpy has no method named getY with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PmRpy::setY(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setY of rcs.posemath.PmRpy with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmRpy::setY jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setY", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmRpy has no method named setY with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   jdouble PmRpy::getR() {

   if(jthis == NULL) {
       std::cerr << "Call of method getR of rcs.posemath.PmRpy with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmRpy::getR jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getR", "()D");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmRpy has no method named getR with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PmRpy::norm() {

   if(jthis == NULL) {
       std::cerr << "Call of method norm of rcs.posemath.PmRpy with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmRpy::norm jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "norm", "()V");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmRpy has no method named norm with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jdouble PmRpy::getP() {

   if(jthis == NULL) {
       std::cerr << "Call of method getP of rcs.posemath.PmRpy with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmRpy::getP jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getP", "()D");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmRpy has no method named getP with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PmRpy::setR(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setR of rcs.posemath.PmRpy with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmRpy::setR jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setR", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmRpy has no method named setR with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PmRpy::setP(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setP of rcs.posemath.PmRpy with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmRpy::setP jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setP", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmRpy has no method named setP with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   jstring PmRpy::toString() {

   if(jthis == NULL) {
       std::cerr << "Call of method toString of rcs.posemath.PmRpy with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmRpy::toString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toString", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmRpy has no method named toString with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   PmRpy PmRpy::clone() {

   if(jthis == NULL) {
       std::cerr << "Call of method clone of rcs.posemath.PmRpy with jthis == NULL." << std::endl;
       PmRpy nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmRpy::clone jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "clone", "()Lrcs/posemath/PmRpy;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmRpy has no method named clone with signature ()Lrcs/posemath/PmRpy;." << std::endl;
           PmRpy nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PmRpy retObject(retVal,false);
    return retObject;
   }
   static jclass getNewPmRpyClass() {
       jclass clss = getEnv()->FindClass("rcs/posemath/PmRpy");
       if (NULL == clss) {
           std::cerr << " Can't find class rcs/posemath/PmRpy" << std::endl;
       }
       return clss;
   }
   
   static jclass PmRpyClass = NULL;
   static inline jclass getPmRpyClass() {
       if (PmRpyClass != NULL) {
           return PmRpyClass;
       }
       PmRpyClass = getNewPmRpyClass();
   }
  } // end namespace posemath
 } // end namespace rcs

  namespace org{
   namespace w3c{
    namespace dom{
    
    // get JNI handle for class org.w3c.dom.Node
    static inline jclass getNodeClass();
    
    Node::Node(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
            // Place holder for future extensibility
    }
    
    Node::Node(const Node &objref) {
        jobject _jthis = objref.jthis;
        if (_jthis != NULL) {
            jthis = getEnv()->NewGlobalRef(_jthis);
        }
    }
    Node::Node() {
    JNIEnv *env =getEnv();
    static jclass cls = getNodeClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class Node has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Node jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
    }


    // Destructor for org.w3c.dom.Node
    Node::~Node() {
    	// Place-holder for later extensibility.
    }

    static jclass getNewNodeClass() {
        jclass clss = getEnv()->FindClass("org/w3c/dom/Node");
        if (NULL == clss) {
            std::cerr << " Can't find class org/w3c/dom/Node" << std::endl;
        }
        return clss;
    }
    
    static jclass NodeClass = NULL;
    static inline jclass getNodeClass() {
        if (NodeClass != NULL) {
            return NodeClass;
        }
        NodeClass = getNewNodeClass();
    }
    
    // get JNI handle for class org.w3c.dom.NodeList
    static inline jclass getNodeListClass();
    
    NodeList::NodeList(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
            // Place holder for future extensibility
    }
    
    NodeList::NodeList(const NodeList &objref) {
        jobject _jthis = objref.jthis;
        if (_jthis != NULL) {
            jthis = getEnv()->NewGlobalRef(_jthis);
        }
    }
    NodeList::NodeList() {
    JNIEnv *env =getEnv();
    static jclass cls = getNodeListClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class NodeList has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new NodeList jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
    }


    // Destructor for org.w3c.dom.NodeList
    NodeList::~NodeList() {
    	// Place-holder for later extensibility.
    }

    static jclass getNewNodeListClass() {
        jclass clss = getEnv()->FindClass("org/w3c/dom/NodeList");
        if (NULL == clss) {
            std::cerr << " Can't find class org/w3c/dom/NodeList" << std::endl;
        }
        return clss;
    }
    
    static jclass NodeListClass = NULL;
    static inline jclass getNodeListClass() {
        if (NodeListClass != NULL) {
            return NodeListClass;
        }
        NodeListClass = getNewNodeListClass();
    }
   } // end namespace dom
  } // end namespace w3c
 } // end namespace org

  namespace javax{
   namespace xml{
    namespace datatype{
    
    // get JNI handle for class javax.xml.datatype.XMLGregorianCalendar
    static inline jclass getXMLGregorianCalendarClass();
    
    XMLGregorianCalendar::XMLGregorianCalendar(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
            // Place holder for future extensibility
    }
    
    XMLGregorianCalendar::XMLGregorianCalendar(const XMLGregorianCalendar &objref) {
        jobject _jthis = objref.jthis;
        if (_jthis != NULL) {
            jthis = getEnv()->NewGlobalRef(_jthis);
        }
    }
    XMLGregorianCalendar::XMLGregorianCalendar() {
     JNIEnv *env =getEnv();
     static jclass cls = getXMLGregorianCalendarClass();
     if (cls != NULL) {
         static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
         if (NULL == mid) {
             std::cerr << "Class XMLGregorianCalendar has no method constructor signature ()V" << std::endl;
         } else {
             jthis = env->NewObject(cls, mid );
             jobjectRefType ref = env->GetObjectRefType(jthis);
             if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new XMLGregorianCalendar jthis=",jthis);
             if(ref != JNIGlobalRefType) {
                 jthis = env->NewGlobalRef(jthis);
             }
         }
     }
     releaseEnv(env);
    }


    // Destructor for javax.xml.datatype.XMLGregorianCalendar
    XMLGregorianCalendar::~XMLGregorianCalendar() {
    	// Place-holder for later extensibility.
    }

    void XMLGregorianCalendar::setTime(jint int_0,jint int_1,jint int_2,::crclj::java::math::BigDecimal  &bigDecimal_3) {

    if(jthis == NULL) {
        std::cerr << "Call of method setTime of javax.xml.datatype.XMLGregorianCalendar with jthis == NULL." << std::endl;
        
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XMLGregorianCalendar::setTime jthis=",jthis);
    
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "setTime", "(IIILjava/math/BigDecimal;)V");
        if (NULL == mid) {
            std::cerr << "Class javax.xml.datatype.XMLGregorianCalendar has no method named setTime with signature (IIILjava/math/BigDecimal;)V." << std::endl;
            
        } else {
             env->CallVoidMethod(jthis, mid ,int_0,int_1,int_2,bigDecimal_3.jthis );
        }
    }
    releaseEnv(env);
    
    }
    void XMLGregorianCalendar::setTime(jint int_0,jint int_1,jint int_2) {

    if(jthis == NULL) {
        std::cerr << "Call of method setTime of javax.xml.datatype.XMLGregorianCalendar with jthis == NULL." << std::endl;
        
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XMLGregorianCalendar::setTime jthis=",jthis);
    
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "setTime", "(III)V");
        if (NULL == mid) {
            std::cerr << "Class javax.xml.datatype.XMLGregorianCalendar has no method named setTime with signature (III)V." << std::endl;
            
        } else {
             env->CallVoidMethod(jthis, mid ,int_0,int_1,int_2 );
        }
    }
    releaseEnv(env);
    
    }
    void XMLGregorianCalendar::setTime(jint int_0,jint int_1,jint int_2,jint int_3) {

    if(jthis == NULL) {
        std::cerr << "Call of method setTime of javax.xml.datatype.XMLGregorianCalendar with jthis == NULL." << std::endl;
        
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XMLGregorianCalendar::setTime jthis=",jthis);
    
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "setTime", "(IIII)V");
        if (NULL == mid) {
            std::cerr << "Class javax.xml.datatype.XMLGregorianCalendar has no method named setTime with signature (IIII)V." << std::endl;
            
        } else {
             env->CallVoidMethod(jthis, mid ,int_0,int_1,int_2,int_3 );
        }
    }
    releaseEnv(env);
    
    }
    jint XMLGregorianCalendar::getMillisecond() {

    if(jthis == NULL) {
        std::cerr << "Call of method getMillisecond of javax.xml.datatype.XMLGregorianCalendar with jthis == NULL." << std::endl;
        return (jint) -1;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XMLGregorianCalendar::getMillisecond jthis=",jthis);
    jint retVal= (jint) -1;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "getMillisecond", "()I");
        if (NULL == mid) {
            std::cerr << "Class javax.xml.datatype.XMLGregorianCalendar has no method named getMillisecond with signature ()I." << std::endl;
            return (jint) -1;
        } else {
            retVal= (jint)  env->CallIntMethod(jthis, mid  );
        }
    }
    releaseEnv(env);
    return retVal;
    }
    jboolean XMLGregorianCalendar::equals(::crclj::java::lang::Object  &object_0) {

    if(jthis == NULL) {
        std::cerr << "Call of method equals of javax.xml.datatype.XMLGregorianCalendar with jthis == NULL." << std::endl;
        return false;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XMLGregorianCalendar::equals jthis=",jthis);
    jboolean retVal=false;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
        if (NULL == mid) {
            std::cerr << "Class javax.xml.datatype.XMLGregorianCalendar has no method named equals with signature (Ljava/lang/Object;)Z." << std::endl;
            return false;
        } else {
            retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,object_0.jthis );
        }
    }
    releaseEnv(env);
    return retVal;
    }
    jstring XMLGregorianCalendar::toString() {

    if(jthis == NULL) {
        std::cerr << "Call of method toString of javax.xml.datatype.XMLGregorianCalendar with jthis == NULL." << std::endl;
        return NULL;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XMLGregorianCalendar::toString jthis=",jthis);
    jstring retVal=NULL;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "toString", "()Ljava/lang/String;");
        if (NULL == mid) {
            std::cerr << "Class javax.xml.datatype.XMLGregorianCalendar has no method named toString with signature ()Ljava/lang/String;." << std::endl;
            return NULL;
        } else {
            retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
        }
    }
    releaseEnv(env);
    return retVal;
    }
    jint XMLGregorianCalendar::hashCode() {

    if(jthis == NULL) {
        std::cerr << "Call of method hashCode of javax.xml.datatype.XMLGregorianCalendar with jthis == NULL." << std::endl;
        return (jint) -1;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," XMLGregorianCalendar::hashCode jthis=",jthis);
    jint retVal= (jint) -1;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "hashCode", "()I");
        if (NULL == mid) {
            std::cerr << "Class javax.xml.datatype.XMLGregorianCalendar has no method named hashCode with signature ()I." << std::endl;
            return (jint) -1;
        } else {
            retVal= (jint)  env->CallIntMethod(jthis, mid  );
        }
    }
    releaseEnv(env);
    return retVal;
    }
    static jclass getNewXMLGregorianCalendarClass() {
        jclass clss = getEnv()->FindClass("javax/xml/datatype/XMLGregorianCalendar");
        if (NULL == clss) {
            std::cerr << " Can't find class javax/xml/datatype/XMLGregorianCalendar" << std::endl;
        }
        return clss;
    }
    
    static jclass XMLGregorianCalendarClass = NULL;
    static inline jclass getXMLGregorianCalendarClass() {
        if (XMLGregorianCalendarClass != NULL) {
            return XMLGregorianCalendarClass;
        }
        XMLGregorianCalendarClass = getNewXMLGregorianCalendarClass();
    }
   } // end namespace datatype
  } // end namespace xml
 } // end namespace javax

  namespace java{
   namespace io{
   
   // get JNI handle for class java.io.OutputStream
   static inline jclass getOutputStreamClass();
   
   OutputStream::OutputStream(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   OutputStream::OutputStream(const OutputStream &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   OutputStream::OutputStream() {
    JNIEnv *env =getEnv();
    static jclass cls = getOutputStreamClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class OutputStream has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new OutputStream jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for java.io.OutputStream
   OutputStream::~OutputStream() {
   	// Place-holder for later extensibility.
   }

   void OutputStream::write(jbyteArray byteArray_0,jint int_1,jint int_2) {

   if(jthis == NULL) {
       std::cerr << "Call of method write of java.io.OutputStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," OutputStream::write jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "write", "([BII)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.OutputStream has no method named write with signature ([BII)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,byteArray_0,int_1,int_2 );
       }
   }
   releaseEnv(env);
   
   }
   void OutputStream::write(jbyteArray byteArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method write of java.io.OutputStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," OutputStream::write jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "write", "([B)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.OutputStream has no method named write with signature ([B)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,byteArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void OutputStream::flush() {

   if(jthis == NULL) {
       std::cerr << "Call of method flush of java.io.OutputStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," OutputStream::flush jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "flush", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.io.OutputStream has no method named flush with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void OutputStream::close() {

   if(jthis == NULL) {
       std::cerr << "Call of method close of java.io.OutputStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," OutputStream::close jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "close", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.io.OutputStream has no method named close with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewOutputStreamClass() {
       jclass clss = getEnv()->FindClass("java/io/OutputStream");
       if (NULL == clss) {
           std::cerr << " Can't find class java/io/OutputStream" << std::endl;
       }
       return clss;
   }
   
   static jclass OutputStreamClass = NULL;
   static inline jclass getOutputStreamClass() {
       if (OutputStreamClass != NULL) {
           return OutputStreamClass;
       }
       OutputStreamClass = getNewOutputStreamClass();
   }
   
   // get JNI handle for class java.io.FilterOutputStream
   static inline jclass getFilterOutputStreamClass();
   
   FilterOutputStream::FilterOutputStream(jobject _jthis, bool copy): OutputStream(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   FilterOutputStream::FilterOutputStream(const FilterOutputStream &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   FilterOutputStream::FilterOutputStream(OutputStream  &outputStream_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getFilterOutputStreamClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/io/OutputStream;)V");
        if (NULL == mid) {
            std::cerr << "Class FilterOutputStream has no method constructor signature (Ljava/io/OutputStream;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,outputStream_0.jthis);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new FilterOutputStream jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for java.io.FilterOutputStream
   FilterOutputStream::~FilterOutputStream() {
   	// Place-holder for later extensibility.
   }

   void FilterOutputStream::write(jbyteArray byteArray_0,jint int_1,jint int_2) {

   if(jthis == NULL) {
       std::cerr << "Call of method write of java.io.FilterOutputStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," FilterOutputStream::write jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "write", "([BII)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.FilterOutputStream has no method named write with signature ([BII)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,byteArray_0,int_1,int_2 );
       }
   }
   releaseEnv(env);
   
   }
   void FilterOutputStream::write(jbyteArray byteArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method write of java.io.FilterOutputStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," FilterOutputStream::write jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "write", "([B)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.FilterOutputStream has no method named write with signature ([B)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,byteArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void FilterOutputStream::write(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method write of java.io.FilterOutputStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," FilterOutputStream::write jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "write", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.FilterOutputStream has no method named write with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   void FilterOutputStream::flush() {

   if(jthis == NULL) {
       std::cerr << "Call of method flush of java.io.FilterOutputStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," FilterOutputStream::flush jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "flush", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.io.FilterOutputStream has no method named flush with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void FilterOutputStream::close() {

   if(jthis == NULL) {
       std::cerr << "Call of method close of java.io.FilterOutputStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," FilterOutputStream::close jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "close", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.io.FilterOutputStream has no method named close with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewFilterOutputStreamClass() {
       jclass clss = getEnv()->FindClass("java/io/FilterOutputStream");
       if (NULL == clss) {
           std::cerr << " Can't find class java/io/FilterOutputStream" << std::endl;
       }
       return clss;
   }
   
   static jclass FilterOutputStreamClass = NULL;
   static inline jclass getFilterOutputStreamClass() {
       if (FilterOutputStreamClass != NULL) {
           return FilterOutputStreamClass;
       }
       FilterOutputStreamClass = getNewFilterOutputStreamClass();
   }
   
   // get JNI handle for class java.io.PrintStream
   static inline jclass getPrintStreamClass();
   
   PrintStream::PrintStream(jobject _jthis, bool copy): FilterOutputStream(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   PrintStream::PrintStream(const PrintStream &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   PrintStream::PrintStream(OutputStream  &outputStream_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getPrintStreamClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/io/OutputStream;)V");
        if (NULL == mid) {
            std::cerr << "Class PrintStream has no method constructor signature (Ljava/io/OutputStream;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,outputStream_0.jthis);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PrintStream jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PrintStream::PrintStream(OutputStream  &outputStream_0,jboolean boolean_1) {
    JNIEnv *env =getEnv();
    static jclass cls = getPrintStreamClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/io/OutputStream;Z)V");
        if (NULL == mid) {
            std::cerr << "Class PrintStream has no method constructor signature (Ljava/io/OutputStream;Z)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,outputStream_0.jthis,boolean_1);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PrintStream jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PrintStream::PrintStream(OutputStream  &outputStream_0,jboolean boolean_1,jstring string_2) {
    JNIEnv *env =getEnv();
    static jclass cls = getPrintStreamClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/io/OutputStream;ZLjava/lang/String;)V");
        if (NULL == mid) {
            std::cerr << "Class PrintStream has no method constructor signature (Ljava/io/OutputStream;ZLjava/lang/String;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,outputStream_0.jthis,boolean_1,string_2);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PrintStream jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PrintStream::PrintStream(jstring string_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getPrintStreamClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        if (NULL == mid) {
            std::cerr << "Class PrintStream has no method constructor signature (Ljava/lang/String;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,string_0);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PrintStream jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PrintStream::PrintStream(jstring string_0,jstring string_1) {
    JNIEnv *env =getEnv();
    static jclass cls = getPrintStreamClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/lang/String;Ljava/lang/String;)V");
        if (NULL == mid) {
            std::cerr << "Class PrintStream has no method constructor signature (Ljava/lang/String;Ljava/lang/String;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,string_0,string_1);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PrintStream jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PrintStream::PrintStream(File  &file_0,jstring string_1) {
    JNIEnv *env =getEnv();
    static jclass cls = getPrintStreamClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/io/File;Ljava/lang/String;)V");
        if (NULL == mid) {
            std::cerr << "Class PrintStream has no method constructor signature (Ljava/io/File;Ljava/lang/String;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,file_0.jthis,string_1);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PrintStream jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PrintStream::PrintStream(File  &file_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getPrintStreamClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/io/File;)V");
        if (NULL == mid) {
            std::cerr << "Class PrintStream has no method constructor signature (Ljava/io/File;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,file_0.jthis);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PrintStream jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for java.io.PrintStream
   PrintStream::~PrintStream() {
   	// Place-holder for later extensibility.
   }

   void PrintStream::println(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method println of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::println jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "println", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named println with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::println(jfloat float_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method println of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::println jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "println", "(F)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named println with signature (F)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,float_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::println(jlong long_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method println of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::println jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "println", "(J)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named println with signature (J)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,long_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::println(::crclj::java::lang::Object  &object_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method println of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::println jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "println", "(Ljava/lang/Object;)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named println with signature (Ljava/lang/Object;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,object_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::println(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method println of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::println jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "println", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named println with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::println(jcharArray charArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method println of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::println jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "println", "([C)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named println with signature ([C)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,charArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::println() {

   if(jthis == NULL) {
       std::cerr << "Call of method println of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::println jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "println", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named println with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::println(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method println of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::println jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "println", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named println with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::println(jchar char_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method println of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::println jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "println", "(C)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named println with signature (C)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,char_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::println(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method println of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::println jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "println", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named println with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   PrintStream PrintStream::append(jchar char_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method append of java.io.PrintStream with jthis == NULL." << std::endl;
       PrintStream nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::append jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "append", "(C)Ljava/io/PrintStream;");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named append with signature (C)Ljava/io/PrintStream;." << std::endl;
           PrintStream nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,char_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PrintStream retObject(retVal,false);
    return retObject;
   }
   PrintStream PrintStream::format(jstring string_0,jobjectArray objectArray_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method format of java.io.PrintStream with jthis == NULL." << std::endl;
       PrintStream nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::format jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "format", "(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named format with signature (Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;." << std::endl;
           PrintStream nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,string_0,objectArray_1 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PrintStream retObject(retVal,false);
    return retObject;
   }
   void PrintStream::write(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method write of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::write jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "write", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named write with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::write(jbyteArray byteArray_0,jint int_1,jint int_2) {

   if(jthis == NULL) {
       std::cerr << "Call of method write of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::write jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "write", "([BII)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named write with signature ([BII)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,byteArray_0,int_1,int_2 );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::print(jboolean boolean_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method print of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::print jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "print", "(Z)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named print with signature (Z)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,boolean_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::print(jlong long_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method print of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::print jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "print", "(J)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named print with signature (J)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,long_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::print(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method print of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::print jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "print", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named print with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::print(jfloat float_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method print of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::print jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "print", "(F)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named print with signature (F)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,float_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::print(::crclj::java::lang::Object  &object_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method print of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::print jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "print", "(Ljava/lang/Object;)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named print with signature (Ljava/lang/Object;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,object_0.jthis );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::print(jstring string_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method print of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::print jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "print", "(Ljava/lang/String;)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named print with signature (Ljava/lang/String;)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,string_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::print(jcharArray charArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method print of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::print jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "print", "([C)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named print with signature ([C)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,charArray_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::print(jchar char_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method print of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::print jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "print", "(C)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named print with signature (C)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,char_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::print(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method print of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::print jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "print", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named print with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::flush() {

   if(jthis == NULL) {
       std::cerr << "Call of method flush of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::flush jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "flush", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named flush with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void PrintStream::close() {

   if(jthis == NULL) {
       std::cerr << "Call of method close of java.io.PrintStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::close jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "close", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named close with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   jboolean PrintStream::checkError() {

   if(jthis == NULL) {
       std::cerr << "Call of method checkError of java.io.PrintStream with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::checkError jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "checkError", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named checkError with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   PrintStream PrintStream::printf(jstring string_0,jobjectArray objectArray_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method printf of java.io.PrintStream with jthis == NULL." << std::endl;
       PrintStream nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PrintStream::printf jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "printf", "(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;");
       if (NULL == mid) {
           std::cerr << "Class java.io.PrintStream has no method named printf with signature (Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;." << std::endl;
           PrintStream nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,string_0,objectArray_1 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PrintStream retObject(retVal,false);
    return retObject;
   }
   static jclass getNewPrintStreamClass() {
       jclass clss = getEnv()->FindClass("java/io/PrintStream");
       if (NULL == clss) {
           std::cerr << " Can't find class java/io/PrintStream" << std::endl;
       }
       return clss;
   }
   
   static jclass PrintStreamClass = NULL;
   static inline jclass getPrintStreamClass() {
       if (PrintStreamClass != NULL) {
           return PrintStreamClass;
       }
       PrintStreamClass = getNewPrintStreamClass();
   }
  } // end namespace io

   namespace util{
    namespace function{
    
    // get JNI handle for class java.util.function.Predicate
    static inline jclass getPredicateClass();
    
    Predicate::Predicate(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
            // Place holder for future extensibility
    }
    
    Predicate::Predicate(const Predicate &objref) {
        jobject _jthis = objref.jthis;
        if (_jthis != NULL) {
            jthis = getEnv()->NewGlobalRef(_jthis);
        }
    }
    Predicate::Predicate() {
    JNIEnv *env =getEnv();
    static jclass cls = getPredicateClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class Predicate has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Predicate jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
    }


    // Destructor for java.util.function.Predicate
    Predicate::~Predicate() {
    	// Place-holder for later extensibility.
    }

    Predicate Predicate::isEqual(::crclj::java::lang::Object  &object_0) {

    JNIEnv *env =getEnv();
    static jclass cls = getPredicateClass();
    jobject retVal=NULL;
    if (cls != NULL) {
        static jmethodID mid = env->GetStaticMethodID(cls, "isEqual", "(Ljava/lang/Object;)Ljava/util/function/Predicate;");
        if (NULL == mid) {
            std::cerr << "Class java.util.function.Predicate has no method named isEqual with signature (Ljava/lang/Object;)Ljava/util/function/Predicate;." << std::endl;
            Predicate nullObject((jobject)NULL,false); return nullObject;
        } else {
            retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,object_0.jthis );
        }
    }
    releaseEnv(env);
         
     jobjectRefType ref = env->GetObjectRefType(retVal);
     std::cout << "ref=" << ref << std::endl;
     std::cout << "retVal=" << retVal << std::endl;
     Predicate retObject(retVal,false);
     return retObject;
    }
    Predicate Predicate::negate() {

    if(jthis == NULL) {
        std::cerr << "Call of method negate of java.util.function.Predicate with jthis == NULL." << std::endl;
        Predicate nullObject((jobject)NULL,false); return nullObject;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Predicate::negate jthis=",jthis);
    jobject retVal=NULL;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "negate", "()Ljava/util/function/Predicate;");
        if (NULL == mid) {
            std::cerr << "Class java.util.function.Predicate has no method named negate with signature ()Ljava/util/function/Predicate;." << std::endl;
            Predicate nullObject((jobject)NULL,false); return nullObject;
        } else {
            retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
        }
    }
    releaseEnv(env);
         
     jobjectRefType ref = env->GetObjectRefType(retVal);
     std::cout << "ref=" << ref << std::endl;
     std::cout << "retVal=" << retVal << std::endl;
     Predicate retObject(retVal,false);
     return retObject;
    }
    Predicate Predicate::andMethod(Predicate  &predicate_0) {

    if(jthis == NULL) {
        std::cerr << "Call of method andMethod of java.util.function.Predicate with jthis == NULL." << std::endl;
        Predicate nullObject((jobject)NULL,false); return nullObject;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Predicate::andMethod jthis=",jthis);
    jobject retVal=NULL;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "andMethod", "(Ljava/util/function/Predicate;)Ljava/util/function/Predicate;");
        if (NULL == mid) {
            std::cerr << "Class java.util.function.Predicate has no method named andMethod with signature (Ljava/util/function/Predicate;)Ljava/util/function/Predicate;." << std::endl;
            Predicate nullObject((jobject)NULL,false); return nullObject;
        } else {
            retVal= (jobject)  env->CallObjectMethod(jthis, mid ,predicate_0.jthis );
        }
    }
    releaseEnv(env);
         
     jobjectRefType ref = env->GetObjectRefType(retVal);
     std::cout << "ref=" << ref << std::endl;
     std::cout << "retVal=" << retVal << std::endl;
     Predicate retObject(retVal,false);
     return retObject;
    }
    Predicate Predicate::orMethod(Predicate  &predicate_0) {

    if(jthis == NULL) {
        std::cerr << "Call of method orMethod of java.util.function.Predicate with jthis == NULL." << std::endl;
        Predicate nullObject((jobject)NULL,false); return nullObject;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Predicate::orMethod jthis=",jthis);
    jobject retVal=NULL;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "orMethod", "(Ljava/util/function/Predicate;)Ljava/util/function/Predicate;");
        if (NULL == mid) {
            std::cerr << "Class java.util.function.Predicate has no method named orMethod with signature (Ljava/util/function/Predicate;)Ljava/util/function/Predicate;." << std::endl;
            Predicate nullObject((jobject)NULL,false); return nullObject;
        } else {
            retVal= (jobject)  env->CallObjectMethod(jthis, mid ,predicate_0.jthis );
        }
    }
    releaseEnv(env);
         
     jobjectRefType ref = env->GetObjectRefType(retVal);
     std::cout << "ref=" << ref << std::endl;
     std::cout << "retVal=" << retVal << std::endl;
     Predicate retObject(retVal,false);
     return retObject;
    }
    static jclass getNewPredicateClass() {
        jclass clss = getEnv()->FindClass("java/util/function/Predicate");
        if (NULL == clss) {
            std::cerr << " Can't find class java/util/function/Predicate" << std::endl;
        }
        return clss;
    }
    
    static jclass PredicateClass = NULL;
    static inline jclass getPredicateClass() {
        if (PredicateClass != NULL) {
            return PredicateClass;
        }
        PredicateClass = getNewPredicateClass();
    }
   } // end namespace function
  } // end namespace util

   namespace math{
   
   // get JNI handle for class java.math.BigInteger
   static inline jclass getBigIntegerClass();
   
   BigInteger::BigInteger(jobject _jthis, bool copy): ::crclj::java::lang::Number(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   BigInteger::BigInteger(const BigInteger &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   BigInteger::BigInteger(jstring string_0,jint int_1) {
    JNIEnv *env =getEnv();
    static jclass cls = getBigIntegerClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/lang/String;I)V");
        if (NULL == mid) {
            std::cerr << "Class BigInteger has no method constructor signature (Ljava/lang/String;I)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,string_0,int_1);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new BigInteger jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   BigInteger::BigInteger(jint int_0,jbyteArray byteArray_1) {
    JNIEnv *env =getEnv();
    static jclass cls = getBigIntegerClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(I[B)V");
        if (NULL == mid) {
            std::cerr << "Class BigInteger has no method constructor signature (I[B)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,int_0,byteArray_1);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new BigInteger jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   BigInteger::BigInteger(jbyteArray byteArray_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getBigIntegerClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "([B)V");
        if (NULL == mid) {
            std::cerr << "Class BigInteger has no method constructor signature ([B)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,byteArray_0);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new BigInteger jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   BigInteger::BigInteger(jstring string_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getBigIntegerClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        if (NULL == mid) {
            std::cerr << "Class BigInteger has no method constructor signature (Ljava/lang/String;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,string_0);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new BigInteger jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for java.math.BigInteger
   BigInteger::~BigInteger() {
   	// Place-holder for later extensibility.
   }

   BigInteger BigInteger::mod(BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method mod of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::mod jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "mod", "(Ljava/math/BigInteger;)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named mod with signature (Ljava/math/BigInteger;)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   jobjectArray BigInteger::divideAndRemainder(BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method divideAndRemainder of java.math.BigInteger with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::divideAndRemainder jthis=",jthis);
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "divideAndRemainder", "(Ljava/math/BigInteger;)[Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named divideAndRemainder with signature (Ljava/math/BigInteger;)[Ljava/math/BigInteger;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallObjectMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jlong BigInteger::longValueExact() {

   if(jthis == NULL) {
       std::cerr << "Call of method longValueExact of java.math.BigInteger with jthis == NULL." << std::endl;
       return (jlong) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::longValueExact jthis=",jthis);
   jlong retVal= (jlong) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "longValueExact", "()J");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named longValueExact with signature ()J." << std::endl;
           return (jlong) -1;
       } else {
           retVal= (jlong)  env->CallLongMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint BigInteger::intValueExact() {

   if(jthis == NULL) {
       std::cerr << "Call of method intValueExact of java.math.BigInteger with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::intValueExact jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "intValueExact", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named intValueExact with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jshort BigInteger::shortValueExact() {

   if(jthis == NULL) {
       std::cerr << "Call of method shortValueExact of java.math.BigInteger with jthis == NULL." << std::endl;
       return (jshort) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::shortValueExact jthis=",jthis);
   jshort retVal=(jshort) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "shortValueExact", "()S");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named shortValueExact with signature ()S." << std::endl;
           return (jshort) -1;
       } else {
           retVal= (jshort)  env->CallShortMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jbyte BigInteger::byteValueExact() {

   if(jthis == NULL) {
       std::cerr << "Call of method byteValueExact of java.math.BigInteger with jthis == NULL." << std::endl;
       return (jbyte) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::byteValueExact jthis=",jthis);
   jbyte retVal= (jbyte) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "byteValueExact", "()B");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named byteValueExact with signature ()B." << std::endl;
           return (jbyte) -1;
       } else {
           retVal= (jbyte)  env->CallByteMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint BigInteger::bitLength() {

   if(jthis == NULL) {
       std::cerr << "Call of method bitLength of java.math.BigInteger with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::bitLength jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "bitLength", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named bitLength with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean BigInteger::testBit(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method testBit of java.math.BigInteger with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::testBit jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "testBit", "(I)Z");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named testBit with signature (I)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   BigInteger BigInteger::notMethod() {

   if(jthis == NULL) {
       std::cerr << "Call of method notMethod of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::notMethod jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "notMethod", "()Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named notMethod with signature ()Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigInteger BigInteger::nextProbablePrime() {

   if(jthis == NULL) {
       std::cerr << "Call of method nextProbablePrime of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::nextProbablePrime jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "nextProbablePrime", "()Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named nextProbablePrime with signature ()Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigInteger BigInteger::modPow(BigInteger  &bigInteger_0,BigInteger  &bigInteger_1) {

   if(jthis == NULL) {
       std::cerr << "Call of method modPow of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::modPow jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "modPow", "(Ljava/math/BigInteger;Ljava/math/BigInteger;)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named modPow with signature (Ljava/math/BigInteger;Ljava/math/BigInteger;)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigInteger_0.jthis,bigInteger_1.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigInteger BigInteger::modInverse(BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method modInverse of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::modInverse jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "modInverse", "(Ljava/math/BigInteger;)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named modInverse with signature (Ljava/math/BigInteger;)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigInteger BigInteger::clearBit(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method clearBit of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::clearBit jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "clearBit", "(I)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named clearBit with signature (I)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   jint BigInteger::getLowestSetBit() {

   if(jthis == NULL) {
       std::cerr << "Call of method getLowestSetBit of java.math.BigInteger with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::getLowestSetBit jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getLowestSetBit", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named getLowestSetBit with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean BigInteger::isProbablePrime(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method isProbablePrime of java.math.BigInteger with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::isProbablePrime jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isProbablePrime", "(I)Z");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named isProbablePrime with signature (I)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   BigInteger BigInteger::subtract(BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method subtract of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::subtract jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "subtract", "(Ljava/math/BigInteger;)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named subtract with signature (Ljava/math/BigInteger;)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigInteger BigInteger::multiply(BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method multiply of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::multiply jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "multiply", "(Ljava/math/BigInteger;)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named multiply with signature (Ljava/math/BigInteger;)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigInteger BigInteger::negate() {

   if(jthis == NULL) {
       std::cerr << "Call of method negate of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::negate jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "negate", "()Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named negate with signature ()Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigInteger BigInteger::shiftRight(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method shiftRight of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::shiftRight jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "shiftRight", "(I)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named shiftRight with signature (I)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigInteger BigInteger::setBit(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setBit of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::setBit jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setBit", "(I)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named setBit with signature (I)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigInteger BigInteger::flipBit(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method flipBit of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::flipBit jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "flipBit", "(I)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named flipBit with signature (I)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigInteger BigInteger::gcd(BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method gcd of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::gcd jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "gcd", "(Ljava/math/BigInteger;)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named gcd with signature (Ljava/math/BigInteger;)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigInteger BigInteger::add(BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method add of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::add jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "add", "(Ljava/math/BigInteger;)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named add with signature (Ljava/math/BigInteger;)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   jint BigInteger::bitCount() {

   if(jthis == NULL) {
       std::cerr << "Call of method bitCount of java.math.BigInteger with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::bitCount jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "bitCount", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named bitCount with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean BigInteger::equals(::crclj::java::lang::Object  &object_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method equals of java.math.BigInteger with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::equals jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named equals with signature (Ljava/lang/Object;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,object_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring BigInteger::toString() {

   if(jthis == NULL) {
       std::cerr << "Call of method toString of java.math.BigInteger with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::toString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toString", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named toString with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring BigInteger::toString(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method toString of java.math.BigInteger with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::toString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toString", "(I)Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named toString with signature (I)Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint BigInteger::hashCode() {

   if(jthis == NULL) {
       std::cerr << "Call of method hashCode of java.math.BigInteger with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::hashCode jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "hashCode", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named hashCode with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   BigInteger BigInteger::abs() {

   if(jthis == NULL) {
       std::cerr << "Call of method abs of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::abs jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "abs", "()Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named abs with signature ()Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigInteger BigInteger::pow(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method pow of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::pow jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "pow", "(I)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named pow with signature (I)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigInteger BigInteger::min(BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method min of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::min jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "min", "(Ljava/math/BigInteger;)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named min with signature (Ljava/math/BigInteger;)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigInteger BigInteger::max(BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method max of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::max jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "max", "(Ljava/math/BigInteger;)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named max with signature (Ljava/math/BigInteger;)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   jint BigInteger::compareTo(BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method compareTo of java.math.BigInteger with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::compareTo jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "compareTo", "(Ljava/math/BigInteger;)I");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named compareTo with signature (Ljava/math/BigInteger;)I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint BigInteger::intValue() {

   if(jthis == NULL) {
       std::cerr << "Call of method intValue of java.math.BigInteger with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::intValue jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "intValue", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named intValue with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jlong BigInteger::longValue() {

   if(jthis == NULL) {
       std::cerr << "Call of method longValue of java.math.BigInteger with jthis == NULL." << std::endl;
       return (jlong) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::longValue jthis=",jthis);
   jlong retVal= (jlong) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "longValue", "()J");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named longValue with signature ()J." << std::endl;
           return (jlong) -1;
       } else {
           retVal= (jlong)  env->CallLongMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jfloat BigInteger::floatValue() {

   if(jthis == NULL) {
       std::cerr << "Call of method floatValue of java.math.BigInteger with jthis == NULL." << std::endl;
       return (jfloat) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::floatValue jthis=",jthis);
   jfloat retVal= (jfloat) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "floatValue", "()F");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named floatValue with signature ()F." << std::endl;
           return (jfloat) -1.0;
       } else {
           retVal= (jfloat)  env->CallFloatMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jdouble BigInteger::doubleValue() {

   if(jthis == NULL) {
       std::cerr << "Call of method doubleValue of java.math.BigInteger with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::doubleValue jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "doubleValue", "()D");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named doubleValue with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   BigInteger BigInteger::valueOf(jlong long_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getBigIntegerClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "valueOf", "(J)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named valueOf with signature (J)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,long_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   jint BigInteger::signum() {

   if(jthis == NULL) {
       std::cerr << "Call of method signum of java.math.BigInteger with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::signum jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "signum", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named signum with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   BigInteger BigInteger::shiftLeft(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method shiftLeft of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::shiftLeft jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "shiftLeft", "(I)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named shiftLeft with signature (I)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigInteger BigInteger::divide(BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method divide of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::divide jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "divide", "(Ljava/math/BigInteger;)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named divide with signature (Ljava/math/BigInteger;)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigInteger BigInteger::remainder(BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method remainder of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::remainder jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "remainder", "(Ljava/math/BigInteger;)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named remainder with signature (Ljava/math/BigInteger;)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   jbyteArray BigInteger::toByteArray() {

   if(jthis == NULL) {
       std::cerr << "Call of method toByteArray of java.math.BigInteger with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::toByteArray jthis=",jthis);
   jbyteArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toByteArray", "()[B");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named toByteArray with signature ()[B." << std::endl;
           return NULL;
       } else {
           retVal= (jbyteArray)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   BigInteger BigInteger::andMethod(BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method andMethod of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::andMethod jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "andMethod", "(Ljava/math/BigInteger;)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named andMethod with signature (Ljava/math/BigInteger;)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigInteger BigInteger::orMethod(BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method orMethod of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::orMethod jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "orMethod", "(Ljava/math/BigInteger;)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named orMethod with signature (Ljava/math/BigInteger;)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigInteger BigInteger::xorMethod(BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method xorMethod of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::xorMethod jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "xorMethod", "(Ljava/math/BigInteger;)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named xorMethod with signature (Ljava/math/BigInteger;)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   BigInteger BigInteger::andNot(BigInteger  &bigInteger_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method andNot of java.math.BigInteger with jthis == NULL." << std::endl;
       BigInteger nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," BigInteger::andNot jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "andNot", "(Ljava/math/BigInteger;)Ljava/math/BigInteger;");
       if (NULL == mid) {
           std::cerr << "Class java.math.BigInteger has no method named andNot with signature (Ljava/math/BigInteger;)Ljava/math/BigInteger;." << std::endl;
           BigInteger nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,bigInteger_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    BigInteger retObject(retVal,false);
    return retObject;
   }
   static jclass getNewBigIntegerClass() {
       jclass clss = getEnv()->FindClass("java/math/BigInteger");
       if (NULL == clss) {
           std::cerr << " Can't find class java/math/BigInteger" << std::endl;
       }
       return clss;
   }
   
   static jclass BigIntegerClass = NULL;
   static inline jclass getBigIntegerClass() {
       if (BigIntegerClass != NULL) {
           return BigIntegerClass;
       }
       BigIntegerClass = getNewBigIntegerClass();
   }
  } // end namespace math
 } // end namespace java

  namespace rcs{
   namespace posemath{
   
   // get JNI handle for class rcs.posemath.PmQuaternion
   static inline jclass getPmQuaternionClass();
   
   PmQuaternion::PmQuaternion(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   PmQuaternion::PmQuaternion(const PmQuaternion &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   PmQuaternion::PmQuaternion() {
    JNIEnv *env =getEnv();
    static jclass cls = getPmQuaternionClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class PmQuaternion has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PmQuaternion jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PmQuaternion::PmQuaternion(PmRpy  &pmRpy_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getPmQuaternionClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Lrcs/posemath/PmRpy;)V");
        if (NULL == mid) {
            std::cerr << "Class PmQuaternion has no method constructor signature (Lrcs/posemath/PmRpy;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,pmRpy_0.jthis);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PmQuaternion jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PmQuaternion::PmQuaternion(jdouble double_0,jdouble double_1,jdouble double_2,jdouble double_3) {
    JNIEnv *env =getEnv();
    static jclass cls = getPmQuaternionClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(DDDD)V");
        if (NULL == mid) {
            std::cerr << "Class PmQuaternion has no method constructor signature (DDDD)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,double_0,double_1,double_2,double_3);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PmQuaternion jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PmQuaternion::PmQuaternion(PmRotationMatrix  &pmRotationMatrix_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getPmQuaternionClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Lrcs/posemath/PmRotationMatrix;)V");
        if (NULL == mid) {
            std::cerr << "Class PmQuaternion has no method constructor signature (Lrcs/posemath/PmRotationMatrix;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,pmRotationMatrix_0.jthis);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PmQuaternion jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }

   PmQuaternion::PmQuaternion(PmRotationVector  &pmRotationVector_0) {
    JNIEnv *env =getEnv();
    static jclass cls = getPmQuaternionClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "(Lrcs/posemath/PmRotationVector;)V");
        if (NULL == mid) {
            std::cerr << "Class PmQuaternion has no method constructor signature (Lrcs/posemath/PmRotationVector;)V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid ,pmRotationVector_0.jthis);
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new PmQuaternion jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for rcs.posemath.PmQuaternion
   PmQuaternion::~PmQuaternion() {
   	// Place-holder for later extensibility.
   }

   jdouble PmQuaternion::getX() {

   if(jthis == NULL) {
       std::cerr << "Call of method getX of rcs.posemath.PmQuaternion with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmQuaternion::getX jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getX", "()D");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmQuaternion has no method named getX with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jdouble PmQuaternion::getY() {

   if(jthis == NULL) {
       std::cerr << "Call of method getY of rcs.posemath.PmQuaternion with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmQuaternion::getY jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getY", "()D");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmQuaternion has no method named getY with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jdouble PmQuaternion::getS() {

   if(jthis == NULL) {
       std::cerr << "Call of method getS of rcs.posemath.PmQuaternion with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmQuaternion::getS jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getS", "()D");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmQuaternion has no method named getS with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PmQuaternion::setS(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setS of rcs.posemath.PmQuaternion with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmQuaternion::setS jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setS", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmQuaternion has no method named setS with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PmQuaternion::setX(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setX of rcs.posemath.PmQuaternion with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmQuaternion::setX jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setX", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmQuaternion has no method named setX with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   void PmQuaternion::setY(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setY of rcs.posemath.PmQuaternion with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmQuaternion::setY jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setY", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmQuaternion has no method named setY with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   jdouble PmQuaternion::getZ() {

   if(jthis == NULL) {
       std::cerr << "Call of method getZ of rcs.posemath.PmQuaternion with jthis == NULL." << std::endl;
       return (jdouble) -1.0;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmQuaternion::getZ jthis=",jthis);
   jdouble retVal= (jdouble) -1.0;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getZ", "()D");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmQuaternion has no method named getZ with signature ()D." << std::endl;
           return (jdouble) -1.0;
       } else {
           retVal= (jdouble)  env->CallDoubleMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void PmQuaternion::setZ(jdouble double_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method setZ of rcs.posemath.PmQuaternion with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmQuaternion::setZ jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "setZ", "(D)V");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmQuaternion has no method named setZ with signature (D)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,double_0 );
       }
   }
   releaseEnv(env);
   
   }
   PmQuaternion PmQuaternion::multipy(PmQuaternion  &pmQuaternion_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method multipy of rcs.posemath.PmQuaternion with jthis == NULL." << std::endl;
       PmQuaternion nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmQuaternion::multipy jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "multipy", "(Lrcs/posemath/PmQuaternion;)Lrcs/posemath/PmQuaternion;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmQuaternion has no method named multipy with signature (Lrcs/posemath/PmQuaternion;)Lrcs/posemath/PmQuaternion;." << std::endl;
           PmQuaternion nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,pmQuaternion_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PmQuaternion retObject(retVal,false);
    return retObject;
   }
   jboolean PmQuaternion::equals(PmRotationVector  &pmRotationVector_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method equals of rcs.posemath.PmQuaternion with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmQuaternion::equals jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "equals", "(Lrcs/posemath/PmRotationVector;)Z");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmQuaternion has no method named equals with signature (Lrcs/posemath/PmRotationVector;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,pmRotationVector_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PmQuaternion::equals(PmRotationMatrix  &pmRotationMatrix_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method equals of rcs.posemath.PmQuaternion with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmQuaternion::equals jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "equals", "(Lrcs/posemath/PmRotationMatrix;)Z");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmQuaternion has no method named equals with signature (Lrcs/posemath/PmRotationMatrix;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,pmRotationMatrix_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean PmQuaternion::equals(PmQuaternion  &pmQuaternion_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method equals of rcs.posemath.PmQuaternion with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmQuaternion::equals jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "equals", "(Lrcs/posemath/PmQuaternion;)Z");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmQuaternion has no method named equals with signature (Lrcs/posemath/PmQuaternion;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,pmQuaternion_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring PmQuaternion::toString() {

   if(jthis == NULL) {
       std::cerr << "Call of method toString of rcs.posemath.PmQuaternion with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmQuaternion::toString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toString", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmQuaternion has no method named toString with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   PmQuaternion PmQuaternion::clone() {

   if(jthis == NULL) {
       std::cerr << "Call of method clone of rcs.posemath.PmQuaternion with jthis == NULL." << std::endl;
       PmQuaternion nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," PmQuaternion::clone jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "clone", "()Lrcs/posemath/PmQuaternion;");
       if (NULL == mid) {
           std::cerr << "Class rcs.posemath.PmQuaternion has no method named clone with signature ()Lrcs/posemath/PmQuaternion;." << std::endl;
           PmQuaternion nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    PmQuaternion retObject(retVal,false);
    return retObject;
   }
   static jclass getNewPmQuaternionClass() {
       jclass clss = getEnv()->FindClass("rcs/posemath/PmQuaternion");
       if (NULL == clss) {
           std::cerr << " Can't find class rcs/posemath/PmQuaternion" << std::endl;
       }
       return clss;
   }
   
   static jclass PmQuaternionClass = NULL;
   static inline jclass getPmQuaternionClass() {
       if (PmQuaternionClass != NULL) {
           return PmQuaternionClass;
       }
       PmQuaternionClass = getNewPmQuaternionClass();
   }
  } // end namespace posemath
 } // end namespace rcs

  namespace java{
   namespace net{
   
   // get JNI handle for class java.net.InetAddress
   static inline jclass getInetAddressClass();
   
   InetAddress::InetAddress(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   InetAddress::InetAddress(const InetAddress &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }

   // Destructor for java.net.InetAddress
   InetAddress::~InetAddress() {
   	// Place-holder for later extensibility.
   }

   jboolean InetAddress::isLoopbackAddress() {

   if(jthis == NULL) {
       std::cerr << "Call of method isLoopbackAddress of java.net.InetAddress with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InetAddress::isLoopbackAddress jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isLoopbackAddress", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named isLoopbackAddress with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean InetAddress::isLinkLocalAddress() {

   if(jthis == NULL) {
       std::cerr << "Call of method isLinkLocalAddress of java.net.InetAddress with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InetAddress::isLinkLocalAddress jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isLinkLocalAddress", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named isLinkLocalAddress with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean InetAddress::isSiteLocalAddress() {

   if(jthis == NULL) {
       std::cerr << "Call of method isSiteLocalAddress of java.net.InetAddress with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InetAddress::isSiteLocalAddress jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isSiteLocalAddress", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named isSiteLocalAddress with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean InetAddress::isMCGlobal() {

   if(jthis == NULL) {
       std::cerr << "Call of method isMCGlobal of java.net.InetAddress with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InetAddress::isMCGlobal jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isMCGlobal", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named isMCGlobal with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean InetAddress::isMCNodeLocal() {

   if(jthis == NULL) {
       std::cerr << "Call of method isMCNodeLocal of java.net.InetAddress with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InetAddress::isMCNodeLocal jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isMCNodeLocal", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named isMCNodeLocal with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean InetAddress::isMCLinkLocal() {

   if(jthis == NULL) {
       std::cerr << "Call of method isMCLinkLocal of java.net.InetAddress with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InetAddress::isMCLinkLocal jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isMCLinkLocal", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named isMCLinkLocal with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean InetAddress::isMCSiteLocal() {

   if(jthis == NULL) {
       std::cerr << "Call of method isMCSiteLocal of java.net.InetAddress with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InetAddress::isMCSiteLocal jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isMCSiteLocal", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named isMCSiteLocal with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean InetAddress::isMCOrgLocal() {

   if(jthis == NULL) {
       std::cerr << "Call of method isMCOrgLocal of java.net.InetAddress with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InetAddress::isMCOrgLocal jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isMCOrgLocal", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named isMCOrgLocal with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean InetAddress::isReachable(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method isReachable of java.net.InetAddress with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InetAddress::isReachable jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isReachable", "(I)Z");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named isReachable with signature (I)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring InetAddress::getCanonicalHostName() {

   if(jthis == NULL) {
       std::cerr << "Call of method getCanonicalHostName of java.net.InetAddress with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InetAddress::getCanonicalHostName jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getCanonicalHostName", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named getCanonicalHostName with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   InetAddress InetAddress::getByAddress(jbyteArray byteArray_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getInetAddressClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "getByAddress", "([B)Ljava/net/InetAddress;");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named getByAddress with signature ([B)Ljava/net/InetAddress;." << std::endl;
           InetAddress nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,byteArray_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    InetAddress retObject(retVal,false);
    return retObject;
   }
   InetAddress InetAddress::getByAddress(jstring string_0,jbyteArray byteArray_1) {

   JNIEnv *env =getEnv();
   static jclass cls = getInetAddressClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "getByAddress", "(Ljava/lang/String;[B)Ljava/net/InetAddress;");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named getByAddress with signature (Ljava/lang/String;[B)Ljava/net/InetAddress;." << std::endl;
           InetAddress nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,string_0,byteArray_1 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    InetAddress retObject(retVal,false);
    return retObject;
   }
   jobjectArray InetAddress::getAllByName(jstring string_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getInetAddressClass();
   jobjectArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "getAllByName", "(Ljava/lang/String;)[Ljava/net/InetAddress;");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named getAllByName with signature (Ljava/lang/String;)[Ljava/net/InetAddress;." << std::endl;
           return NULL;
       } else {
           retVal= (jobjectArray)  env->CallStaticObjectMethod( cls, mid ,string_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   InetAddress InetAddress::getByName(jstring string_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getInetAddressClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "getByName", "(Ljava/lang/String;)Ljava/net/InetAddress;");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named getByName with signature (Ljava/lang/String;)Ljava/net/InetAddress;." << std::endl;
           InetAddress nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,string_0 );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    InetAddress retObject(retVal,false);
    return retObject;
   }
   InetAddress InetAddress::getLoopbackAddress() {

   JNIEnv *env =getEnv();
   static jclass cls = getInetAddressClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "getLoopbackAddress", "()Ljava/net/InetAddress;");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named getLoopbackAddress with signature ()Ljava/net/InetAddress;." << std::endl;
           InetAddress nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    InetAddress retObject(retVal,false);
    return retObject;
   }
   jboolean InetAddress::isMulticastAddress() {

   if(jthis == NULL) {
       std::cerr << "Call of method isMulticastAddress of java.net.InetAddress with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InetAddress::isMulticastAddress jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isMulticastAddress", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named isMulticastAddress with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean InetAddress::isAnyLocalAddress() {

   if(jthis == NULL) {
       std::cerr << "Call of method isAnyLocalAddress of java.net.InetAddress with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InetAddress::isAnyLocalAddress jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isAnyLocalAddress", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named isAnyLocalAddress with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   InetAddress InetAddress::getLocalHost() {

   JNIEnv *env =getEnv();
   static jclass cls = getInetAddressClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "getLocalHost", "()Ljava/net/InetAddress;");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named getLocalHost with signature ()Ljava/net/InetAddress;." << std::endl;
           InetAddress nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    InetAddress retObject(retVal,false);
    return retObject;
   }
   jboolean InetAddress::equals(::crclj::java::lang::Object  &object_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method equals of java.net.InetAddress with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InetAddress::equals jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named equals with signature (Ljava/lang/Object;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,object_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring InetAddress::toString() {

   if(jthis == NULL) {
       std::cerr << "Call of method toString of java.net.InetAddress with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InetAddress::toString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toString", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named toString with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint InetAddress::hashCode() {

   if(jthis == NULL) {
       std::cerr << "Call of method hashCode of java.net.InetAddress with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InetAddress::hashCode jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "hashCode", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named hashCode with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jbyteArray InetAddress::getAddress() {

   if(jthis == NULL) {
       std::cerr << "Call of method getAddress of java.net.InetAddress with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InetAddress::getAddress jthis=",jthis);
   jbyteArray retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getAddress", "()[B");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named getAddress with signature ()[B." << std::endl;
           return NULL;
       } else {
           retVal= (jbyteArray)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring InetAddress::getHostAddress() {

   if(jthis == NULL) {
       std::cerr << "Call of method getHostAddress of java.net.InetAddress with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InetAddress::getHostAddress jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getHostAddress", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named getHostAddress with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring InetAddress::getHostName() {

   if(jthis == NULL) {
       std::cerr << "Call of method getHostName of java.net.InetAddress with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InetAddress::getHostName jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "getHostName", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.net.InetAddress has no method named getHostName with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   static jclass getNewInetAddressClass() {
       jclass clss = getEnv()->FindClass("java/net/InetAddress");
       if (NULL == clss) {
           std::cerr << " Can't find class java/net/InetAddress" << std::endl;
       }
       return clss;
   }
   
   static jclass InetAddressClass = NULL;
   static inline jclass getInetAddressClass() {
       if (InetAddressClass != NULL) {
           return InetAddressClass;
       }
       InetAddressClass = getNewInetAddressClass();
   }
  } // end namespace net

   namespace util{
    namespace function{
    
    // get JNI handle for class java.util.function.UnaryOperator
    static inline jclass getUnaryOperatorClass();
    
    UnaryOperator::UnaryOperator(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
            // Place holder for future extensibility
    }
    
    UnaryOperator::UnaryOperator(const UnaryOperator &objref) {
        jobject _jthis = objref.jthis;
        if (_jthis != NULL) {
            jthis = getEnv()->NewGlobalRef(_jthis);
        }
    }
    UnaryOperator::UnaryOperator() {
    JNIEnv *env =getEnv();
    static jclass cls = getUnaryOperatorClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class UnaryOperator has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new UnaryOperator jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
    }


    // Destructor for java.util.function.UnaryOperator
    UnaryOperator::~UnaryOperator() {
    	// Place-holder for later extensibility.
    }

    UnaryOperator UnaryOperator::identity() {

    JNIEnv *env =getEnv();
    static jclass cls = getUnaryOperatorClass();
    jobject retVal=NULL;
    if (cls != NULL) {
        static jmethodID mid = env->GetStaticMethodID(cls, "identity", "()Ljava/util/function/UnaryOperator;");
        if (NULL == mid) {
            std::cerr << "Class java.util.function.UnaryOperator has no method named identity with signature ()Ljava/util/function/UnaryOperator;." << std::endl;
            UnaryOperator nullObject((jobject)NULL,false); return nullObject;
        } else {
            retVal= (jobject)  env->CallStaticObjectMethod( cls, mid  );
        }
    }
    releaseEnv(env);
         
     jobjectRefType ref = env->GetObjectRefType(retVal);
     std::cout << "ref=" << ref << std::endl;
     std::cout << "retVal=" << retVal << std::endl;
     UnaryOperator retObject(retVal,false);
     return retObject;
    }
    static jclass getNewUnaryOperatorClass() {
        jclass clss = getEnv()->FindClass("java/util/function/UnaryOperator");
        if (NULL == clss) {
            std::cerr << " Can't find class java/util/function/UnaryOperator" << std::endl;
        }
        return clss;
    }
    
    static jclass UnaryOperatorClass = NULL;
    static inline jclass getUnaryOperatorClass() {
        if (UnaryOperatorClass != NULL) {
            return UnaryOperatorClass;
        }
        UnaryOperatorClass = getNewUnaryOperatorClass();
    }
   } // end namespace function
  } // end namespace util
 } // end namespace java

  namespace javax{
   namespace xml{
    namespace validation{
    
    // get JNI handle for class javax.xml.validation.Schema
    static inline jclass getSchemaClass();
    
    Schema::Schema(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
            // Place holder for future extensibility
    }
    
    Schema::Schema(const Schema &objref) {
        jobject _jthis = objref.jthis;
        if (_jthis != NULL) {
            jthis = getEnv()->NewGlobalRef(_jthis);
        }
    }

    // Destructor for javax.xml.validation.Schema
    Schema::~Schema() {
    	// Place-holder for later extensibility.
    }

    static jclass getNewSchemaClass() {
        jclass clss = getEnv()->FindClass("javax/xml/validation/Schema");
        if (NULL == clss) {
            std::cerr << " Can't find class javax/xml/validation/Schema" << std::endl;
        }
        return clss;
    }
    
    static jclass SchemaClass = NULL;
    static inline jclass getSchemaClass() {
        if (SchemaClass != NULL) {
            return SchemaClass;
        }
        SchemaClass = getNewSchemaClass();
    }
   } // end namespace validation
  } // end namespace xml
 } // end namespace javax

  namespace java{
   namespace io{
   
   // get JNI handle for class java.io.InputStream
   static inline jclass getInputStreamClass();
   
   InputStream::InputStream(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   InputStream::InputStream(const InputStream &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   InputStream::InputStream() {
    JNIEnv *env =getEnv();
    static jclass cls = getInputStreamClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class InputStream has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new InputStream jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
   }


   // Destructor for java.io.InputStream
   InputStream::~InputStream() {
   	// Place-holder for later extensibility.
   }

   jint InputStream::read(jbyteArray byteArray_0,jint int_1,jint int_2) {

   if(jthis == NULL) {
       std::cerr << "Call of method read of java.io.InputStream with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InputStream::read jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "read", "([BII)I");
       if (NULL == mid) {
           std::cerr << "Class java.io.InputStream has no method named read with signature ([BII)I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid ,byteArray_0,int_1,int_2 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint InputStream::read(jbyteArray byteArray_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method read of java.io.InputStream with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InputStream::read jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "read", "([B)I");
       if (NULL == mid) {
           std::cerr << "Class java.io.InputStream has no method named read with signature ([B)I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid ,byteArray_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void InputStream::close() {

   if(jthis == NULL) {
       std::cerr << "Call of method close of java.io.InputStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InputStream::close jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "close", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.io.InputStream has no method named close with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   void InputStream::mark(jint int_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method mark of java.io.InputStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InputStream::mark jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "mark", "(I)V");
       if (NULL == mid) {
           std::cerr << "Class java.io.InputStream has no method named mark with signature (I)V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid ,int_0 );
       }
   }
   releaseEnv(env);
   
   }
   jlong InputStream::skip(jlong long_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method skip of java.io.InputStream with jthis == NULL." << std::endl;
       return (jlong) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InputStream::skip jthis=",jthis);
   jlong retVal= (jlong) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "skip", "(J)J");
       if (NULL == mid) {
           std::cerr << "Class java.io.InputStream has no method named skip with signature (J)J." << std::endl;
           return (jlong) -1;
       } else {
           retVal= (jlong)  env->CallLongMethod(jthis, mid ,long_0 );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint InputStream::available() {

   if(jthis == NULL) {
       std::cerr << "Call of method available of java.io.InputStream with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InputStream::available jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "available", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.io.InputStream has no method named available with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jboolean InputStream::markSupported() {

   if(jthis == NULL) {
       std::cerr << "Call of method markSupported of java.io.InputStream with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InputStream::markSupported jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "markSupported", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.io.InputStream has no method named markSupported with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   void InputStream::reset() {

   if(jthis == NULL) {
       std::cerr << "Call of method reset of java.io.InputStream with jthis == NULL." << std::endl;
       
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," InputStream::reset jthis=",jthis);
   
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "reset", "()V");
       if (NULL == mid) {
           std::cerr << "Class java.io.InputStream has no method named reset with signature ()V." << std::endl;
           
       } else {
            env->CallVoidMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   
   }
   static jclass getNewInputStreamClass() {
       jclass clss = getEnv()->FindClass("java/io/InputStream");
       if (NULL == clss) {
           std::cerr << " Can't find class java/io/InputStream" << std::endl;
       }
       return clss;
   }
   
   static jclass InputStreamClass = NULL;
   static inline jclass getInputStreamClass() {
       if (InputStreamClass != NULL) {
           return InputStreamClass;
       }
       InputStreamClass = getNewInputStreamClass();
   }
  } // end namespace io
 } // end namespace java

  namespace javax{
   namespace xml{
    namespace transform{
     namespace sax{
     
     // get JNI handle for class javax.xml.transform.sax.SAXSource
     static inline jclass getSAXSourceClass();
     
     SAXSource::SAXSource(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
             // Place holder for future extensibility
     }
     
     SAXSource::SAXSource(const SAXSource &objref) {
         jobject _jthis = objref.jthis;
         if (_jthis != NULL) {
             jthis = getEnv()->NewGlobalRef(_jthis);
         }
     }
     SAXSource::SAXSource() {
      JNIEnv *env =getEnv();
      static jclass cls = getSAXSourceClass();
      if (cls != NULL) {
          static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
          if (NULL == mid) {
              std::cerr << "Class SAXSource has no method constructor signature ()V" << std::endl;
          } else {
              jthis = env->NewObject(cls, mid );
              jobjectRefType ref = env->GetObjectRefType(jthis);
              if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new SAXSource jthis=",jthis);
              if(ref != JNIGlobalRefType) {
                  jthis = env->NewGlobalRef(jthis);
              }
          }
      }
      releaseEnv(env);
     }


     // Destructor for javax.xml.transform.sax.SAXSource
     SAXSource::~SAXSource() {
     	// Place-holder for later extensibility.
     }

     jstring SAXSource::getSystemId() {

     if(jthis == NULL) {
         std::cerr << "Call of method getSystemId of javax.xml.transform.sax.SAXSource with jthis == NULL." << std::endl;
         return NULL;
     }
     JNIEnv *env =getEnv();
     jclass cls = env->GetObjectClass(jthis);
     if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SAXSource::getSystemId jthis=",jthis);
     jstring retVal=NULL;
     if (cls != NULL) {
         static jmethodID mid = env->GetMethodID(cls, "getSystemId", "()Ljava/lang/String;");
         if (NULL == mid) {
             std::cerr << "Class javax.xml.transform.sax.SAXSource has no method named getSystemId with signature ()Ljava/lang/String;." << std::endl;
             return NULL;
         } else {
             retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
         }
     }
     releaseEnv(env);
     return retVal;
     }
     void SAXSource::setSystemId(jstring string_0) {

     if(jthis == NULL) {
         std::cerr << "Call of method setSystemId of javax.xml.transform.sax.SAXSource with jthis == NULL." << std::endl;
         
     }
     JNIEnv *env =getEnv();
     jclass cls = env->GetObjectClass(jthis);
     if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," SAXSource::setSystemId jthis=",jthis);
     
     if (cls != NULL) {
         static jmethodID mid = env->GetMethodID(cls, "setSystemId", "(Ljava/lang/String;)V");
         if (NULL == mid) {
             std::cerr << "Class javax.xml.transform.sax.SAXSource has no method named setSystemId with signature (Ljava/lang/String;)V." << std::endl;
             
         } else {
              env->CallVoidMethod(jthis, mid ,string_0 );
         }
     }
     releaseEnv(env);
     
     }
     static jclass getNewSAXSourceClass() {
         jclass clss = getEnv()->FindClass("javax/xml/transform/sax/SAXSource");
         if (NULL == clss) {
             std::cerr << " Can't find class javax/xml/transform/sax/SAXSource" << std::endl;
         }
         return clss;
     }
     
     static jclass SAXSourceClass = NULL;
     static inline jclass getSAXSourceClass() {
         if (SAXSourceClass != NULL) {
             return SAXSourceClass;
         }
         SAXSourceClass = getNewSAXSourceClass();
     }
    } // end namespace sax
   } // end namespace transform
  } // end namespace xml
 } // end namespace javax

  namespace java{
   namespace util{
   
   // get JNI handle for class java.util.Optional
   static inline jclass getOptionalClass();
   
   Optional::Optional(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   Optional::Optional(const Optional &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }

   // Destructor for java.util.Optional
   Optional::~Optional() {
   	// Place-holder for later extensibility.
   }

   Optional Optional::ofNullable(::crclj::java::lang::Object  &object_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getOptionalClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "ofNullable", "(Ljava/lang/Object;)Ljava/util/Optional;");
       if (NULL == mid) {
           std::cerr << "Class java.util.Optional has no method named ofNullable with signature (Ljava/lang/Object;)Ljava/util/Optional;." << std::endl;
           Optional nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,object_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Optional retObject(retVal,false);
    return retObject;
   }
   ::crclj::java::lang::Object Optional::orElse(::crclj::java::lang::Object  &object_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method orElse of java.util.Optional with jthis == NULL." << std::endl;
       ::crclj::java::lang::Object nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Optional::orElse jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "orElse", "(Ljava/lang/Object;)Ljava/lang/Object;");
       if (NULL == mid) {
           std::cerr << "Class java.util.Optional has no method named orElse with signature (Ljava/lang/Object;)Ljava/lang/Object;." << std::endl;
           ::crclj::java::lang::Object nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,object_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::lang::Object retObject(retVal,false);
    return retObject;
   }
   Optional Optional::flatMap(function::Function  &function_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method flatMap of java.util.Optional with jthis == NULL." << std::endl;
       Optional nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Optional::flatMap jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "flatMap", "(Ljava/util/function/Function;)Ljava/util/Optional;");
       if (NULL == mid) {
           std::cerr << "Class java.util.Optional has no method named flatMap with signature (Ljava/util/function/Function;)Ljava/util/Optional;." << std::endl;
           Optional nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,function_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Optional retObject(retVal,false);
    return retObject;
   }
   jboolean Optional::isPresent() {

   if(jthis == NULL) {
       std::cerr << "Call of method isPresent of java.util.Optional with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Optional::isPresent jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "isPresent", "()Z");
       if (NULL == mid) {
           std::cerr << "Class java.util.Optional has no method named isPresent with signature ()Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   ::crclj::java::lang::Object Optional::get() {

   if(jthis == NULL) {
       std::cerr << "Call of method get of java.util.Optional with jthis == NULL." << std::endl;
       ::crclj::java::lang::Object nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Optional::get jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "get", "()Ljava/lang/Object;");
       if (NULL == mid) {
           std::cerr << "Class java.util.Optional has no method named get with signature ()Ljava/lang/Object;." << std::endl;
           ::crclj::java::lang::Object nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    ::crclj::java::lang::Object retObject(retVal,false);
    return retObject;
   }
   jboolean Optional::equals(::crclj::java::lang::Object  &object_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method equals of java.util.Optional with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Optional::equals jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
       if (NULL == mid) {
           std::cerr << "Class java.util.Optional has no method named equals with signature (Ljava/lang/Object;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,object_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jstring Optional::toString() {

   if(jthis == NULL) {
       std::cerr << "Call of method toString of java.util.Optional with jthis == NULL." << std::endl;
       return NULL;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Optional::toString jthis=",jthis);
   jstring retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "toString", "()Ljava/lang/String;");
       if (NULL == mid) {
           std::cerr << "Class java.util.Optional has no method named toString with signature ()Ljava/lang/String;." << std::endl;
           return NULL;
       } else {
           retVal= (jstring)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   jint Optional::hashCode() {

   if(jthis == NULL) {
       std::cerr << "Call of method hashCode of java.util.Optional with jthis == NULL." << std::endl;
       return (jint) -1;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Optional::hashCode jthis=",jthis);
   jint retVal= (jint) -1;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "hashCode", "()I");
       if (NULL == mid) {
           std::cerr << "Class java.util.Optional has no method named hashCode with signature ()I." << std::endl;
           return (jint) -1;
       } else {
           retVal= (jint)  env->CallIntMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   Optional Optional::of(::crclj::java::lang::Object  &object_0) {

   JNIEnv *env =getEnv();
   static jclass cls = getOptionalClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "of", "(Ljava/lang/Object;)Ljava/util/Optional;");
       if (NULL == mid) {
           std::cerr << "Class java.util.Optional has no method named of with signature (Ljava/lang/Object;)Ljava/util/Optional;." << std::endl;
           Optional nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,object_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Optional retObject(retVal,false);
    return retObject;
   }
   Optional Optional::empty() {

   JNIEnv *env =getEnv();
   static jclass cls = getOptionalClass();
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetStaticMethodID(cls, "empty", "()Ljava/util/Optional;");
       if (NULL == mid) {
           std::cerr << "Class java.util.Optional has no method named empty with signature ()Ljava/util/Optional;." << std::endl;
           Optional nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallStaticObjectMethod( cls, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Optional retObject(retVal,false);
    return retObject;
   }
   Optional Optional::filter(function::Predicate  &predicate_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method filter of java.util.Optional with jthis == NULL." << std::endl;
       Optional nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Optional::filter jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "filter", "(Ljava/util/function/Predicate;)Ljava/util/Optional;");
       if (NULL == mid) {
           std::cerr << "Class java.util.Optional has no method named filter with signature (Ljava/util/function/Predicate;)Ljava/util/Optional;." << std::endl;
           Optional nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,predicate_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Optional retObject(retVal,false);
    return retObject;
   }
   Optional Optional::map(function::Function  &function_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method map of java.util.Optional with jthis == NULL." << std::endl;
       Optional nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Optional::map jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "map", "(Ljava/util/function/Function;)Ljava/util/Optional;");
       if (NULL == mid) {
           std::cerr << "Class java.util.Optional has no method named map with signature (Ljava/util/function/Function;)Ljava/util/Optional;." << std::endl;
           Optional nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid ,function_0.jthis );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    Optional retObject(retVal,false);
    return retObject;
   }
   static jclass getNewOptionalClass() {
       jclass clss = getEnv()->FindClass("java/util/Optional");
       if (NULL == clss) {
           std::cerr << " Can't find class java/util/Optional" << std::endl;
       }
       return clss;
   }
   
   static jclass OptionalClass = NULL;
   static inline jclass getOptionalClass() {
       if (OptionalClass != NULL) {
           return OptionalClass;
       }
       OptionalClass = getNewOptionalClass();
   }
    namespace stream{
    
    // get JNI handle for class java.util.stream.Stream
    static inline jclass getStreamClass();
    
    Stream::Stream(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
            // Place holder for future extensibility
    }
    
    Stream::Stream(const Stream &objref) {
        jobject _jthis = objref.jthis;
        if (_jthis != NULL) {
            jthis = getEnv()->NewGlobalRef(_jthis);
        }
    }
    Stream::Stream() {
    JNIEnv *env =getEnv();
    static jclass cls = getStreamClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class Stream has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Stream jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
    }


    // Destructor for java.util.stream.Stream
    Stream::~Stream() {
    	// Place-holder for later extensibility.
    }

    Stream Stream::iterate(::crclj::java::lang::Object  &object_0,::crclj::java::util::function::UnaryOperator  &unaryOperator_1) {

    JNIEnv *env =getEnv();
    static jclass cls = getStreamClass();
    jobject retVal=NULL;
    if (cls != NULL) {
        static jmethodID mid = env->GetStaticMethodID(cls, "iterate", "(Ljava/lang/Object;Ljava/util/function/UnaryOperator;)Ljava/util/stream/Stream;");
        if (NULL == mid) {
            std::cerr << "Class java.util.stream.Stream has no method named iterate with signature (Ljava/lang/Object;Ljava/util/function/UnaryOperator;)Ljava/util/stream/Stream;." << std::endl;
            Stream nullObject((jobject)NULL,false); return nullObject;
        } else {
            retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,object_0.jthis,unaryOperator_1.jthis );
        }
    }
    releaseEnv(env);
         
     jobjectRefType ref = env->GetObjectRefType(retVal);
     std::cout << "ref=" << ref << std::endl;
     std::cout << "retVal=" << retVal << std::endl;
     Stream retObject(retVal,false);
     return retObject;
    }
    Stream Stream::concat(Stream  &stream_0,Stream  &stream_1) {

    JNIEnv *env =getEnv();
    static jclass cls = getStreamClass();
    jobject retVal=NULL;
    if (cls != NULL) {
        static jmethodID mid = env->GetStaticMethodID(cls, "concat", "(Ljava/util/stream/Stream;Ljava/util/stream/Stream;)Ljava/util/stream/Stream;");
        if (NULL == mid) {
            std::cerr << "Class java.util.stream.Stream has no method named concat with signature (Ljava/util/stream/Stream;Ljava/util/stream/Stream;)Ljava/util/stream/Stream;." << std::endl;
            Stream nullObject((jobject)NULL,false); return nullObject;
        } else {
            retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,stream_0.jthis,stream_1.jthis );
        }
    }
    releaseEnv(env);
         
     jobjectRefType ref = env->GetObjectRefType(retVal);
     std::cout << "ref=" << ref << std::endl;
     std::cout << "retVal=" << retVal << std::endl;
     Stream retObject(retVal,false);
     return retObject;
    }
    Stream Stream::of(jobjectArray objectArray_0) {

    JNIEnv *env =getEnv();
    static jclass cls = getStreamClass();
    jobject retVal=NULL;
    if (cls != NULL) {
        static jmethodID mid = env->GetStaticMethodID(cls, "of", "([Ljava/lang/Object;)Ljava/util/stream/Stream;");
        if (NULL == mid) {
            std::cerr << "Class java.util.stream.Stream has no method named of with signature ([Ljava/lang/Object;)Ljava/util/stream/Stream;." << std::endl;
            Stream nullObject((jobject)NULL,false); return nullObject;
        } else {
            retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,objectArray_0 );
        }
    }
    releaseEnv(env);
         
     jobjectRefType ref = env->GetObjectRefType(retVal);
     std::cout << "ref=" << ref << std::endl;
     std::cout << "retVal=" << retVal << std::endl;
     Stream retObject(retVal,false);
     return retObject;
    }
    Stream Stream::of(::crclj::java::lang::Object  &object_0) {

    JNIEnv *env =getEnv();
    static jclass cls = getStreamClass();
    jobject retVal=NULL;
    if (cls != NULL) {
        static jmethodID mid = env->GetStaticMethodID(cls, "of", "(Ljava/lang/Object;)Ljava/util/stream/Stream;");
        if (NULL == mid) {
            std::cerr << "Class java.util.stream.Stream has no method named of with signature (Ljava/lang/Object;)Ljava/util/stream/Stream;." << std::endl;
            Stream nullObject((jobject)NULL,false); return nullObject;
        } else {
            retVal= (jobject)  env->CallStaticObjectMethod( cls, mid ,object_0.jthis );
        }
    }
    releaseEnv(env);
         
     jobjectRefType ref = env->GetObjectRefType(retVal);
     std::cout << "ref=" << ref << std::endl;
     std::cout << "retVal=" << retVal << std::endl;
     Stream retObject(retVal,false);
     return retObject;
    }
    Stream Stream::empty() {

    JNIEnv *env =getEnv();
    static jclass cls = getStreamClass();
    jobject retVal=NULL;
    if (cls != NULL) {
        static jmethodID mid = env->GetStaticMethodID(cls, "empty", "()Ljava/util/stream/Stream;");
        if (NULL == mid) {
            std::cerr << "Class java.util.stream.Stream has no method named empty with signature ()Ljava/util/stream/Stream;." << std::endl;
            Stream nullObject((jobject)NULL,false); return nullObject;
        } else {
            retVal= (jobject)  env->CallStaticObjectMethod( cls, mid  );
        }
    }
    releaseEnv(env);
         
     jobjectRefType ref = env->GetObjectRefType(retVal);
     std::cout << "ref=" << ref << std::endl;
     std::cout << "retVal=" << retVal << std::endl;
     Stream retObject(retVal,false);
     return retObject;
    }
    static jclass getNewStreamClass() {
        jclass clss = getEnv()->FindClass("java/util/stream/Stream");
        if (NULL == clss) {
            std::cerr << " Can't find class java/util/stream/Stream" << std::endl;
        }
        return clss;
    }
    
    static jclass StreamClass = NULL;
    static inline jclass getStreamClass() {
        if (StreamClass != NULL) {
            return StreamClass;
        }
        StreamClass = getNewStreamClass();
    }
   } // end namespace stream

   
   // get JNI handle for class java.util.Collection
   static inline jclass getCollectionClass();
   
   Collection::Collection(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
           // Place holder for future extensibility
   }
   
   Collection::Collection(const Collection &objref) {
       jobject _jthis = objref.jthis;
       if (_jthis != NULL) {
           jthis = getEnv()->NewGlobalRef(_jthis);
       }
   }
   Collection::Collection() {
   JNIEnv *env =getEnv();
   static jclass cls = getCollectionClass();
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
       if (NULL == mid) {
           std::cerr << "Class Collection has no method constructor signature ()V" << std::endl;
       } else {
           jthis = env->NewObject(cls, mid );
           jobjectRefType ref = env->GetObjectRefType(jthis);
           if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Collection jthis=",jthis);
           if(ref != JNIGlobalRefType) {
               jthis = env->NewGlobalRef(jthis);
           }
       }
   }
   releaseEnv(env);
   }


   // Destructor for java.util.Collection
   Collection::~Collection() {
   	// Place-holder for later extensibility.
   }

   stream::Stream Collection::stream() {

   if(jthis == NULL) {
       std::cerr << "Call of method stream of java.util.Collection with jthis == NULL." << std::endl;
       stream::Stream nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Collection::stream jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "stream", "()Ljava/util/stream/Stream;");
       if (NULL == mid) {
           std::cerr << "Class java.util.Collection has no method named stream with signature ()Ljava/util/stream/Stream;." << std::endl;
           stream::Stream nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    stream::Stream retObject(retVal,false);
    return retObject;
   }
   jboolean Collection::removeIf(function::Predicate  &predicate_0) {

   if(jthis == NULL) {
       std::cerr << "Call of method removeIf of java.util.Collection with jthis == NULL." << std::endl;
       return false;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Collection::removeIf jthis=",jthis);
   jboolean retVal=false;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "removeIf", "(Ljava/util/function/Predicate;)Z");
       if (NULL == mid) {
           std::cerr << "Class java.util.Collection has no method named removeIf with signature (Ljava/util/function/Predicate;)Z." << std::endl;
           return false;
       } else {
           retVal= (jboolean)  env->CallBooleanMethod(jthis, mid ,predicate_0.jthis );
       }
   }
   releaseEnv(env);
   return retVal;
   }
   stream::Stream Collection::parallelStream() {

   if(jthis == NULL) {
       std::cerr << "Call of method parallelStream of java.util.Collection with jthis == NULL." << std::endl;
       stream::Stream nullObject((jobject)NULL,false); return nullObject;
   }
   JNIEnv *env =getEnv();
   jclass cls = env->GetObjectClass(jthis);
   if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Collection::parallelStream jthis=",jthis);
   jobject retVal=NULL;
   if (cls != NULL) {
       static jmethodID mid = env->GetMethodID(cls, "parallelStream", "()Ljava/util/stream/Stream;");
       if (NULL == mid) {
           std::cerr << "Class java.util.Collection has no method named parallelStream with signature ()Ljava/util/stream/Stream;." << std::endl;
           stream::Stream nullObject((jobject)NULL,false); return nullObject;
       } else {
           retVal= (jobject)  env->CallObjectMethod(jthis, mid  );
       }
   }
   releaseEnv(env);
       
    jobjectRefType ref = env->GetObjectRefType(retVal);
    std::cout << "ref=" << ref << std::endl;
    std::cout << "retVal=" << retVal << std::endl;
    stream::Stream retObject(retVal,false);
    return retObject;
   }
   static jclass getNewCollectionClass() {
       jclass clss = getEnv()->FindClass("java/util/Collection");
       if (NULL == clss) {
           std::cerr << " Can't find class java/util/Collection" << std::endl;
       }
       return clss;
   }
   
   static jclass CollectionClass = NULL;
   static inline jclass getCollectionClass() {
       if (CollectionClass != NULL) {
           return CollectionClass;
       }
       CollectionClass = getNewCollectionClass();
   }
    namespace function{
    
    // get JNI handle for class java.util.function.Function
    static inline jclass getFunctionClass();
    
    Function::Function(jobject _jthis, bool copy): ::crclj::java::lang::Object(_jthis,copy) {
            // Place holder for future extensibility
    }
    
    Function::Function(const Function &objref) {
        jobject _jthis = objref.jthis;
        if (_jthis != NULL) {
            jthis = getEnv()->NewGlobalRef(_jthis);
        }
    }
    Function::Function() {
    JNIEnv *env =getEnv();
    static jclass cls = getFunctionClass();
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "<init>", "()V");
        if (NULL == mid) {
            std::cerr << "Class Function has no method constructor signature ()V" << std::endl;
        } else {
            jthis = env->NewObject(cls, mid );
            jobjectRefType ref = env->GetObjectRefType(jthis);
            if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," new Function jthis=",jthis);
            if(ref != JNIGlobalRefType) {
                jthis = env->NewGlobalRef(jthis);
            }
        }
    }
    releaseEnv(env);
    }


    // Destructor for java.util.function.Function
    Function::~Function() {
    	// Place-holder for later extensibility.
    }

    Function Function::compose(Function  &function_0) {

    if(jthis == NULL) {
        std::cerr << "Call of method compose of java.util.function.Function with jthis == NULL." << std::endl;
        Function nullObject((jobject)NULL,false); return nullObject;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Function::compose jthis=",jthis);
    jobject retVal=NULL;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "compose", "(Ljava/util/function/Function;)Ljava/util/function/Function;");
        if (NULL == mid) {
            std::cerr << "Class java.util.function.Function has no method named compose with signature (Ljava/util/function/Function;)Ljava/util/function/Function;." << std::endl;
            Function nullObject((jobject)NULL,false); return nullObject;
        } else {
            retVal= (jobject)  env->CallObjectMethod(jthis, mid ,function_0.jthis );
        }
    }
    releaseEnv(env);
         
     jobjectRefType ref = env->GetObjectRefType(retVal);
     std::cout << "ref=" << ref << std::endl;
     std::cout << "retVal=" << retVal << std::endl;
     Function retObject(retVal,false);
     return retObject;
    }
    Function Function::andThen(Function  &function_0) {

    if(jthis == NULL) {
        std::cerr << "Call of method andThen of java.util.function.Function with jthis == NULL." << std::endl;
        Function nullObject((jobject)NULL,false); return nullObject;
    }
    JNIEnv *env =getEnv();
    jclass cls = env->GetObjectClass(jthis);
    if(debug_j4cpp) DebugPrintJObject(__FILE__,__LINE__," Function::andThen jthis=",jthis);
    jobject retVal=NULL;
    if (cls != NULL) {
        static jmethodID mid = env->GetMethodID(cls, "andThen", "(Ljava/util/function/Function;)Ljava/util/function/Function;");
        if (NULL == mid) {
            std::cerr << "Class java.util.function.Function has no method named andThen with signature (Ljava/util/function/Function;)Ljava/util/function/Function;." << std::endl;
            Function nullObject((jobject)NULL,false); return nullObject;
        } else {
            retVal= (jobject)  env->CallObjectMethod(jthis, mid ,function_0.jthis );
        }
    }
    releaseEnv(env);
         
     jobjectRefType ref = env->GetObjectRefType(retVal);
     std::cout << "ref=" << ref << std::endl;
     std::cout << "retVal=" << retVal << std::endl;
     Function retObject(retVal,false);
     return retObject;
    }
    Function Function::identity() {

    JNIEnv *env =getEnv();
    static jclass cls = getFunctionClass();
    jobject retVal=NULL;
    if (cls != NULL) {
        static jmethodID mid = env->GetStaticMethodID(cls, "identity", "()Ljava/util/function/Function;");
        if (NULL == mid) {
            std::cerr << "Class java.util.function.Function has no method named identity with signature ()Ljava/util/function/Function;." << std::endl;
            Function nullObject((jobject)NULL,false); return nullObject;
        } else {
            retVal= (jobject)  env->CallStaticObjectMethod( cls, mid  );
        }
    }
    releaseEnv(env);
         
     jobjectRefType ref = env->GetObjectRefType(retVal);
     std::cout << "ref=" << ref << std::endl;
     std::cout << "retVal=" << retVal << std::endl;
     Function retObject(retVal,false);
     return retObject;
    }
    static jclass getNewFunctionClass() {
        jclass clss = getEnv()->FindClass("java/util/function/Function");
        if (NULL == clss) {
            std::cerr << " Can't find class java/util/function/Function" << std::endl;
        }
        return clss;
    }
    
    static jclass FunctionClass = NULL;
    static inline jclass getFunctionClass() {
        if (FunctionClass != NULL) {
            return FunctionClass;
        }
        FunctionClass = getNewFunctionClass();
    }
   } // end namespace function
  } // end namespace util
 } // end namespace java




    static JNIEnv *getNewEnv() {
        JavaVM *jvm; /* denotes a Java VM */
        JNIEnv *env; /* pointer to native method interface */
        JavaVM * jvmBuf[1];
        jsize nVMs;
        debug_j4cpp = debug_j4cpp || (getenv("DEBUG_J4CPP") != NULL);
        char *classPathEnv = getenv("CLASSPATH");
        char *jvmOptionsEnv = getenv("JVM_OPTIONS");
        std::string str;
        str += "/home/shackle/crac/CRCLJava/target/CRCLJava-1.0-SNAPSHOT-jar-with-dependencies.jar";
        if (classPathEnv != NULL) {
            std::string classPathEnvStr(classPathEnv);
            if (debug_j4cpp) std::cout << "classPathEnv=" << classPathEnvStr << std::endl;
            str += ":";
            str += classPathEnvStr;
        }
        if (debug_j4cpp) std::cout << "str=" << str << std::endl;
        setenv("CLASSPATH", str.c_str(), 1);
        std::string optsString;
        optsString += "-Djava.class.path=";
        optsString += str;
        if (jvmOptionsEnv != NULL) {
            std::string jvmOptionsEnvStr(jvmOptionsEnv);
            if (debug_j4cpp) std::cout << "jvmOptionsEnvStr=" << jvmOptionsEnvStr << std::endl;
            optsString += " ";
            optsString += jvmOptionsEnvStr;
        }
        if (debug_j4cpp) std::cout << "optsString=" << optsString << std::endl;
        jint v = JNI_GetCreatedJavaVMs(jvmBuf, 1, &nVMs);
        if (nVMs > 0) {
            jvmBuf[0]->GetEnv((void **) &env, JNI_VERSION_1_6);
            return env;
        }
        JavaVMInitArgs vm_args; /* JDK/JRE 6 VM initialization arguments */
        JavaVMOption* options = new JavaVMOption[1];
        options[0].optionString = (char *) optsString.c_str();
        vm_args.version = JNI_VERSION_1_6;
        vm_args.nOptions = NULL != options[0].optionString ? 1 : 0;
        vm_args.options = options;
        vm_args.ignoreUnrecognized = false;
        /* load and initialize a Java VM, return a JNI interface
         * pointer in env */
        JNI_CreateJavaVM(&jvm,
                ((void **) (&env)),
                ((void *) (&vm_args)));
        delete options;
        return env;
    }

    static JNIEnv *env = NULL;

    JNIEnv *getEnv() {
        if (env != NULL) {
            return env;
        }
        env = getNewEnv();
        return env;
    }

    void releaseEnv(JNIEnv *env) {
        // Maybe implement this later, 
        // This will probably cause a memory leak.
        // Don't like leaks? Why the hell are using C++?
    }

    static jclass getNewStringClass() {
        jclass clss = getEnv()->FindClass("java/lang/String");
        if (NULL == clss) {
            std::cerr << " Can't find class java/lang/String" << std::endl;
        }
        return clss;
    }

    static jclass StringClass = NULL;

    static inline jclass getStringClass() {
        if (StringClass != NULL) {
            return StringClass;
        }
        StringClass = getNewStringClass();
        return StringClass;
    }

    static jstring getNewEmptyString() {
        return getEnv()->NewStringUTF("");
    }

    static jstring EmptyString = NULL;

    static inline jstring getEmptyString() {
        if (EmptyString != NULL) {
            return EmptyString;
        }
        EmptyString = getNewEmptyString();
        return EmptyString;
    }

    void PrintJObject(const char *prefix, jobject jobj) {
        JNIEnv *env = getEnv();
        jclass clss = env->GetObjectClass(jobj);
        jmethodID midToString = env->GetMethodID(clss, "toString", "()Ljava/lang/String;");
        jstring jobjstr = (jstring) env->CallObjectMethod(jobj, midToString);
        jboolean iscopy = JNI_FALSE;
        const char *cstr = env->GetStringUTFChars(jobjstr, &iscopy);
        std::cout << prefix << cstr << std::endl;
        env->ReleaseStringUTFChars(jobjstr,cstr);
    }
    
    void DebugPrintJObject(const char *file, int lineno, const char *prefix, jobject jobj) {
        JNIEnv *env = getEnv();
        jclass clss = env->GetObjectClass(jobj);
        bool isnull = (jobj == NULL) || (env->IsSameObject(jobj,NULL) == JNI_TRUE);
        if(isnull) {
            std::cout << file << ":" << lineno << " jobj=" << jobj << " " << prefix << "NULL" << std::endl;
            return;
        }
        jmethodID midToString = env->GetMethodID(clss, "toString", "()Ljava/lang/String;");
        jstring jobjstr = (jstring) env->CallObjectMethod(jobj, midToString);
        jboolean iscopy = JNI_FALSE;
        const char *cstr = env->GetStringUTFChars(jobjstr, &iscopy);
        std::cout << file << ":" << lineno << " jobj=" << jobj << " " << prefix << cstr << std::endl;
        env->ReleaseStringUTFChars(jobjstr,cstr);
    }
    
    void PrintObject(const char *prefix, const ::crclj::java::lang::Object &objref) {
        PrintJObject(prefix,objref.jthis);
    }
    
    extern void SetDebugJ4Cpp(bool debug) {
        debug_j4cpp = debug;
    }
    
    extern bool GetDebugJ4Cpp() { 
        return debug_j4cpp;
    }
    // end namespace crclj
}

